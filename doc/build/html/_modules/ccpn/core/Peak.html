
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ccpn.core.Peak &#8212; Python  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/classic.css" />
    
    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">Python  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">ccpn.core.Peak</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for ccpn.core.Peak</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c1">#=========================================================================================</span>
<span class="c1"># Licence, Reference and Credits</span>
<span class="c1">#=========================================================================================</span>
<span class="n">__copyright__</span> <span class="o">=</span> <span class="s2">&quot;Copyright (C) CCPN project (https://www.ccpn.ac.uk) 2014 - 2022&quot;</span>
<span class="n">__credits__</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Ed Brooksbank, Joanna Fox, Victoria A Higman, Luca Mureddu, Eliza Płoskoń&quot;</span><span class="p">,</span>
               <span class="s2">&quot;Timothy J Ragan, Brian O Smith, Gary S Thompson &amp; Geerten W Vuister&quot;</span><span class="p">)</span>
<span class="n">__licence__</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;CCPN licence. See https://ccpn.ac.uk/software/licensing/&quot;</span><span class="p">)</span>
<span class="n">__reference__</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Skinner, S.P., Fogh, R.H., Boucher, W., Ragan, T.J., Mureddu, L.G., &amp; Vuister, G.W.&quot;</span><span class="p">,</span>
                 <span class="s2">&quot;CcpNmr AnalysisAssign: a flexible platform for integrated NMR analysis&quot;</span><span class="p">,</span>
                 <span class="s2">&quot;J.Biomol.Nmr (2016), 66, 111-124, http://doi.org/10.1007/s10858-016-0060-y&quot;</span><span class="p">)</span>
<span class="c1">#=========================================================================================</span>
<span class="c1"># Last code modification</span>
<span class="c1">#=========================================================================================</span>
<span class="n">__modifiedBy__</span> <span class="o">=</span> <span class="s2">&quot;$modifiedBy: Ed Brooksbank $&quot;</span>
<span class="n">__dateModified__</span> <span class="o">=</span> <span class="s2">&quot;$dateModified: 2022-07-05 13:20:37 +0100 (Tue, July 05, 2022) $&quot;</span>
<span class="n">__version__</span> <span class="o">=</span> <span class="s2">&quot;$Revision: 3.1.0 $&quot;</span>
<span class="c1">#=========================================================================================</span>
<span class="c1"># Created</span>
<span class="c1">#=========================================================================================</span>
<span class="n">__author__</span> <span class="o">=</span> <span class="s2">&quot;$Author: CCPN $&quot;</span>
<span class="n">__date__</span> <span class="o">=</span> <span class="s2">&quot;$Date: 2017-04-07 10:28:41 +0000 (Fri, April 07, 2017) $&quot;</span>
<span class="c1">#=========================================================================================</span>
<span class="c1"># Start of code</span>
<span class="c1">#=========================================================================================</span>

<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Any</span>

<span class="kn">from</span> <span class="nn">ccpn.core.lib.AxisCodeLib</span> <span class="kn">import</span> <span class="n">_axisCodeMapIndices</span>
<span class="kn">from</span> <span class="nn">ccpn.util</span> <span class="kn">import</span> <span class="n">Common</span> <span class="k">as</span> <span class="n">commonUtil</span>
<span class="kn">from</span> <span class="nn">ccpn.core._implementation.AbstractWrapperObject</span> <span class="kn">import</span> <span class="n">AbstractWrapperObject</span>
<span class="kn">from</span> <span class="nn">ccpn.core.Project</span> <span class="kn">import</span> <span class="n">Project</span>
<span class="kn">from</span> <span class="nn">ccpn.core.PeakList</span> <span class="kn">import</span> <span class="n">PeakList</span><span class="p">,</span> <span class="n">PARABOLICMETHOD</span>
<span class="kn">from</span> <span class="nn">ccpn.core.NmrAtom</span> <span class="kn">import</span> <span class="n">NmrAtom</span>
<span class="kn">from</span> <span class="nn">ccpnmodel.ccpncore.api.ccp.nmr</span> <span class="kn">import</span> <span class="n">Nmr</span>
<span class="kn">from</span> <span class="nn">ccpn.core.lib.peakUtils</span> <span class="kn">import</span> <span class="n">_getPeakSNRatio</span><span class="p">,</span> <span class="n">snapToExtremum</span> <span class="k">as</span> <span class="n">peakUtilsSnapToExtremum</span>
<span class="kn">from</span> <span class="nn">ccpn.util.decorators</span> <span class="kn">import</span> <span class="n">logCommand</span>
<span class="kn">from</span> <span class="nn">ccpn.core.lib.ContextManagers</span> <span class="kn">import</span> <span class="n">newObject</span><span class="p">,</span> <span class="n">ccpNmrV3CoreSetter</span><span class="p">,</span> \
    <span class="n">undoBlock</span><span class="p">,</span> <span class="n">undoBlockWithoutSideBar</span><span class="p">,</span> <span class="n">undoStackBlocking</span><span class="p">,</span> <span class="n">ccpNmrV3CoreUndoBlock</span>
<span class="kn">from</span> <span class="nn">ccpn.util.Logging</span> <span class="kn">import</span> <span class="n">getLogger</span>
<span class="kn">from</span> <span class="nn">ccpn.util.Common</span> <span class="kn">import</span> <span class="n">makeIterableList</span><span class="p">,</span> <span class="n">isIterable</span>
<span class="kn">from</span> <span class="nn">ccpn.util.Constants</span> <span class="kn">import</span> <span class="n">SCALETOLERANCE</span>
<span class="kn">from</span> <span class="nn">ccpn.core.NmrAtom</span> <span class="kn">import</span> <span class="n">UnknownIsotopeCode</span>


<div class="viewcode-block" id="Peak"><a class="viewcode-back" href="../../../ccpn/ccpn.core.html#ccpn.core.Peak.Peak">[docs]</a><span class="k">class</span> <span class="nc">Peak</span><span class="p">(</span><span class="n">AbstractWrapperObject</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Peak object, holding position, intensity, and assignment information</span>

<span class="sd">    Measurements that require more than one NmrAtom for an individual assignment</span>
<span class="sd">    (such as  splittings, J-couplings, MQ dimensions, reduced-dimensionality</span>
<span class="sd">    experiments etc.) are not supported (yet). Assignments can be viewed and set</span>
<span class="sd">    either as a list of assignments for each dimension (dimensionNmrAtoms) or as a</span>
<span class="sd">    list of all possible assignment combinations (assignedNmrAtoms)&quot;&quot;&quot;</span>

    <span class="c1">#: Short class name, for PID.</span>
    <span class="n">shortClassName</span> <span class="o">=</span> <span class="s1">&#39;PK&#39;</span>
    <span class="c1"># Attribute it necessary as subclasses must use superclass className</span>
    <span class="n">className</span> <span class="o">=</span> <span class="s1">&#39;Peak&#39;</span>

    <span class="n">_parentClass</span> <span class="o">=</span> <span class="n">PeakList</span>

    <span class="c1">#: Name of plural link to instances of class</span>
    <span class="n">_pluralLinkName</span> <span class="o">=</span> <span class="s1">&#39;peaks&#39;</span>

    <span class="c1"># the attribute name used by current</span>
    <span class="n">_currentAttributeName</span> <span class="o">=</span> <span class="s1">&#39;peaks&#39;</span>

    <span class="c1">#: List of child classes.</span>
    <span class="n">_childClasses</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Qualified name of matching API class</span>
    <span class="n">_apiClassQualifiedName</span> <span class="o">=</span> <span class="n">Nmr</span><span class="o">.</span><span class="n">Peak</span><span class="o">.</span><span class="n">_metaclass</span><span class="o">.</span><span class="n">qualifiedName</span><span class="p">()</span>

    <span class="c1"># CCPN properties</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_apiPeak</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Nmr</span><span class="o">.</span><span class="n">Peak</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;API peaks matching Peak&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_key</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;id string - serial number converted to string.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">serial</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">serial</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;serial number of Peak, used in Pid and to identify the Peak.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">serial</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_parent</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">PeakList</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;PeakList containing Peak.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_project</span><span class="o">.</span><span class="n">_data2Obj</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">peakList</span><span class="p">]</span> \
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">peakList</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_project</span><span class="o">.</span><span class="n">_data2Obj</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="n">peakList</span> <span class="o">=</span> <span class="n">_parent</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spectrum</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convenience property to get the spectrum, equivalent to peak.peakList.spectrum</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">peakList</span><span class="o">.</span><span class="n">spectrum</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">chemicalShiftList</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convenience property to get the spectrum, equivalent to peak.peakList.chemicalShiftList</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">peakList</span><span class="o">.</span><span class="n">chemicalShiftList</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">restraints</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Restraints corresponding to Peak&quot;&quot;&quot;</span>
        <span class="c1"># placeholder, hotfixed later</span>
        <span class="k">pass</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">height</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;height of Peak.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">height</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peakList</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">scale</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="n">scale</span> <span class="k">if</span> <span class="n">scale</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mf">1.0</span>
        <span class="k">if</span> <span class="o">-</span><span class="n">SCALETOLERANCE</span> <span class="o">&lt;</span> <span class="n">scale</span> <span class="o">&lt;</span> <span class="n">SCALETOLERANCE</span><span class="p">:</span>
            <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Scaling </span><span class="si">{}</span><span class="s1">.height by minimum tolerance (±</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">SCALETOLERANCE</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">height</span> <span class="o">*</span> <span class="n">scale</span>

    <span class="nd">@height</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@logCommand</span><span class="p">(</span><span class="n">get</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">,</span> <span class="n">isProperty</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nd">@ccpNmrV3CoreSetter</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">height</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">))):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;height must be a float, integer or None&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="n">value</span> <span class="o">-</span> <span class="n">value</span><span class="p">)</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;height cannot be NaN or Infinity&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">height</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peakList</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">scale</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="n">scale</span> <span class="k">if</span> <span class="n">scale</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mf">1.0</span>
            <span class="k">if</span> <span class="o">-</span><span class="n">SCALETOLERANCE</span> <span class="o">&lt;</span> <span class="n">scale</span> <span class="o">&lt;</span> <span class="n">SCALETOLERANCE</span><span class="p">:</span>
                <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Scaling </span><span class="si">{}</span><span class="s1">.height by minimum tolerance (±</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">SCALETOLERANCE</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">height</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">height</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">/</span> <span class="n">scale</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">heightError</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;height error of Peak.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">heightError</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peakList</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">scale</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="n">scale</span> <span class="k">if</span> <span class="n">scale</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mf">1.0</span>
        <span class="k">if</span> <span class="o">-</span><span class="n">SCALETOLERANCE</span> <span class="o">&lt;</span> <span class="n">scale</span> <span class="o">&lt;</span> <span class="n">SCALETOLERANCE</span><span class="p">:</span>
            <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Scaling </span><span class="si">{}</span><span class="s1">.heightError by minimum tolerance (±</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">SCALETOLERANCE</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">heightError</span> <span class="o">*</span> <span class="n">scale</span>

    <span class="nd">@heightError</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@logCommand</span><span class="p">(</span><span class="n">get</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">,</span> <span class="n">isProperty</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nd">@ccpNmrV3CoreSetter</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">heightError</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">))):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;heightError must be a float, integer or None&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="n">value</span> <span class="o">-</span> <span class="n">value</span><span class="p">)</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;heightError cannot be NaN or Infinity&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">heightError</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peakList</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">scale</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="n">scale</span> <span class="k">if</span> <span class="n">scale</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mf">1.0</span>
            <span class="k">if</span> <span class="o">-</span><span class="n">SCALETOLERANCE</span> <span class="o">&lt;</span> <span class="n">scale</span> <span class="o">&lt;</span> <span class="n">SCALETOLERANCE</span><span class="p">:</span>
                <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Scaling </span><span class="si">{}</span><span class="s1">.heightError by minimum tolerance (±</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">SCALETOLERANCE</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">heightError</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">heightError</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">/</span> <span class="n">scale</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">volume</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;volume of Peak.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">volume</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peakList</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">scale</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="n">scale</span> <span class="k">if</span> <span class="n">scale</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mf">1.0</span>
        <span class="k">if</span> <span class="o">-</span><span class="n">SCALETOLERANCE</span> <span class="o">&lt;</span> <span class="n">scale</span> <span class="o">&lt;</span> <span class="n">SCALETOLERANCE</span><span class="p">:</span>
            <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Scaling </span><span class="si">{}</span><span class="s1">.volume by minimum tolerance (±</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">SCALETOLERANCE</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">volume</span> <span class="o">*</span> <span class="n">scale</span>

    <span class="nd">@volume</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@logCommand</span><span class="p">(</span><span class="n">get</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">,</span> <span class="n">isProperty</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nd">@ccpNmrV3CoreSetter</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">volume</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">))):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;volume must be a float, integer or None&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="n">value</span> <span class="o">-</span> <span class="n">value</span><span class="p">)</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;volume cannot be NaN or Infinity&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">volume</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peakList</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">scale</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="n">scale</span> <span class="k">if</span> <span class="n">scale</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mf">1.0</span>
            <span class="k">if</span> <span class="o">-</span><span class="n">SCALETOLERANCE</span> <span class="o">&lt;</span> <span class="n">scale</span> <span class="o">&lt;</span> <span class="n">SCALETOLERANCE</span><span class="p">:</span>
                <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Scaling </span><span class="si">{}</span><span class="s1">.volume by minimum tolerance (±</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">SCALETOLERANCE</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">volume</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">volume</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">/</span> <span class="n">scale</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">volumeError</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;volume error of Peak.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">volumeError</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peakList</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">scale</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="n">scale</span> <span class="k">if</span> <span class="n">scale</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mf">1.0</span>
        <span class="k">if</span> <span class="o">-</span><span class="n">SCALETOLERANCE</span> <span class="o">&lt;</span> <span class="n">scale</span> <span class="o">&lt;</span> <span class="n">SCALETOLERANCE</span><span class="p">:</span>
            <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Scaling </span><span class="si">{}</span><span class="s1">.volumeError by minimum tolerance (±</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">SCALETOLERANCE</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">volumeError</span> <span class="o">*</span> <span class="n">scale</span>

    <span class="nd">@volumeError</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@logCommand</span><span class="p">(</span><span class="n">get</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">,</span> <span class="n">isProperty</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nd">@ccpNmrV3CoreSetter</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">volumeError</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">))):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;volumeError must be a float, integer or None&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="n">value</span> <span class="o">-</span> <span class="n">value</span><span class="p">)</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;volumeError cannot be NaN or Infinity&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">volumeError</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peakList</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">scale</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="n">scale</span> <span class="k">if</span> <span class="n">scale</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mf">1.0</span>
            <span class="k">if</span> <span class="o">-</span><span class="n">SCALETOLERANCE</span> <span class="o">&lt;</span> <span class="n">scale</span> <span class="o">&lt;</span> <span class="n">SCALETOLERANCE</span><span class="p">:</span>
                <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Scaling </span><span class="si">{}</span><span class="s1">.volumeError by minimum tolerance (±</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">SCALETOLERANCE</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">volumeError</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">volumeError</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">/</span> <span class="n">scale</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">figureOfMerit</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;figureOfMerit of Peak, between 0.0 and 1.0 inclusive.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">figOfMerit</span>

    <span class="nd">@figureOfMerit</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@logCommand</span><span class="p">(</span><span class="n">get</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">,</span> <span class="n">isProperty</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nd">@ccpNmrV3CoreSetter</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">figureOfMerit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">figOfMerit</span> <span class="o">==</span> <span class="n">value</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">figOfMerit</span> <span class="o">=</span> <span class="n">value</span>

        <span class="c1"># recalculate the shifts</span>
        <span class="n">assigned</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">makeIterableList</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">assignments</span><span class="p">))</span>
        <span class="n">shifts</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">cs</span> <span class="k">for</span> <span class="n">nmrAt</span> <span class="ow">in</span> <span class="n">assigned</span> <span class="k">for</span> <span class="n">cs</span> <span class="ow">in</span> <span class="n">nmrAt</span><span class="o">.</span><span class="n">chemicalShifts</span> <span class="k">if</span> <span class="n">cs</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">cs</span><span class="o">.</span><span class="n">isDeleted</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_childActions</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">sh</span><span class="o">.</span><span class="n">_recalculateShiftValue</span> <span class="k">for</span> <span class="n">sh</span> <span class="ow">in</span> <span class="n">shifts</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_finaliseChildren</span><span class="o">.</span><span class="n">extend</span><span class="p">((</span><span class="n">sh</span><span class="p">,</span> <span class="s1">&#39;change&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">sh</span> <span class="ow">in</span> <span class="n">shifts</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">annotation</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Peak text annotation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">annotation</span>

    <span class="nd">@annotation</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@logCommand</span><span class="p">(</span><span class="n">get</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">,</span> <span class="n">isProperty</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nd">@ccpNmrV3CoreSetter</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">annotation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">))):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;annotation must be a string or None&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">annotation</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">axisCodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Spectrum axis codes in dimension order matching position.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">axisCodes</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">position</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Peak position in ppm (or other relevant unit) in dimension order.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">value</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">sortedPeakDims</span><span class="p">())</span>

    <span class="nd">@position</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@logCommand</span><span class="p">(</span><span class="n">get</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">,</span> <span class="n">isProperty</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nd">@ccpNmrV3CoreSetter</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">position</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">):</span>
        <span class="c1"># call api changes</span>
        <span class="n">shifts</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">ff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_project</span><span class="o">.</span><span class="n">_data2Obj</span><span class="o">.</span><span class="n">get</span>

        <span class="n">dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">sortedPeakDims</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">.ppmPositions must be None or tuple|list of length </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">peakDim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dims</span><span class="p">):</span>
            <span class="n">_old</span> <span class="o">=</span> <span class="n">peakDim</span><span class="o">.</span><span class="n">position</span>  <span class="c1"># the current pointPosition, quick to get</span>
            <span class="n">peakDim</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="k">if</span> <span class="n">value</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="n">peakDim</span><span class="o">.</span><span class="n">realValue</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="c1"># log any peak assignments that have moved in this axis</span>
            <span class="k">if</span> <span class="n">peakDim</span><span class="o">.</span><span class="n">position</span> <span class="o">!=</span> <span class="n">_old</span><span class="p">:</span>
                <span class="n">assigned</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">ff</span><span class="p">(</span><span class="n">pdc</span><span class="o">.</span><span class="n">resonance</span><span class="p">)</span> <span class="k">for</span> <span class="n">pdc</span> <span class="ow">in</span> <span class="n">peakDim</span><span class="o">.</span><span class="n">mainPeakDimContribs</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">pdc</span><span class="p">,</span> <span class="s1">&#39;resonance&#39;</span><span class="p">)])</span>
                <span class="n">shifts</span> <span class="o">|=</span> <span class="nb">set</span><span class="p">(</span><span class="n">sh</span> <span class="k">for</span> <span class="n">nmrAt</span> <span class="ow">in</span> <span class="n">assigned</span> <span class="k">for</span> <span class="n">sh</span> <span class="ow">in</span> <span class="n">nmrAt</span><span class="o">.</span><span class="n">chemicalShifts</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_childActions</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">sh</span><span class="o">.</span><span class="n">_recalculateShiftValue</span> <span class="k">for</span> <span class="n">sh</span> <span class="ow">in</span> <span class="n">shifts</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_finaliseChildren</span><span class="o">.</span><span class="n">extend</span><span class="p">((</span><span class="n">sh</span><span class="p">,</span> <span class="s1">&#39;change&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">sh</span> <span class="ow">in</span> <span class="n">shifts</span><span class="p">)</span>

    <span class="n">ppmPositions</span> <span class="o">=</span> <span class="n">position</span>

    <span class="c1"># @property</span>
    <span class="c1"># def ppmPositions(self) -&gt; Tuple[float, ...]:</span>
    <span class="c1">#     &quot;&quot;&quot;Peak position in ppm (or other relevant unit) in dimension order.&quot;&quot;&quot;</span>
    <span class="c1">#     return tuple(x.value for x in self._wrappedData.sortedPeakDims())</span>
    <span class="c1">#</span>
    <span class="c1"># @ppmPositions.setter</span>
    <span class="c1"># @logCommand(get=&#39;self&#39;, isProperty=True)</span>
    <span class="c1"># @ccpNmrV3CoreSetter()</span>
    <span class="c1"># def ppmPositions(self, value: Sequence):</span>
    <span class="c1">#     # call api changes</span>
    <span class="c1">#     for ii, peakDim in enumerate(self._wrappedData.sortedPeakDims()):</span>
    <span class="c1">#         peakDim.value = value[ii]</span>
    <span class="c1">#         peakDim.realValue = None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">positionError</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="o">...</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Peak position error in ppm (or other relevant unit).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">valueError</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">sortedPeakDims</span><span class="p">())</span>

    <span class="nd">@positionError</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@logCommand</span><span class="p">(</span><span class="n">get</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">,</span> <span class="n">isProperty</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nd">@ccpNmrV3CoreSetter</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">positionError</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">peakDim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">sortedPeakDims</span><span class="p">()):</span>
            <span class="n">peakDim</span><span class="o">.</span><span class="n">valueError</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pointPositions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Peak position in points.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">position</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">sortedPeakDims</span><span class="p">())</span>

    <span class="nd">@pointPositions</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@logCommand</span><span class="p">(</span><span class="n">get</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">,</span> <span class="n">isProperty</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nd">@ccpNmrV3CoreSetter</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">pointPositions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">):</span>
        <span class="n">shifts</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">ff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_project</span><span class="o">.</span><span class="n">_data2Obj</span><span class="o">.</span><span class="n">get</span>

        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">peakDim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">sortedPeakDims</span><span class="p">()):</span>
            <span class="n">_old</span> <span class="o">=</span> <span class="n">peakDim</span><span class="o">.</span><span class="n">position</span>  <span class="c1"># the current pointPositions</span>
            <span class="n">peakDim</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>

            <span class="c1"># log any peak assignments that have moved in this axis</span>
            <span class="k">if</span> <span class="n">peakDim</span><span class="o">.</span><span class="n">position</span> <span class="o">!=</span> <span class="n">_old</span><span class="p">:</span>
                <span class="n">assigned</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">ff</span><span class="p">(</span><span class="n">pdc</span><span class="o">.</span><span class="n">resonance</span><span class="p">)</span> <span class="k">for</span> <span class="n">pdc</span> <span class="ow">in</span> <span class="n">peakDim</span><span class="o">.</span><span class="n">mainPeakDimContribs</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">pdc</span><span class="p">,</span> <span class="s1">&#39;resonance&#39;</span><span class="p">)])</span>
                <span class="n">shifts</span> <span class="o">|=</span> <span class="nb">set</span><span class="p">(</span><span class="n">sh</span> <span class="k">for</span> <span class="n">nmrAt</span> <span class="ow">in</span> <span class="n">assigned</span> <span class="k">for</span> <span class="n">sh</span> <span class="ow">in</span> <span class="n">nmrAt</span><span class="o">.</span><span class="n">chemicalShifts</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_childActions</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">sh</span><span class="o">.</span><span class="n">_recalculateShiftValue</span> <span class="k">for</span> <span class="n">sh</span> <span class="ow">in</span> <span class="n">shifts</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_finaliseChildren</span><span class="o">.</span><span class="n">extend</span><span class="p">((</span><span class="n">sh</span><span class="p">,</span> <span class="s1">&#39;change&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">sh</span> <span class="ow">in</span> <span class="n">shifts</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">boxWidths</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="o">...</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;The full width of the peak footprint in points for each dimension,</span>
<span class="sd">        i.e. the width of the area that should be considered for integration, fitting, etc.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">boxWidth</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">sortedPeakDims</span><span class="p">())</span>

    <span class="nd">@boxWidths</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@logCommand</span><span class="p">(</span><span class="n">get</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">,</span> <span class="n">isProperty</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nd">@ccpNmrV3CoreSetter</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">boxWidths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">peakDim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">sortedPeakDims</span><span class="p">()):</span>
            <span class="n">peakDim</span><span class="o">.</span><span class="n">boxWidth</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">lineWidths</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="o">...</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Full-width-half-height of peak for each dimension, in Hz/ppm.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">lineWidth</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">sortedPeakDims</span><span class="p">())</span>

    <span class="nd">@lineWidths</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@logCommand</span><span class="p">(</span><span class="n">get</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">,</span> <span class="n">isProperty</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nd">@ccpNmrV3CoreSetter</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">lineWidths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">peakDim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">sortedPeakDims</span><span class="p">()):</span>
            <span class="n">peakDim</span><span class="o">.</span><span class="n">lineWidth</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>

    <span class="c1"># @property</span>
    <span class="c1"># def ppmLineWidths(self) -&gt; Tuple[Optional[float], ...]:</span>
    <span class="c1">#     &quot;&quot;&quot;Full-width-half-height of peak for each dimension, in ppm.&quot;&quot;&quot;</span>
    <span class="c1">#     return tuple(peakDim.lineWidth * peakDim.dataDim.valuePerPoint if peakDim.lineWidth is not None else None</span>
    <span class="c1">#                  for peakDim in self._wrappedData.sortedPeakDims())</span>
    <span class="c1">#</span>
    <span class="c1"># @ppmLineWidths.setter</span>
    <span class="c1"># @logCommand(get=&#39;self&#39;, isProperty=True)</span>
    <span class="c1"># @ccpNmrV3CoreSetter()</span>
    <span class="c1"># def ppmLineWidths(self, value: Sequence):</span>
    <span class="c1">#     for ii, peakDim in enumerate(self._wrappedData.sortedPeakDims()):</span>
    <span class="c1">#         peakDim.lineWidth = value[ii] / peakDim.dataDim.valuePerPoint if value[ii] is not None else None</span>

    <span class="n">ppmLineWidths</span> <span class="o">=</span> <span class="n">lineWidths</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pointLineWidths</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="o">...</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Full-width-half-height of peak for each dimension, in points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># currently assumes that internal storage is in ppm&#39;s; GWV thinks Hz????</span>

        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">peakDim</span><span class="p">,</span> <span class="n">valuePerPoint</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">sortedPeakDims</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">_valuePerPoints</span><span class="p">):</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">peakDim</span><span class="o">.</span><span class="n">lineWidth</span> <span class="o">/</span> <span class="n">valuePerPoint</span> <span class="k">if</span> <span class="n">peakDim</span><span class="o">.</span><span class="n">lineWidth</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="nd">@pointLineWidths</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@logCommand</span><span class="p">(</span><span class="n">get</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">,</span> <span class="n">isProperty</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nd">@ccpNmrV3CoreSetter</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">pointLineWidths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">val</span><span class="p">,</span> <span class="n">peakDim</span><span class="p">,</span> <span class="n">valuePerPoint</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">value</span><span class="p">,</span>
                                               <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">sortedPeakDims</span><span class="p">(),</span>
                                               <span class="bp">self</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">_valuePerPoints</span><span class="p">):</span>
            <span class="n">peakDim</span><span class="o">.</span><span class="n">lineWidth</span> <span class="o">=</span> <span class="n">val</span> <span class="o">*</span> <span class="n">valuePerPoint</span> <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">aliasing</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="o">...</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Aliasing for the peak in each dimension.</span>
<span class="sd">        Defined as integer number of spectralWidths added or subtracted along each dimension</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">aliasing</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">peakDim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">sortedPeakDims</span><span class="p">():</span>
            <span class="n">axisReversed</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">expDimRef</span> <span class="o">=</span> <span class="n">peakDim</span><span class="o">.</span><span class="n">dataDim</span><span class="o">.</span><span class="n">expDim</span><span class="o">.</span><span class="n">findFirstExpDimRef</span><span class="p">(</span><span class="n">serial</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">expDimRef</span><span class="p">:</span>
                <span class="n">axisReversed</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">expDimRef</span><span class="o">.</span><span class="n">isAxisReversed</span> <span class="k">else</span> <span class="mi">1</span>
            <span class="n">aliasing</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">axisReversed</span> <span class="o">*</span> <span class="n">peakDim</span><span class="o">.</span><span class="n">numAliasing</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">aliasing</span><span class="p">)</span>

    <span class="nd">@aliasing</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@logCommand</span><span class="p">(</span><span class="n">get</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">,</span> <span class="n">isProperty</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nd">@ccpNmrV3CoreSetter</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">aliasing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">sortedPeakDims</span><span class="p">()):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Length of </span><span class="si">%s</span><span class="s2"> does not match number of dimensions.&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">dimVal</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">dimVal</span> <span class="ow">in</span> <span class="n">value</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Aliasing values must be integer.&quot;</span><span class="p">)</span>

        <span class="c1"># call api changes</span>
        <span class="n">shifts</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">ff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_project</span><span class="o">.</span><span class="n">_data2Obj</span><span class="o">.</span><span class="n">get</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">peakDim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">sortedPeakDims</span><span class="p">()):</span>
            <span class="c1"># log any peak assignments that have moved in this axis</span>
            <span class="k">if</span> <span class="n">peakDim</span><span class="o">.</span><span class="n">numAliasing</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">value</span><span class="p">[</span><span class="n">ii</span><span class="p">]:</span>
                <span class="n">assigned</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">ff</span><span class="p">(</span><span class="n">pdc</span><span class="o">.</span><span class="n">resonance</span><span class="p">)</span> <span class="k">for</span> <span class="n">pdc</span> <span class="ow">in</span> <span class="n">peakDim</span><span class="o">.</span><span class="n">mainPeakDimContribs</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">pdc</span><span class="p">,</span> <span class="s1">&#39;resonance&#39;</span><span class="p">)])</span>
                <span class="n">peakDim</span><span class="o">.</span><span class="n">numAliasing</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">value</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>

                <span class="n">shifts</span> <span class="o">|=</span> <span class="nb">set</span><span class="p">(</span><span class="n">sh</span> <span class="k">for</span> <span class="n">nmrAt</span> <span class="ow">in</span> <span class="n">assigned</span> <span class="k">for</span> <span class="n">sh</span> <span class="ow">in</span> <span class="n">nmrAt</span><span class="o">.</span><span class="n">chemicalShifts</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_childActions</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">sh</span><span class="o">.</span><span class="n">_recalculateShiftValue</span> <span class="k">for</span> <span class="n">sh</span> <span class="ow">in</span> <span class="n">shifts</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_finaliseChildren</span><span class="o">.</span><span class="n">extend</span><span class="p">((</span><span class="n">sh</span><span class="p">,</span> <span class="s1">&#39;change&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">sh</span> <span class="ow">in</span> <span class="n">shifts</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dimensionNmrAtoms</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="s1">&#39;NmrAtom&#39;</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="o">...</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Peak dimension assignment - a tuple of tuples with the assigned NmrAtoms for each dimension.</span>
<span class="sd">        One of two alternative views on the Peak assignment.</span>

<span class="sd">        Example, for a 13C HSQC:</span>
<span class="sd">          ((&lt;NA:A.127.LEU.HA&gt;, &lt;NA:A.127.LEU.HBX&gt;, &lt;NA:A.127.LEU.HBY&gt;, &lt;NA:A.127.LEU.HG&gt;,</span>

<span class="sd">           (&lt;NA:A.127.LEU.CA&gt;, &lt;NA:A.127.LEU.CB&gt;)</span>
<span class="sd">           )</span>

<span class="sd">        Assignments as a list of individual combinations is given in &#39;assignedNmrAtoms&#39;.</span>
<span class="sd">        Note that by setting dimensionAssignments you tel the program that all combinations are</span>
<span class="sd">        possible - in the example that all four protons could be bound to either of the carbons</span>

<span class="sd">        To (re)set the assignment for a single dimension, use the Peak.assignDimension method.&quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">peakDim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">sortedPeakDims</span><span class="p">():</span>
            <span class="n">mainPeakDimContribs</span> <span class="o">=</span> <span class="n">peakDim</span><span class="o">.</span><span class="n">mainPeakDimContribs</span>
            <span class="c1"># Done this way as a quick way of sorting the values</span>
            <span class="n">mainPeakDimContribs</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">peakDim</span><span class="o">.</span><span class="n">sortedPeakDimContribs</span><span class="p">()</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">mainPeakDimContribs</span><span class="p">]</span>

            <span class="n">data2Obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_project</span><span class="o">.</span><span class="n">_data2Obj</span>
            <span class="n">dimResults</span> <span class="o">=</span> <span class="p">[</span><span class="n">data2Obj</span><span class="p">[</span><span class="n">pdc</span><span class="o">.</span><span class="n">resonance</span><span class="p">]</span> <span class="k">for</span> <span class="n">pdc</span> <span class="ow">in</span> <span class="n">mainPeakDimContribs</span>
                          <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">pdc</span><span class="p">,</span> <span class="s1">&#39;resonance&#39;</span><span class="p">)]</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">dimResults</span><span class="p">)))</span>
        <span class="c1">#</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_dimensionNmrAtoms</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="s1">&#39;NmrAtom&#39;</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="o">...</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Transparent method to control notifiers&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensionNmrAtoms</span>

    <span class="nd">@_dimensionNmrAtoms</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@ccpNmrV3CoreUndoBlock</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">_dimensionNmrAtoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Assign by Dimensions</span>
<span class="sd">        Ccpn Internal:used by assignDimension/dimensionNmrAtoms - not to be called elsewhere</span>
<span class="sd">        Doesn&#39;t need undoBlock/CoreSetter as this is taken care of by calling method</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;dimensionNmrAtoms must be sequence of list/tuples&quot;</span><span class="p">)</span>

        <span class="n">isotopeCodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peakList</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">isotopeCodes</span>

        <span class="n">apiPeak</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span>
        <span class="n">dimResonances</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">atoms</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">atoms</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">dimResonances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="n">isotopeCode</span> <span class="o">=</span> <span class="n">isotopeCodes</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;dimensionNmrAtoms cannot be set to a sequence of strings&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;dimensionNmrAtoms must be sequence of list/tuples&quot;</span><span class="p">)</span>

                <span class="n">atoms</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getByPid</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">atoms</span><span class="p">)</span>
                <span class="n">resonances</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">_wrappedData</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">atoms</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">isotopeCode</span> <span class="ow">and</span> <span class="n">isotopeCode</span> <span class="o">!=</span> <span class="n">UnknownIsotopeCode</span><span class="p">:</span>
                    <span class="c1"># check for isotope match</span>
                    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">resonances</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">isotopeCode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="n">isotopeCode</span><span class="p">,</span> <span class="n">UnknownIsotopeCode</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
                            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&quot;&quot;IsotopeCodes mismatch between NmrAtom </span><span class="si">{</span><span class="n">x</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> and Spectrum. </span>
<span class="s2">                                  Consider changing NmrAtom isotopeCode from </span><span class="si">{</span><span class="n">x</span><span class="o">.</span><span class="n">isotopeCode</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">isotopeCode</span><span class="si">}</span><span class="s2">, None, or </span><span class="si">{</span><span class="n">UnknownIsotopeCode</span><span class="si">}</span><span class="s2"></span>
<span class="s2">                                  to avoid future warnings.&quot;&quot;&quot;</span>
                            <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>  <span class="c1"># don&#39;t raise errors. NmrAtoms are just labels and can be assigned to anything if user wants so.</span>

                <span class="n">dimResonances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">resonances</span><span class="p">)</span>

        <span class="n">apiPeak</span><span class="o">.</span><span class="n">assignByDimensions</span><span class="p">(</span><span class="n">dimResonances</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_recalculatePeakShifts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nmrResidues</span><span class="p">,</span> <span class="n">shifts</span><span class="p">):</span>
        <span class="c1"># update the assigned nmrAtom chemical shift values - notify the nmrResidues and chemicalShifts</span>
        <span class="k">for</span> <span class="n">sh</span> <span class="ow">in</span> <span class="n">shifts</span><span class="p">:</span>
            <span class="n">sh</span><span class="o">.</span><span class="n">_recalculateShiftValue</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">nmr</span> <span class="ow">in</span> <span class="n">nmrResidues</span><span class="p">:</span>
            <span class="n">nmr</span><span class="o">.</span><span class="n">_finaliseAction</span><span class="p">(</span><span class="s1">&#39;change&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">sh</span> <span class="ow">in</span> <span class="n">shifts</span><span class="p">:</span>
            <span class="n">sh</span><span class="o">.</span><span class="n">_finaliseAction</span><span class="p">(</span><span class="s1">&#39;change&#39;</span><span class="p">)</span>

    <span class="nd">@dimensionNmrAtoms</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@logCommand</span><span class="p">(</span><span class="n">get</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">,</span> <span class="n">isProperty</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">dimensionNmrAtoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">):</span>

        <span class="n">_pre</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">makeIterableList</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">assignedNmrAtoms</span><span class="p">))</span>
        <span class="n">_post</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">makeIterableList</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
        <span class="n">nmrResidues</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">nmr</span><span class="o">.</span><span class="n">nmrResidue</span> <span class="k">for</span> <span class="n">nmr</span> <span class="ow">in</span> <span class="p">(</span><span class="n">_pre</span> <span class="o">|</span> <span class="n">_post</span><span class="p">))</span>
        <span class="n">shifts</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">cs</span> <span class="k">for</span> <span class="n">nmrAt</span> <span class="ow">in</span> <span class="p">(</span><span class="n">_pre</span> <span class="o">|</span> <span class="n">_post</span><span class="p">)</span> <span class="k">for</span> <span class="n">cs</span> <span class="ow">in</span> <span class="n">nmrAt</span><span class="o">.</span><span class="n">chemicalShifts</span><span class="p">))</span>
        <span class="n">newShifts</span> <span class="o">=</span> <span class="n">shifts</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">_thisNmrPids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">chemicalShiftList</span><span class="o">.</span><span class="n">_getNmrAtomPids</span><span class="p">()</span>
        <span class="n">_pre</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">atm</span><span class="o">.</span><span class="n">pid</span> <span class="k">for</span> <span class="n">atm</span> <span class="ow">in</span> <span class="n">_pre</span><span class="p">)</span>
        <span class="n">_post</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">atm</span><span class="o">.</span><span class="n">pid</span> <span class="k">for</span> <span class="n">atm</span> <span class="ow">in</span> <span class="n">_post</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">undoBlock</span><span class="p">():</span>
            <span class="k">with</span> <span class="n">undoStackBlocking</span><span class="p">()</span> <span class="k">as</span> <span class="n">addUndoItem</span><span class="p">:</span>
                <span class="n">addUndoItem</span><span class="p">(</span><span class="n">undo</span><span class="o">=</span><span class="n">partial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_recalculatePeakShifts</span><span class="p">,</span> <span class="n">nmrResidues</span><span class="p">,</span> <span class="n">shifts</span><span class="p">))</span>

            <span class="c1"># set the value</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dimensionNmrAtoms</span> <span class="o">=</span> <span class="n">value</span>

            <span class="c1"># add those that are not already in the list - otherwise recalculate</span>
            <span class="k">for</span> <span class="n">nmrAtom</span> <span class="ow">in</span> <span class="p">(</span><span class="n">_post</span> <span class="o">-</span> <span class="n">_pre</span> <span class="o">-</span> <span class="n">_thisNmrPids</span><span class="p">):</span>
                <span class="n">newShifts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">chemicalShiftList</span><span class="o">.</span><span class="n">newChemicalShift</span><span class="p">(</span><span class="n">nmrAtom</span><span class="o">=</span><span class="n">nmrAtom</span><span class="p">))</span>

            <span class="c1"># update the chemicalShift value/valueError</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_recalculatePeakShifts</span><span class="p">(</span><span class="n">nmrResidues</span><span class="p">,</span> <span class="n">newShifts</span><span class="p">)</span>
            <span class="k">with</span> <span class="n">undoStackBlocking</span><span class="p">()</span> <span class="k">as</span> <span class="n">addUndoItem</span><span class="p">:</span>
                <span class="n">addUndoItem</span><span class="p">(</span><span class="n">redo</span><span class="o">=</span><span class="n">partial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_recalculatePeakShifts</span><span class="p">,</span> <span class="n">nmrResidues</span><span class="p">,</span> <span class="n">newShifts</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">assignedNmrAtoms</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="s1">&#39;NmrAtom&#39;</span><span class="p">],</span> <span class="o">...</span><span class="p">],</span> <span class="o">...</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Peak assignment - a tuple of tuples of NmrAtom combinations.</span>
<span class="sd">        (e.g. a tuple of triplets for a 3D spectrum).</span>
<span class="sd">        One of two alternative views on the Peak assignment.</span>
<span class="sd">        Missing assignments are entered as None.</span>

<span class="sd">        Example, for 13H HSQC::</span>
<span class="sd">          ((&lt;NA:A.127.LEU.HA&gt;, &lt;NA:A.127.LEU.CA&gt;),</span>

<span class="sd">          (&lt;NA:A.127.LEU.HBX&gt;, &lt;NA:A.127.LEU.CB&gt;),</span>

<span class="sd">          (&lt;NA:A.127.LEU.HBY&gt;, &lt;NA:A.127.LEU.CB&gt;),</span>

<span class="sd">          (&lt;NA:A.127.LEU.HG&gt;, None),)</span>

<span class="sd">        To add a single assignment tuple, use the Peak.addAssignment method</span>

<span class="sd">        See also dimensionNmrAtoms, which gives assignments per dimension.&quot;&quot;&quot;</span>

        <span class="n">data2Obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_project</span><span class="o">.</span><span class="n">_data2Obj</span>
        <span class="n">apiPeak</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span>
        <span class="n">peakDims</span> <span class="o">=</span> <span class="n">apiPeak</span><span class="o">.</span><span class="n">sortedPeakDims</span><span class="p">()</span>
        <span class="n">mainPeakDimContribs</span> <span class="o">=</span> <span class="p">[</span><span class="nb">sorted</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">mainPeakDimContribs</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">operator</span><span class="o">.</span><span class="n">attrgetter</span><span class="p">(</span><span class="s1">&#39;serial&#39;</span><span class="p">))</span>
                               <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">peakDims</span><span class="p">]</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">peakContrib</span> <span class="ow">in</span> <span class="n">apiPeak</span><span class="o">.</span><span class="n">sortedPeakContribs</span><span class="p">():</span>
            <span class="n">allAtoms</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">peakDimContribs</span> <span class="o">=</span> <span class="n">peakContrib</span><span class="o">.</span><span class="n">peakDimContribs</span>
            <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">peakDim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">peakDims</span><span class="p">):</span>
                <span class="n">nmrAtoms</span> <span class="o">=</span> <span class="p">[</span><span class="n">data2Obj</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">resonance</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">mainPeakDimContribs</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
                            <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">peakDimContribs</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;resonance&#39;</span><span class="p">)]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">nmrAtoms</span><span class="p">:</span>
                    <span class="n">nmrAtoms</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>
                <span class="n">allAtoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nmrAtoms</span><span class="p">)</span>

            <span class="c1"># NB this gives a list of tuples</span>
            <span class="c1"># Remove all-None tuples</span>
            <span class="n">result</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">tt</span> <span class="k">for</span> <span class="n">tt</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">allAtoms</span><span class="p">)</span>
                          <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">tt</span><span class="p">))</span>
            <span class="c1"># result += itertools.product(*allAtoms)</span>

        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_assignedNmrAtoms</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="s1">&#39;NmrAtom&#39;</span><span class="p">],</span> <span class="o">...</span><span class="p">],</span> <span class="o">...</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Transparent method to control notifiers&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">assignedNmrAtoms</span>

    <span class="nd">@_assignedNmrAtoms</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@ccpNmrV3CoreUndoBlock</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">_assignedNmrAtoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Assign by Contributions</span>
<span class="sd">        Ccpn Internal: used by assignedNmrAtoms - not to be called elsewhere</span>
<span class="sd">        Doesn&#39;t need undoBlock/CoreSetter as this is taken care of by calling method</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;assignedNmrAtoms must be set to a sequence of list/tuples&quot;</span><span class="p">)</span>

        <span class="n">isotopeCodes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="kc">None</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">UnknownIsotopeCode</span> <span class="k">else</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">peakList</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">isotopeCodes</span><span class="p">)</span>

        <span class="n">apiPeak</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span>
        <span class="n">peakDims</span> <span class="o">=</span> <span class="n">apiPeak</span><span class="o">.</span><span class="n">sortedPeakDims</span><span class="p">()</span>
        <span class="n">dimensionCount</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">peakDims</span><span class="p">)</span>

        <span class="c1"># get resonance, all tuples and per dimension</span>
        <span class="n">resonances</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">tt</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
            <span class="n">ll</span> <span class="o">=</span> <span class="n">dimensionCount</span> <span class="o">*</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>
            <span class="n">resonances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ll</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">atom</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tt</span><span class="p">):</span>
                <span class="n">atom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getByPid</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">atom</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="n">NmrAtom</span><span class="p">):</span>
                    <span class="n">resonance</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">_wrappedData</span>
                    <span class="k">if</span> <span class="n">isotopeCodes</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="ow">and</span> <span class="n">resonance</span><span class="o">.</span><span class="n">isotopeCode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="n">isotopeCodes</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">UnknownIsotopeCode</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;NmrAtom </span><span class="si">%s</span><span class="s2">, isotope </span><span class="si">%s</span><span class="s2">, assigned to dimension </span><span class="si">%s</span><span class="s2"> must have isotope </span><span class="si">%s</span><span class="s2"> or </span><span class="si">%s</span><span class="s2">&quot;</span>
                                         <span class="o">%</span> <span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="n">resonance</span><span class="o">.</span><span class="n">isotopeCode</span><span class="p">,</span> <span class="n">ii</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">isotopeCodes</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">UnknownIsotopeCode</span><span class="p">))</span>

                    <span class="n">ll</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">resonance</span>

                <span class="k">elif</span> <span class="n">atom</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Error assigning NmrAtom </span><span class="si">%s</span><span class="s1"> to dimension </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">atom</span><span class="p">),</span> <span class="n">ii</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

        <span class="c1"># store the currently attached nmrAtoms</span>
        <span class="n">_assigned</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">makeIterableList</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">assignedNmrAtoms</span><span class="p">))</span>

        <span class="c1"># set assignments</span>
        <span class="n">apiPeak</span><span class="o">.</span><span class="n">assignByContributions</span><span class="p">(</span><span class="n">resonances</span><span class="p">)</span>

    <span class="nd">@assignedNmrAtoms</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@logCommand</span><span class="p">(</span><span class="n">get</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">,</span> <span class="n">isProperty</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">assignedNmrAtoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">):</span>

        <span class="n">_pre</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">makeIterableList</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">assignedNmrAtoms</span><span class="p">))</span>
        <span class="n">_post</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">makeIterableList</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
        <span class="n">nmrResidues</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">nmr</span><span class="o">.</span><span class="n">nmrResidue</span> <span class="k">for</span> <span class="n">nmr</span> <span class="ow">in</span> <span class="p">(</span><span class="n">_pre</span> <span class="o">|</span> <span class="n">_post</span><span class="p">))</span>
        <span class="n">shifts</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">cs</span> <span class="k">for</span> <span class="n">nmrAt</span> <span class="ow">in</span> <span class="p">(</span><span class="n">_pre</span> <span class="o">|</span> <span class="n">_post</span><span class="p">)</span> <span class="k">for</span> <span class="n">cs</span> <span class="ow">in</span> <span class="n">nmrAt</span><span class="o">.</span><span class="n">chemicalShifts</span><span class="p">))</span>
        <span class="n">newShifts</span> <span class="o">=</span> <span class="n">shifts</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">_thisNmrPids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">chemicalShiftList</span><span class="o">.</span><span class="n">_getNmrAtomPids</span><span class="p">()</span>
        <span class="n">_pre</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">atm</span><span class="o">.</span><span class="n">pid</span> <span class="k">for</span> <span class="n">atm</span> <span class="ow">in</span> <span class="n">_pre</span><span class="p">)</span>
        <span class="n">_post</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">atm</span><span class="o">.</span><span class="n">pid</span> <span class="k">for</span> <span class="n">atm</span> <span class="ow">in</span> <span class="n">_post</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">undoBlock</span><span class="p">():</span>
            <span class="k">with</span> <span class="n">undoStackBlocking</span><span class="p">()</span> <span class="k">as</span> <span class="n">addUndoItem</span><span class="p">:</span>
                <span class="n">addUndoItem</span><span class="p">(</span><span class="n">undo</span><span class="o">=</span><span class="n">partial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_recalculatePeakShifts</span><span class="p">,</span> <span class="n">nmrResidues</span><span class="p">,</span> <span class="n">shifts</span><span class="p">))</span>

            <span class="c1"># set the value</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_assignedNmrAtoms</span> <span class="o">=</span> <span class="n">value</span>

            <span class="c1"># add those that are not already in the list - otherwise recalculate</span>
            <span class="k">for</span> <span class="n">nmrAtom</span> <span class="ow">in</span> <span class="p">(</span><span class="n">_post</span> <span class="o">-</span> <span class="n">_pre</span> <span class="o">-</span> <span class="n">_thisNmrPids</span><span class="p">):</span>
                <span class="n">newShifts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">chemicalShiftList</span><span class="o">.</span><span class="n">newChemicalShift</span><span class="p">(</span><span class="n">nmrAtom</span><span class="o">=</span><span class="n">nmrAtom</span><span class="p">))</span>

            <span class="c1"># update the chemicalShift value/valueError</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_recalculatePeakShifts</span><span class="p">(</span><span class="n">nmrResidues</span><span class="p">,</span> <span class="n">newShifts</span><span class="p">)</span>
            <span class="k">with</span> <span class="n">undoStackBlocking</span><span class="p">()</span> <span class="k">as</span> <span class="n">addUndoItem</span><span class="p">:</span>
                <span class="n">addUndoItem</span><span class="p">(</span><span class="n">redo</span><span class="o">=</span><span class="n">partial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_recalculatePeakShifts</span><span class="p">,</span> <span class="n">nmrResidues</span><span class="p">,</span> <span class="n">newShifts</span><span class="p">))</span>

    <span class="c1"># alternativeNames</span>
    <span class="n">assignments</span> <span class="o">=</span> <span class="n">assignedNmrAtoms</span>
    <span class="n">assignmentsByDimensions</span> <span class="o">=</span> <span class="n">dimensionNmrAtoms</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">multiplets</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Any</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;List of multiplets containing the Peak.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_project</span><span class="o">.</span><span class="n">_data2Obj</span><span class="p">[</span><span class="n">mt</span><span class="p">]</span> <span class="k">for</span> <span class="n">mt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">sortedMultiplets</span><span class="p">()</span>
                      <span class="k">if</span> <span class="n">mt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_project</span><span class="o">.</span><span class="n">_data2Obj</span><span class="p">])</span>

<div class="viewcode-block" id="Peak.addAssignment"><a class="viewcode-back" href="../../../ccpn/ccpn.core.html#ccpn.core.Peak.Peak.addAssignment">[docs]</a>    <span class="nd">@logCommand</span><span class="p">(</span><span class="n">get</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">addAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="s1">&#39;NmrAtom&#39;</span><span class="p">]]):</span>
        <span class="sd">&quot;&quot;&quot;Add a peak assignment - a list of one NmrAtom or Pid for each dimension&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peakList</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">dimensionCount</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Length of assignment value </span><span class="si">%s</span><span class="s2"> does not match peak dimensionality </span><span class="si">%s</span><span class="s2"> &quot;</span>
                             <span class="o">%</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">peakList</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">dimensionCount</span><span class="p">))</span>

        <span class="c1"># Convert to tuple and check for non-existing pids</span>
        <span class="n">ll</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">vv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getByPid</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">vv</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No NmrAtom matching string pid </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">val</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ll</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vv</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ll</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="n">value</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="n">assignedNmrAtoms</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">assignedNmrAtoms</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">assignedNmrAtoms</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_project</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Attempt to add already existing Peak Assignment: </span><span class="si">%s</span><span class="s2"> - ignored&quot;</span>
                                          <span class="o">%</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">assignedNmrAtoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assignedNmrAtoms</span> <span class="o">=</span> <span class="n">assignedNmrAtoms</span></div>

<div class="viewcode-block" id="Peak.assignDimension"><a class="viewcode-back" href="../../../ccpn/ccpn.core.html#ccpn.core.Peak.Peak.assignDimension">[docs]</a>    <span class="nd">@logCommand</span><span class="p">(</span><span class="n">get</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">assignDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axisCode</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="s1">&#39;NmrAtom&#39;</span><span class="p">],</span>
                                                          <span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="s1">&#39;NmrAtom&#39;</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Assign dimension with axisCode to value (NmrAtom, or Pid or sequence of either, or None).&quot;&quot;&quot;</span>

        <span class="n">axisCodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">axisCodes</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="n">axisCodes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">axisCode</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;axisCode </span><span class="si">%s</span><span class="s2"> not recognised&quot;</span> <span class="o">%</span> <span class="n">axisCode</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">getByPid</span><span class="p">(</span><span class="n">value</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">getByPid</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">value</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="n">value</span><span class="p">]</span>
        <span class="n">dimensionNmrAtoms</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensionNmrAtoms</span><span class="p">)</span>

        <span class="n">dimensionNmrAtoms</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimensionNmrAtoms</span> <span class="o">=</span> <span class="n">dimensionNmrAtoms</span></div>

<div class="viewcode-block" id="Peak.getByAxisCodes"><a class="viewcode-back" href="../../../ccpn/ccpn.core.html#ccpn.core.Peak.Peak.getByAxisCodes">[docs]</a>    <span class="k">def</span> <span class="nf">getByAxisCodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameterName</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">axisCodes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                       <span class="n">exactMatch</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return a list of values defined by parameterName in order defined by axisCodes (default order if None).</span>
<span class="sd">        Perform a mapping if exactMatch=False (eg. &#39;H&#39; to &#39;Hn&#39;)</span>

<span class="sd">        :param parameterName: a str denoting a Spectrum dimensional attribute</span>
<span class="sd">        :param axisCodes: a tuple or list of axisCodes</span>
<span class="sd">        :param exactMatch: a boolean optional testing for an exact match with the instance axisCodes</span>
<span class="sd">        :return: the values defined by parameterName in axisCode order</span>

<span class="sd">        Related:</span>
<span class="sd">        Use getByDimensions() for dimensions (1..dimensionCount) based access of dimensional parameters of the</span>
<span class="sd">            Peak class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">ccpn.core.lib.SpectrumLib</span> <span class="kn">import</span> <span class="n">_getParameterValues</span>

        <span class="k">if</span> <span class="n">axisCodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dimensions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">dimensions</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dimensions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">orderByAxisCodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">dimensions</span><span class="p">,</span> <span class="n">axisCodes</span><span class="o">=</span><span class="n">axisCodes</span><span class="p">,</span> <span class="n">exactMatch</span><span class="o">=</span><span class="n">exactMatch</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">newValues</span> <span class="o">=</span> <span class="n">_getParameterValues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameterName</span><span class="p">,</span>
                                            <span class="n">dimensions</span><span class="o">=</span><span class="n">dimensions</span><span class="p">,</span> <span class="n">dimensionCount</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">dimensionCount</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">es</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">.getByAxisCodes: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">es</span><span class="p">)))</span>

        <span class="k">return</span> <span class="n">newValues</span></div>

<div class="viewcode-block" id="Peak.setByAxisCodes"><a class="viewcode-back" href="../../../ccpn/ccpn.core.html#ccpn.core.Peak.Peak.setByAxisCodes">[docs]</a>    <span class="k">def</span> <span class="nf">setByAxisCodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameterName</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">axisCodes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">exactMatch</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Set attributeName to values in order defined by axisCodes (default order if None)</span>
<span class="sd">        Perform a mapping if exactMatch=False (eg. &#39;H&#39; to &#39;Hn&#39;)</span>

<span class="sd">        :param parameterName: a str denoting a Spectrum dimensional attribute</span>
<span class="sd">        :param values: an iterable with values</span>
<span class="sd">        :param axisCodes: a tuple or list of axisCodes</span>
<span class="sd">        :param exactMatch: a boolean optional testing for an exact match with the instance axisCodes</span>
<span class="sd">        :return: a list of newly set values of parameterName (in default order)</span>

<span class="sd">        Related:</span>
<span class="sd">        Use setByDimensions() for dimensions (1..dimensionCount) based setting of dimensional parameters of the</span>
<span class="sd">            Peak class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">ccpn.core.lib.SpectrumLib</span> <span class="kn">import</span> <span class="n">_setParameterValues</span>

        <span class="k">if</span> <span class="n">axisCodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dimensions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">dimensions</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dimensions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">orderByAxisCodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">dimensions</span><span class="p">,</span> <span class="n">axisCodes</span><span class="o">=</span><span class="n">axisCodes</span><span class="p">,</span> <span class="n">exactMatch</span><span class="o">=</span><span class="n">exactMatch</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">newValues</span> <span class="o">=</span> <span class="n">_setParameterValues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameterName</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span>
                                            <span class="n">dimensions</span><span class="o">=</span><span class="n">dimensions</span><span class="p">,</span> <span class="n">dimensionCount</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">dimensionCount</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">es</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">.setByAxisCodes: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">es</span><span class="p">)))</span>

        <span class="k">return</span> <span class="n">newValues</span></div>

<div class="viewcode-block" id="Peak.getByDimensions"><a class="viewcode-back" href="../../../ccpn/ccpn.core.html#ccpn.core.Peak.Peak.getByDimensions">[docs]</a>    <span class="k">def</span> <span class="nf">getByDimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameterName</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return a list of values of Peak dimensional attribute parameterName in order defined</span>
<span class="sd">        by dimensions (default order if None).</span>

<span class="sd">        :param parameterName: a str denoting a Spectrum dimensional attribute</span>
<span class="sd">        :param dimensions: a tuple or list of dimensions (1..dimensionCount)</span>
<span class="sd">        :return: the values defined by parameterName in dimensions order</span>

<span class="sd">        Related:</span>
<span class="sd">        Use getByAxisCodes() for axisCode based access of dimensional parameters of the Spectrum class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">ccpn.core.lib.SpectrumLib</span> <span class="kn">import</span> <span class="n">_getParameterValues</span>

        <span class="k">if</span> <span class="n">dimensions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dimensions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">dimensions</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">newValues</span> <span class="o">=</span> <span class="n">_getParameterValues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameterName</span><span class="p">,</span>
                                            <span class="n">dimensions</span><span class="o">=</span><span class="n">dimensions</span><span class="p">,</span> <span class="n">dimensionCount</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">dimensionCount</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">es</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">.getByDimensions: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">es</span><span class="p">)))</span>

        <span class="k">return</span> <span class="n">newValues</span></div>

<div class="viewcode-block" id="Peak.setByDimensions"><a class="viewcode-back" href="../../../ccpn/ccpn.core.html#ccpn.core.Peak.Peak.setByDimensions">[docs]</a>    <span class="k">def</span> <span class="nf">setByDimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameterName</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Set Spectrum dimensional attribute parameterName to values in the order as defined by</span>
<span class="sd">        dimensions (1..dimensionCount)(default order if None)</span>

<span class="sd">        :param parameterName: a str denoting a Spectrum dimensional attribute</span>
<span class="sd">        :param dimensions: a tuple or list of dimensions (1..dimensionCount)</span>
<span class="sd">        :return: a list of newly set values of parameterName (in default order)</span>

<span class="sd">        Related:</span>
<span class="sd">        Use setByAxisCodes() for axisCode based setting of dimensional parameters of the Spectrum class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">ccpn.core.lib.SpectrumLib</span> <span class="kn">import</span> <span class="n">_setParameterValues</span>

        <span class="k">if</span> <span class="n">dimensions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dimensions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">dimensions</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">newValues</span> <span class="o">=</span> <span class="n">_setParameterValues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameterName</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">=</span><span class="n">dimensions</span><span class="p">,</span> <span class="n">dimensionCount</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">dimensionCount</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">es</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">.setByDimensions: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">es</span><span class="p">)))</span>

        <span class="k">return</span> <span class="n">newValues</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">clusterId</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get/set the clusterId for the peak</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">clusterId</span>

    <span class="nd">@clusterId</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@logCommand</span><span class="p">(</span><span class="n">get</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">,</span> <span class="n">isProperty</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nd">@ccpNmrV3CoreSetter</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">clusterId</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">))):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Peak.clusterId must be of type int &gt;= 0, None&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Peak.clusterId must be &gt;= 0&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">clusterId</span> <span class="o">=</span> <span class="n">value</span>

    <span class="c1">#=========================================================================================</span>
    <span class="c1"># Implementation functions</span>
    <span class="c1">#=========================================================================================</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_getAllWrappedData</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">parent</span><span class="p">:</span> <span class="n">PeakList</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Nmr</span><span class="o">.</span><span class="n">Peak</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Get wrappedData (Peaks) for all Peak children of parent PeakList.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">parent</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">sortedPeaks</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_finaliseAction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">action</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Subclassed to handle associated multiplets</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_finaliseAction</span><span class="p">(</span><span class="n">action</span><span class="p">):</span>
            <span class="k">return</span>

        <span class="c1"># if this peak is changed or deleted then it&#39;s multiplets/integral need to CHANGE</span>
        <span class="c1"># create required as undo may return peak to a multiplet list</span>
        <span class="k">if</span> <span class="n">action</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;change&#39;</span><span class="p">,</span> <span class="s1">&#39;create&#39;</span><span class="p">,</span> <span class="s1">&#39;delete&#39;</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">mt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">multiplets</span><span class="p">:</span>
                <span class="n">mt</span><span class="o">.</span><span class="n">_finaliseAction</span><span class="p">(</span><span class="s1">&#39;change&#39;</span><span class="p">)</span>
            <span class="c1"># NOTE:ED does integral need to be notified? - and reverse notifiers in multiplet/integral</span>

<div class="viewcode-block" id="Peak.delete"><a class="viewcode-back" href="../../../ccpn/ccpn.core.html#ccpn.core.Peak.Peak.delete">[docs]</a>    <span class="k">def</span> <span class="nf">delete</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Delete a peak.&quot;&quot;&quot;</span>
        <span class="n">assigned</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">peakList</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">dimensionCount</span><span class="p">))</span>

        <span class="k">with</span> <span class="n">undoBlockWithoutSideBar</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dimensionNmrAtoms</span> <span class="o">=</span> <span class="n">assigned</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_delete</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Readable string representation;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_digits</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;1H&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;15N&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;13C&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;19F&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>
        <span class="c1"># _digits.get(iCode,2)</span>
        <span class="n">ppms</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">_digits</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">iCode</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="k">if</span> <span class="n">p</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
                     <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">iCode</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ppmPositions</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">isotopeCodes</span><span class="p">))</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;</span><span class="si">%s</span><span class="s2">: @</span><span class="si">%r</span><span class="s2">&gt;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pid</span><span class="p">,</span> <span class="n">ppms</span><span class="p">)</span>

    <span class="c1">#=========================================================================================</span>
    <span class="c1"># CCPN functions</span>
    <span class="c1">#=========================================================================================</span>

<div class="viewcode-block" id="Peak.isPartlyAssigned"><a class="viewcode-back" href="../../../ccpn/ccpn.core.html#ccpn.core.Peak.Peak.isPartlyAssigned">[docs]</a>    <span class="k">def</span> <span class="nf">isPartlyAssigned</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Whether peak is partly assigned.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensionNmrAtoms</span><span class="p">)</span></div>

<div class="viewcode-block" id="Peak.isFullyAssigned"><a class="viewcode-back" href="../../../ccpn/ccpn.core.html#ccpn.core.Peak.Peak.isFullyAssigned">[docs]</a>    <span class="k">def</span> <span class="nf">isFullyAssigned</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Whether peak is fully assigned.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensionNmrAtoms</span><span class="p">)</span></div>

<div class="viewcode-block" id="Peak.copyTo"><a class="viewcode-back" href="../../../ccpn/ccpn.core.html#ccpn.core.Peak.Peak.copyTo">[docs]</a>    <span class="nd">@logCommand</span><span class="p">(</span><span class="n">get</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">copyTo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">targetPeakList</span><span class="p">:</span> <span class="n">PeakList</span><span class="p">,</span> <span class="n">includeAllProperties</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Peak&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Make (and return) a copy of the Peak in targetPeakList.</span>
<span class="sd">        IncludeAll, True to copy all properties from origin to target Peak. False will copy</span>
<span class="sd">        only position and assignments (if available)&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">includeAllProperties</span><span class="p">:</span>
            <span class="n">singleValueTags</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">,</span> <span class="s1">&#39;volume&#39;</span><span class="p">,</span> <span class="s1">&#39;heightError&#39;</span><span class="p">,</span> <span class="s1">&#39;volumeError&#39;</span><span class="p">,</span> <span class="s1">&#39;figureOfMerit&#39;</span><span class="p">,</span>
                               <span class="s1">&#39;annotation&#39;</span><span class="p">,</span> <span class="s1">&#39;comment&#39;</span><span class="p">,</span> <span class="p">]</span>
            <span class="n">dimensionValueTags</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;ppmPositions&#39;</span><span class="p">,</span> <span class="s1">&#39;positionError&#39;</span><span class="p">,</span> <span class="s1">&#39;boxWidths&#39;</span><span class="p">,</span> <span class="s1">&#39;lineWidths&#39;</span><span class="p">,</span> <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">singleValueTags</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">dimensionValueTags</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;ppmPositions&#39;</span><span class="p">,</span> <span class="s1">&#39;positionError&#39;</span><span class="p">]</span>

        <span class="n">peakList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peakList</span>
        <span class="n">dimensionCount</span> <span class="o">=</span> <span class="n">peakList</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">dimensionCount</span>

        <span class="k">if</span> <span class="n">dimensionCount</span> <span class="o">&lt;</span> <span class="n">targetPeakList</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">dimensionCount</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot copy </span><span class="si">%s</span><span class="s2">D </span><span class="si">%s</span><span class="s2"> to </span><span class="si">%s</span><span class="s2">D </span><span class="si">%s</span><span class="s2">. Incompatible dimensionality.&quot;</span>
                             <span class="o">%</span> <span class="p">(</span><span class="n">dimensionCount</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">longPid</span><span class="p">,</span>
                                <span class="n">targetPeakList</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">dimensionCount</span><span class="p">,</span> <span class="n">targetPeakList</span><span class="o">.</span><span class="n">longPid</span><span class="p">))</span>

        <span class="n">destinationAxisCodes</span> <span class="o">=</span> <span class="n">targetPeakList</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">axisCodes</span>
        <span class="n">dimensionMapping</span> <span class="o">=</span> <span class="n">peakList</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">getByAxisCodes</span><span class="p">(</span><span class="s1">&#39;dimensions&#39;</span><span class="p">,</span> <span class="n">destinationAxisCodes</span><span class="p">,</span> <span class="n">exactMatch</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="kc">None</span> <span class="ow">in</span> <span class="n">dimensionMapping</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> axisCodes </span><span class="si">%s</span><span class="s2"> not compatible with targetSpectrum axisCodes </span><span class="si">%s</span><span class="s2">&quot;</span>
                             <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">peakList</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">axisCodes</span><span class="p">,</span> <span class="n">targetPeakList</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">axisCodes</span><span class="p">))</span>

        <span class="k">with</span> <span class="n">undoBlockWithoutSideBar</span><span class="p">():</span>
            <span class="n">params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">tag</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tag</span><span class="p">))</span> <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">singleValueTags</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">dimensionValueTags</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getByDimensions</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">=</span><span class="n">dimensionMapping</span><span class="p">)</span>
                <span class="n">params</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

            <span class="n">newPeak</span> <span class="o">=</span> <span class="n">targetPeakList</span><span class="o">.</span><span class="n">newPeak</span><span class="p">(</span><span class="o">**</span><span class="n">params</span><span class="p">)</span>

            <span class="n">assignments</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getByDimensions</span><span class="p">(</span><span class="s1">&#39;assignedNmrAtoms&#39;</span><span class="p">,</span> <span class="n">dimensionMapping</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">assignments</span><span class="p">:</span>
                <span class="n">newPeak</span><span class="o">.</span><span class="n">assignedNmrAtoms</span> <span class="o">=</span> <span class="n">assignments</span>

            <span class="k">return</span> <span class="n">newPeak</span></div>

<div class="viewcode-block" id="Peak.reorderValues"><a class="viewcode-back" href="../../../ccpn/ccpn.core.html#ccpn.core.Peak.Peak.reorderValues">[docs]</a>    <span class="k">def</span> <span class="nf">reorderValues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">newAxisCodeOrder</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reorder values in spectrum dimension order to newAxisCodeOrder</span>
<span class="sd">        by matching newAxisCodeOrder to spectrum axis code order.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">commonUtil</span><span class="o">.</span><span class="n">reorder</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">axisCodes</span><span class="p">,</span> <span class="n">newAxisCodeOrder</span><span class="p">)</span></div>

<div class="viewcode-block" id="Peak.getInAxisOrder"><a class="viewcode-back" href="../../../ccpn/ccpn.core.html#ccpn.core.Peak.Peak.getInAxisOrder">[docs]</a>    <span class="k">def</span> <span class="nf">getInAxisOrder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attributeName</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">axisCodes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get attributeName in order defined by axisCodes :</span>
<span class="sd">           (default order if None)&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attributeName</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;Peak object does not have attribute &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="n">attributeName</span><span class="p">)</span>

        <span class="n">values</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attributeName</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">axisCodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">values</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># change to order defined by axisCodes</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reorderValues</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">axisCodes</span><span class="p">)</span></div>

<div class="viewcode-block" id="Peak.setInAxisOrder"><a class="viewcode-back" href="../../../ccpn/ccpn.core.html#ccpn.core.Peak.Peak.setInAxisOrder">[docs]</a>    <span class="k">def</span> <span class="nf">setInAxisOrder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attributeName</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="n">axisCodes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set attributeName from values in order defined by axisCodes</span>
<span class="sd">           (default order if None)&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attributeName</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;Peak object does not have attribute &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="n">attributeName</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">axisCodes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># change values to the order appropriate for spectrum</span>
            <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reorderValues</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">axisCodes</span><span class="p">)</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attributeName</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span></div>

<div class="viewcode-block" id="Peak.snapToExtremum"><a class="viewcode-back" href="../../../ccpn/ccpn.core.html#ccpn.core.Peak.Peak.snapToExtremum">[docs]</a>    <span class="k">def</span> <span class="nf">snapToExtremum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">halfBoxSearchWidth</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">halfBoxFitWidth</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
                       <span class="n">minDropFactor</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">fitMethod</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">PARABOLICMETHOD</span><span class="p">,</span>
                       <span class="n">searchBoxMode</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">searchBoxDoFit</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Snap the Peak to the closest local extrema, if within range.&quot;&quot;&quot;</span>
        <span class="n">peakUtilsSnapToExtremum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">halfBoxSearchWidth</span><span class="o">=</span><span class="n">halfBoxSearchWidth</span><span class="p">,</span> <span class="n">halfBoxFitWidth</span><span class="o">=</span><span class="n">halfBoxFitWidth</span><span class="p">,</span>
                                <span class="n">minDropFactor</span><span class="o">=</span><span class="n">minDropFactor</span><span class="p">,</span> <span class="n">fitMethod</span><span class="o">=</span><span class="n">fitMethod</span><span class="p">,</span>
                                <span class="n">searchBoxMode</span><span class="o">=</span><span class="n">searchBoxMode</span><span class="p">,</span> <span class="n">searchBoxDoFit</span><span class="o">=</span><span class="n">searchBoxDoFit</span><span class="p">)</span></div>

    <span class="c1"># def fitPositionHeightLineWidths(self):</span>
    <span class="c1">#     &quot;&quot;&quot;Set the position, height and lineWidth of the Peak.&quot;&quot;&quot;</span>
    <span class="c1">#     LibPeak.fitPositionHeightLineWidths(self._apiPeak)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">integral</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the integral attached to the peak.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_project</span><span class="o">.</span><span class="n">_data2Obj</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">integral</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">integral</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="nd">@integral</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@logCommand</span><span class="p">(</span><span class="n">get</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">,</span> <span class="n">isProperty</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nd">@ccpNmrV3CoreSetter</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">integral</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s1">&#39;Integral&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Link an integral to the peak.</span>
<span class="sd">        The peak must belong to the spectrum containing the peakList.</span>
<span class="sd">        :param integral: single integral.&quot;&quot;&quot;</span>
        <span class="n">spectrum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">spectrum</span>
        <span class="k">if</span> <span class="n">value</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">ccpn.core.Integral</span> <span class="kn">import</span> <span class="n">Integral</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> is not of type Integral&#39;</span> <span class="o">%</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">integrals</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> does not belong to spectrum: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">pid</span><span class="p">,</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">pid</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">integral</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">_wrappedData</span> <span class="k">if</span> <span class="n">value</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="c1"># def _linkPeaks(self, peaks):</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     NB: this is needed for screening spectrumHits and peakHits. You might see peakCluster instead.</span>
    <span class="c1">#     Saves the peaks in _ccpnInternalData as pids</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     pids = [str(peak.pid) for peak in peaks if peak != self and isinstance(peak, Peak)]</span>
    <span class="c1">#     if isinstance(self._ccpnInternalData, dict):</span>
    <span class="c1">#</span>
    <span class="c1">#         # a single write is required to the api to notify that a change has occurred,</span>
    <span class="c1">#         # this will prompt for a save of the v2 data</span>
    <span class="c1">#         tempCcpn = self._ccpnInternalData.copy()</span>
    <span class="c1">#         tempCcpn[self._linkedPeaksName] = pids</span>
    <span class="c1">#         self._ccpnInternalData = tempCcpn</span>
    <span class="c1">#     else:</span>
    <span class="c1">#         raise ValueError(&quot;Peak.linkPeaks: CCPN internal must be a dictionary&quot;)</span>
    <span class="c1">#</span>
    <span class="c1"># @property</span>
    <span class="c1"># def _linkedPeaks(self):</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     NB: this is needed for screening spectrumHits and peakHits. You might see peakCluster instead.</span>
    <span class="c1">#     It returns a list of peaks belonging to other peakLists or spectra which are required to be linked to this particular peak.</span>
    <span class="c1">#     This functionality is not implemented in the model. Saves the Peak pids in _ccpnInternalData.</span>
    <span class="c1">#     :return: a list of peaks</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     pids = self._ccpnInternalData.get(self._linkedPeaksName) or []</span>
    <span class="c1">#     peaks = [self.project.getByPid(pid) for pid in pids if pid is not None]</span>
    <span class="c1">#     return peaks</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">signalToNoiseRatio</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: float. Estimated  Signal to Noise ratio based on the spectrum noiseLevel values.</span>
<span class="sd">        SNratio = |factor*(height/DeltaNoise)|</span>
<span class="sd">                height: peak height</span>
<span class="sd">                DeltaNoise: spectrum noise levels</span>
<span class="sd">                factor: multiplication factor. Default: 2.5</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_getPeakSNRatio</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<div class="viewcode-block" id="Peak.estimateVolume"><a class="viewcode-back" href="../../../ccpn/ccpn.core.html#ccpn.core.Peak.Peak.estimateVolume">[docs]</a>    <span class="nd">@logCommand</span><span class="p">(</span><span class="n">get</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">estimateVolume</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">volumeIntegralLimit</span><span class="o">=</span><span class="mf">2.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Estimate the volume of the peak from a gaussian distribution.</span>
<span class="sd">        The width of the volume integral in each dimension is the lineWidth (FWHM) * volumeIntegralLimit,</span>
<span class="sd">        the default is 2.0 * FWHM of the peak.</span>
<span class="sd">        :param volumeIntegralLimit: integral width as a multiple of lineWidth (FWHM)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">sigma2fwhm</span><span class="p">(</span><span class="n">sigma</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Convert sigma to FWHM for gaussian distribution</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="n">sigma</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">8</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">fwhm2sigma</span><span class="p">(</span><span class="n">fwhm</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Convert FWHM to sigma for gaussian distribution</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="n">fwhm</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">8</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">make_gauss</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">height</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Generate a gaussian distribution from given parameters</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">height</span>  <span class="c1"># 1.0 / (sigma * np.sqrt(2 * np.pi)) - to give unit area at infinite bounds</span>
            <span class="n">s</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">sigma</span> <span class="o">*</span> <span class="n">sigma</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">k</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">s</span> <span class="o">*</span> <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="n">mu</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="n">mu</span><span class="p">))</span>

        <span class="n">lineWidths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lineWidths</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">lineWidths</span> <span class="ow">or</span> <span class="kc">None</span> <span class="ow">in</span> <span class="n">lineWidths</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;cannot estimate volume, lineWidths not defined or contain None.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">height</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;cannot estimate volume, height not defined.&#39;</span><span class="p">)</span>

        <span class="c1"># parameters for a unit height/sigma gaussian</span>
        <span class="n">sigmaX</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">height</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">numPoints</span> <span class="o">=</span> <span class="mi">39</span>  <span class="c1"># area estimate area &lt; 1e-8 for this number of points</span>

        <span class="c1"># calculate integral limit from FWHM - only need positive half</span>
        <span class="n">FWHM</span> <span class="o">=</span> <span class="n">sigma2fwhm</span><span class="p">(</span><span class="n">sigmaX</span><span class="p">)</span>
        <span class="n">lim</span> <span class="o">=</span> <span class="n">volumeIntegralLimit</span> <span class="o">*</span> <span class="n">FWHM</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="n">xxSig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">lim</span><span class="p">,</span> <span class="n">numPoints</span><span class="p">)</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="n">make_gauss</span><span class="p">(</span><span class="n">xxSig</span><span class="p">,</span> <span class="n">sigmaX</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span>
        <span class="n">area</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">xxSig</span><span class="p">)</span>

        <span class="c1"># note that negative height will give negative volume</span>
        <span class="n">vol</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="k">for</span> <span class="n">lw</span> <span class="ow">in</span> <span class="n">lineWidths</span><span class="p">:</span>
            <span class="c1"># multiply the values for the gaussian in each dimension</span>
            <span class="n">vol</span> <span class="o">*=</span> <span class="p">(</span><span class="n">area</span> <span class="o">*</span> <span class="p">(</span><span class="n">lw</span> <span class="o">/</span> <span class="n">FWHM</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">volume</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">height</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">vol</span><span class="p">)</span></div>

        <span class="c1"># do I need to set the volume error?</span>
        <span class="c1"># self.volumeError = 1e-8</span>

<div class="viewcode-block" id="Peak.fit"><a class="viewcode-back" href="../../../ccpn/ccpn.core.html#ccpn.core.Peak.Peak.fit">[docs]</a>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fitMethod</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">halfBoxSearchWidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">keepPosition</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">iterations</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit the peak to recalculate position and lineWidths.</span>
<span class="sd">        Use peak.estimateVolume to recalculate the volume.</span>

<span class="sd">        :param fitMethod: str, one of [&#39;gaussian&#39;, &#39;lorentzian&#39;, &#39;parabolic&#39;]</span>
<span class="sd">               Default: the fitting method defined in the general preferences.</span>
<span class="sd">               If not given or not included in the available options, it uses the default.</span>
<span class="sd">        :param halfBoxSearchWidth: int. Default: 2.</span>
<span class="sd">               Used to increase the searching area limits from the initial position.</span>
<span class="sd">        :param keepPosition: bool. Default: False.</span>
<span class="sd">               if True, reset to the original position after applying the fitting method.</span>
<span class="sd">               Height is calculated using spectrum.getHeight()</span>
<span class="sd">        :param iterations: int. Default: 3.</span>
<span class="sd">               How many times the fitting method will run before it converges.</span>
<span class="sd">        :return: None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">ccpn.core.PeakList</span> <span class="kn">import</span> <span class="n">PICKINGMETHODS</span>
        <span class="kn">from</span> <span class="nn">ccpn.core.lib.ContextManagers</span> <span class="kn">import</span> <span class="n">undoBlockWithoutSideBar</span><span class="p">,</span> <span class="n">notificationEchoBlocking</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">fitMethod</span> <span class="ow">in</span> <span class="n">PICKINGMETHODS</span><span class="p">:</span>
            <span class="n">fitMethod</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_project</span><span class="o">.</span><span class="n">application</span><span class="o">.</span><span class="n">preferences</span><span class="o">.</span><span class="n">general</span><span class="o">.</span><span class="n">peakFittingMethod</span>
        <span class="n">peak</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">peakList</span> <span class="o">=</span> <span class="n">peak</span><span class="o">.</span><span class="n">peakList</span>
        <span class="n">originalPosition</span> <span class="o">=</span> <span class="n">peak</span><span class="o">.</span><span class="n">position</span>
        <span class="n">lastLWsFound</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">consecutiveSameLWsCount</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">maxSameLWsCount</span> <span class="o">=</span> <span class="mi">3</span>  <span class="c1"># if the same values are found in the last x iterations, then it breaks the loop.</span>
        <span class="k">with</span> <span class="n">undoBlockWithoutSideBar</span><span class="p">():</span>
            <span class="k">with</span> <span class="n">notificationEchoBlocking</span><span class="p">():</span>
                <span class="k">while</span> <span class="n">iterations</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">consecutiveSameLWsCount</span> <span class="o">&lt;=</span> <span class="n">maxSameLWsCount</span><span class="p">:</span>
                    <span class="n">peakList</span><span class="o">.</span><span class="n">fitExistingPeaks</span><span class="p">([</span><span class="n">peak</span><span class="p">],</span> <span class="n">fitMethod</span><span class="o">=</span><span class="n">fitMethod</span><span class="p">,</span>
                                              <span class="n">halfBoxSearchWidth</span><span class="o">=</span><span class="n">halfBoxSearchWidth</span><span class="p">,</span> <span class="n">singularMode</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">keepPosition</span><span class="p">:</span>
                        <span class="n">peak</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">originalPosition</span>
                        <span class="n">peak</span><span class="o">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">peakList</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">getHeight</span><span class="p">(</span><span class="n">peak</span><span class="o">.</span><span class="n">ppmPositions</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">lastLWsFound</span><span class="p">,</span> <span class="n">peak</span><span class="o">.</span><span class="n">lineWidths</span><span class="p">):</span>
                        <span class="n">consecutiveSameLWsCount</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">consecutiveSameLWsCount</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">lastLWsFound</span> <span class="o">=</span> <span class="n">peak</span><span class="o">.</span><span class="n">lineWidths</span>
                    <span class="n">iterations</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Peak fit completed for </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">peak</span><span class="p">)</span>
        <span class="k">return</span></div></div>

    <span class="c1"># def _checkAliasing(self):</span>
    <span class="c1">#     &quot;&quot;&quot;Recalculate the aliasing range for all peaks in the parent spectrum</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     spectrum = self.peakList.spectrum</span>
    <span class="c1">#     alias = spectrum._getAliasingRange()</span>
    <span class="c1">#     if alias is not None:</span>
    <span class="c1">#         spectrum.aliasingRange = alias</span>

    <span class="c1">#===========================================================================================</span>
    <span class="c1"># new&lt;Object&gt; and other methods</span>
    <span class="c1"># Call appropriate routines in their respective locations</span>
    <span class="c1">#===========================================================================================</span>


<span class="c1">#=========================================================================================</span>
<span class="c1"># Connections to parents:</span>
<span class="c1">#=========================================================================================</span>

<span class="nd">@newObject</span><span class="p">(</span><span class="n">Peak</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_newPeak</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">PeakList</span><span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">volume</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
             <span class="n">heightError</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">volumeError</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
             <span class="n">figureOfMerit</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">annotation</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">comment</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
             <span class="n">ppmPositions</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(),</span> <span class="n">position</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">positionError</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(),</span>
             <span class="n">pointPositions</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(),</span> <span class="n">boxWidths</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(),</span>
             <span class="n">lineWidths</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(),</span> <span class="n">ppmLineWidths</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(),</span> <span class="n">pointLineWidths</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(),</span>
             <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Peak</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Create a new Peak within a peakList</span>

<span class="sd">    NB you must create the peak before you can assign it. The assignment attributes are:</span>
<span class="sd">    - assignedNmrAtoms - A tuple of all (e.g.) assignment triplets for a 3D spectrum</span>
<span class="sd">    - dimensionNmrAtoms - A tuple of tuples of assignments, one for each dimension</span>

<span class="sd">    See the Peak class for details.</span>

<span class="sd">    :param height: height of the peak (related attributes: volume, volumeError, lineWidths)</span>
<span class="sd">    :param volume:</span>
<span class="sd">    :param heightError:</span>
<span class="sd">    :param volumeError:</span>
<span class="sd">    :param figureOfMerit:</span>
<span class="sd">    :param annotation:</span>
<span class="sd">    :param comment: optional comment string</span>
<span class="sd">    :param ppmPositions: peak position in ppm for each dimension (related attributes: positionError, pointPositions)</span>
<span class="sd">    :param position: OLD: peak position in ppm for each dimension (related attributes: positionError, pointPositions)</span>
<span class="sd">    :param positionError:</span>
<span class="sd">    :param pointPositions:</span>
<span class="sd">    :param boxWidths:</span>
<span class="sd">    :param lineWidths:</span>
<span class="sd">    :return: a new Peak instance.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">position</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ppmPositions</span> <span class="o">=</span> <span class="n">position</span>  <span class="c1"># Backward compatibility</span>

    <span class="n">apiPeakList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apiPeakList</span>
    <span class="n">apiPeak</span> <span class="o">=</span> <span class="n">apiPeakList</span><span class="o">.</span><span class="n">newPeak</span><span class="p">(</span><span class="n">height</span><span class="o">=</span><span class="n">height</span><span class="p">,</span> <span class="n">volume</span><span class="o">=</span><span class="n">volume</span><span class="p">,</span>
                                  <span class="n">heightError</span><span class="o">=</span><span class="n">heightError</span><span class="p">,</span> <span class="n">volumeError</span><span class="o">=</span><span class="n">volumeError</span><span class="p">,</span>
                                  <span class="n">figOfMerit</span><span class="o">=</span><span class="n">figureOfMerit</span><span class="p">,</span> <span class="n">annotation</span><span class="o">=</span><span class="n">annotation</span><span class="p">,</span> <span class="n">details</span><span class="o">=</span><span class="n">comment</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_project</span><span class="o">.</span><span class="n">_data2Obj</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">apiPeak</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Unable to generate new Peak item&#39;</span><span class="p">)</span>

    <span class="n">apiPeakDims</span> <span class="o">=</span> <span class="n">apiPeak</span><span class="o">.</span><span class="n">sortedPeakDims</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">ppmPositions</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ppmPositions</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">apiPeakDims</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;ppmPositions must be of length </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">apiPeakDims</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">peakDim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">apiPeakDims</span><span class="p">):</span>
            <span class="n">peakDim</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">ppmPositions</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>

    <span class="k">elif</span> <span class="n">pointPositions</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pointPositions</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">apiPeakDims</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;pointPositions must be of length </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">apiPeakDims</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="n">pointCounts</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">pointCounts</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">peakDim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">apiPeakDims</span><span class="p">):</span>
            <span class="c1"># move the peak to the correct aliased position</span>
            <span class="n">alias</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">pointPositions</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="n">pointCounts</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="nb">float</span><span class="p">((</span><span class="n">pointPositions</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">pointCounts</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span> <span class="o">+</span> <span class="mf">1.0</span>  <span class="c1"># API position starts at 1</span>
            <span class="n">peakDim</span><span class="o">.</span><span class="n">numAliasing</span> <span class="o">=</span> <span class="n">alias</span>
            <span class="n">peakDim</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">pos</span>

    <span class="k">if</span> <span class="n">positionError</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">peakDim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">apiPeakDims</span><span class="p">):</span>
            <span class="n">peakDim</span><span class="o">.</span><span class="n">valueError</span> <span class="o">=</span> <span class="n">positionError</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">boxWidths</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">peakDim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">apiPeakDims</span><span class="p">):</span>
            <span class="n">peakDim</span><span class="o">.</span><span class="n">boxWidth</span> <span class="o">=</span> <span class="n">boxWidths</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>

    <span class="c1"># currently, lineWidths/ppmLineWidths are both in Hz/ppm</span>
    <span class="k">if</span> <span class="n">lineWidths</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">peakDim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">apiPeakDims</span><span class="p">):</span>
            <span class="n">peakDim</span><span class="o">.</span><span class="n">lineWidth</span> <span class="o">=</span> <span class="n">lineWidths</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">ppmLineWidths</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">peakDim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">apiPeakDims</span><span class="p">):</span>
            <span class="n">peakDim</span><span class="o">.</span><span class="n">lineWidth</span> <span class="o">=</span> <span class="n">ppmLineWidths</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">pointLineWidths</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">peakDim</span><span class="p">,</span> <span class="n">pointLineWidth</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">apiPeakDims</span><span class="p">,</span> <span class="n">pointLineWidths</span><span class="p">):</span>
            <span class="n">peakDim</span><span class="o">.</span><span class="n">lineWidth</span> <span class="o">=</span> <span class="p">(</span><span class="n">pointLineWidth</span> <span class="o">*</span> <span class="n">peakDim</span><span class="o">.</span><span class="n">dataDim</span><span class="o">.</span><span class="n">valuePerPoint</span><span class="p">)</span> <span class="k">if</span> <span class="n">pointLineWidth</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="n">result</span><span class="o">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">height</span>  <span class="c1"># use the method to store the unit-scaled value</span>
    <span class="n">result</span><span class="o">.</span><span class="n">volume</span> <span class="o">=</span> <span class="n">volume</span>
    <span class="n">result</span><span class="o">.</span><span class="n">heightError</span> <span class="o">=</span> <span class="n">heightError</span>
    <span class="n">result</span><span class="o">.</span><span class="n">volumeError</span> <span class="o">=</span> <span class="n">volumeError</span>

    <span class="k">return</span> <span class="n">result</span>


<span class="nd">@newObject</span><span class="p">(</span><span class="n">Peak</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_newPickedPeak</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">PeakList</span><span class="p">,</span> <span class="n">pointPositions</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                   <span class="n">lineWidths</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(),</span> <span class="n">fitMethod</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;gaussian&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Peak</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Create a new Peak within a peakList from a picked peak</span>

<span class="sd">    See the Peak class for details.</span>

<span class="sd">    :param height: height of the peak (related attributes: volume, volumeError, lineWidths)</span>
<span class="sd">    :param pointPositions: peak position in points for each dimension (related attributes: positionError, pointPositions)</span>
<span class="sd">    :param fitMethod: type of curve fitting</span>
<span class="sd">    :param lineWidths:</span>
<span class="sd">    :return: a new Peak instance.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">apiPeakList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apiPeakList</span>
    <span class="n">apiPeak</span> <span class="o">=</span> <span class="n">apiPeakList</span><span class="o">.</span><span class="n">newPeak</span><span class="p">()</span>
    <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_project</span><span class="o">.</span><span class="n">_data2Obj</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">apiPeak</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Unable to generate new Peak item&#39;</span><span class="p">)</span>

    <span class="n">apiDataSource</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">_apiDataSource</span>
    <span class="n">apiDataDims</span> <span class="o">=</span> <span class="n">apiDataSource</span><span class="o">.</span><span class="n">sortedDataDims</span><span class="p">()</span>
    <span class="n">apiPeakDims</span> <span class="o">=</span> <span class="n">apiPeak</span><span class="o">.</span><span class="n">sortedPeakDims</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">peakDim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">apiPeakDims</span><span class="p">):</span>
        <span class="n">dataDim</span> <span class="o">=</span> <span class="n">apiDataDims</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">dataDim</span><span class="o">.</span><span class="n">className</span> <span class="o">==</span> <span class="s1">&#39;FreqDataDim&#39;</span><span class="p">:</span>
            <span class="n">dataDimRef</span> <span class="o">=</span> <span class="n">dataDim</span><span class="o">.</span><span class="n">primaryDataDimRef</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dataDimRef</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">dataDimRef</span><span class="p">:</span>
            <span class="n">peakDim</span><span class="o">.</span><span class="n">numAliasing</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">divmod</span><span class="p">(</span><span class="n">pointPositions</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dataDim</span><span class="o">.</span><span class="n">numPointsOrig</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">peakDim</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">pointPositions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">peakDim</span><span class="o">.</span><span class="n">numAliasing</span> <span class="o">*</span> <span class="n">dataDim</span><span class="o">.</span><span class="n">numPointsOrig</span><span class="p">)</span>  <span class="c1"># API position starts at 1</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">peakDim</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">pointPositions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">fitMethod</span> <span class="ow">and</span> <span class="n">lineWidths</span> <span class="ow">and</span> <span class="n">lineWidths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">peakDim</span><span class="o">.</span><span class="n">lineWidth</span> <span class="o">=</span> <span class="n">dataDim</span><span class="o">.</span><span class="n">valuePerPoint</span> <span class="o">*</span> <span class="n">lineWidths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>  <span class="c1"># conversion from points to Hz</span>

    <span class="c1"># apiPeak.height = apiDataSource.scale * height</span>
    <span class="c1"># store the unit scaled value</span>
    <span class="n">apiPeak</span><span class="o">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">height</span>

    <span class="k">return</span> <span class="n">result</span>


<span class="c1"># Additional Notifiers:</span>
<span class="c1">#</span>
<span class="c1"># NB These API notifiers will be called for API peaks - which match both Peaks and Integrals</span>
<span class="n">className</span> <span class="o">=</span> <span class="n">Nmr</span><span class="o">.</span><span class="n">PeakDim</span><span class="o">.</span><span class="n">_metaclass</span><span class="o">.</span><span class="n">qualifiedName</span><span class="p">()</span>
<span class="n">Project</span><span class="o">.</span><span class="n">_apiNotifiers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="p">(</span><span class="s1">&#39;_notifyRelatedApiObject&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;pathToObject&#39;</span><span class="p">:</span> <span class="s1">&#39;peak&#39;</span><span class="p">,</span> <span class="s1">&#39;action&#39;</span><span class="p">:</span> <span class="s1">&#39;change&#39;</span><span class="p">},</span> <span class="n">className</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">),</span>
        <span class="p">)</span>
<span class="k">for</span> <span class="n">clazz</span> <span class="ow">in</span> <span class="n">Nmr</span><span class="o">.</span><span class="n">AbstractPeakDimContrib</span><span class="o">.</span><span class="n">_metaclass</span><span class="o">.</span><span class="n">getNonAbstractSubtypes</span><span class="p">():</span>
    <span class="n">className</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="n">qualifiedName</span><span class="p">()</span>
    <span class="c1"># NB - relies on PeakDimContrib.peakDim.peak still working for deleted peak. Should work.</span>
    <span class="n">Project</span><span class="o">.</span><span class="n">_apiNotifiers</span><span class="o">.</span><span class="n">extend</span><span class="p">((</span>
        <span class="p">(</span><span class="s1">&#39;_notifyRelatedApiObject&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;pathToObject&#39;</span><span class="p">:</span> <span class="s1">&#39;peakDim.peak&#39;</span><span class="p">,</span> <span class="s1">&#39;action&#39;</span><span class="p">:</span> <span class="s1">&#39;change&#39;</span><span class="p">},</span>
         <span class="n">className</span><span class="p">,</span> <span class="s1">&#39;postInit&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;_notifyRelatedApiObject&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;pathToObject&#39;</span><span class="p">:</span> <span class="s1">&#39;peakDim.peak&#39;</span><span class="p">,</span> <span class="s1">&#39;action&#39;</span><span class="p">:</span> <span class="s1">&#39;change&#39;</span><span class="p">},</span>
         <span class="n">className</span><span class="p">,</span> <span class="s1">&#39;delete&#39;</span><span class="p">),</span>
        <span class="p">)</span>
            <span class="p">)</span>

<span class="c1"># EJB 20181122: moved to SpectrumReference</span>
<span class="c1"># Notify Peaks change when SpectrumReference changes</span>
<span class="c1"># (That means DataDimRef referencing information)</span>
<span class="c1"># SpectrumReference._setupCoreNotifier(&#39;change&#39;, AbstractWrapperObject._finaliseRelatedObject,</span>
<span class="c1">#                                      {&#39;pathToObject&#39;: &#39;spectrum.peaks&#39;, &#39;action&#39;: &#39;change&#39;})</span>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">Python  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">ccpn.core.Peak</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright .
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.4.0.
    </div>
  </body>
</html>