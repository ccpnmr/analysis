
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ccpn.core.Spectrum &#8212; Python  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/classic.css" />
    
    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">Python  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">ccpn.core.Spectrum</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for ccpn.core.Spectrum</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Spectrum  class.</span>
<span class="sd">Maintains the parameters of a spectrum, including per-dimension/axis values.</span>
<span class="sd">Values that are not defined for a given dimension (e.g. sampled dimensions) are given as None.</span>

<span class="sd">Dimension identifiers run from 1 to the number of dimensions, i.e. dimensionCount,  (e.g. 1,2,3 for a 3D).</span>
<span class="sd">CCPN data the preferred convention is to have the acquisition dimension as dimension 1.</span>

<span class="sd">Axes identifiers run from 0 to the dimensionCount-1 (e.g. 0,1,2 for a 3D)</span>
<span class="sd">Per-axis values are given in the order data are stored in the spectrum file</span>

<span class="sd">The axisCodes are used as an alternative axis identifier. These are unique strings that typically</span>
<span class="sd">reflect the isotope on the relevant axis.</span>
<span class="sd">By default upon loading a new spectrum, the axisCodes are derived from the isotopeCodes that define</span>
<span class="sd">the experimental data for each dimension.</span>
<span class="sd">They can match the dimension identifiers in the reference experiment templates, linking a dimension</span>
<span class="sd">to the correct reference experiment dimension.</span>
<span class="sd">They are also used to automatically map spectrum display-axes between different spectra on a first</span>
<span class="sd">character basis.</span>
<span class="sd">Axes that are linked by a one-bond magnetisation transfer could be given a lower-case suffix to</span>
<span class="sd">show the nucleus bound to. Duplicate axis names should be distinguished by a numerical suffix.</span>
<span class="sd">The rules are best illustrated by example:</span>

<span class="sd">Experiment                          axisCodes</span>

<span class="sd">15N-NOESY-HSQC OR 15N-HSQC-NOESY:   Hn, Nh, H</span>
<span class="sd">4D HCCH-TOCSY                       Hc, Ch, Hc1, Ch1</span>
<span class="sd">HNCA/CB                             H, N, C</span>
<span class="sd">HNCO                                H, N, CO</span>
<span class="sd">HCACO                               H, CA, CO</span>
<span class="sd">3D proton NOESY-TOCSY               H, H1, H2</span>

<span class="sd">1D Bromine NMR                      Br</span>
<span class="sd">19F-13C-HSQC                        Fc, Cf</span>

<span class="sd">Useful reordering methods exist to get dimensional/axis parameters in a particular order, i.e.:</span>
<span class="sd">getByDimension(), setByDimension(), getByAxisCode(), setByAxisCode()</span>
<span class="sd">See doc strings of these methods for detailed documentation</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="c1">#=========================================================================================</span>
<span class="c1"># Licence, Reference and Credits</span>
<span class="c1">#=========================================================================================</span>
<span class="n">__copyright__</span> <span class="o">=</span> <span class="s2">&quot;Copyright (C) CCPN project (https://www.ccpn.ac.uk) 2014 - 2022&quot;</span>
<span class="n">__credits__</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Ed Brooksbank, Joanna Fox, Victoria A Higman, Luca Mureddu, Eliza Płoskoń&quot;</span><span class="p">,</span>
               <span class="s2">&quot;Timothy J Ragan, Brian O Smith, Gary S Thompson &amp; Geerten W Vuister&quot;</span><span class="p">)</span>
<span class="n">__licence__</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;CCPN licence. See https://ccpn.ac.uk/software/licensing/&quot;</span><span class="p">)</span>
<span class="n">__reference__</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Skinner, S.P., Fogh, R.H., Boucher, W., Ragan, T.J., Mureddu, L.G., &amp; Vuister, G.W.&quot;</span><span class="p">,</span>
                 <span class="s2">&quot;CcpNmr AnalysisAssign: a flexible platform for integrated NMR analysis&quot;</span><span class="p">,</span>
                 <span class="s2">&quot;J.Biomol.Nmr (2016), 66, 111-124, http://doi.org/10.1007/s10858-016-0060-y&quot;</span><span class="p">)</span>
<span class="c1">#=========================================================================================</span>
<span class="c1"># Last code modification</span>
<span class="c1">#=========================================================================================</span>
<span class="n">__modifiedBy__</span> <span class="o">=</span> <span class="s2">&quot;$modifiedBy: Ed Brooksbank $&quot;</span>
<span class="n">__dateModified__</span> <span class="o">=</span> <span class="s2">&quot;$dateModified: 2022-07-05 13:20:38 +0100 (Tue, July 05, 2022) $&quot;</span>
<span class="n">__version__</span> <span class="o">=</span> <span class="s2">&quot;$Revision: 3.1.0 $&quot;</span>
<span class="c1">#=========================================================================================</span>
<span class="c1"># Created</span>
<span class="c1">#=========================================================================================</span>
<span class="n">__author__</span> <span class="o">=</span> <span class="s2">&quot;$Author: CCPN $&quot;</span>
<span class="n">__date__</span> <span class="o">=</span> <span class="s2">&quot;$Date: 2017-04-07 10:28:41 +0000 (Fri, April 07, 2017) $&quot;</span>
<span class="c1">#=========================================================================================</span>
<span class="c1"># Start of code</span>
<span class="c1">#=========================================================================================</span>

<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">List</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">permutations</span>
<span class="kn">import</span> <span class="nn">numpy</span>

<span class="kn">from</span> <span class="nn">ccpnmodel.ccpncore.api.ccp.nmr</span> <span class="kn">import</span> <span class="n">Nmr</span>

<span class="kn">from</span> <span class="nn">ccpn.core._implementation.AbstractWrapperObject</span> <span class="kn">import</span> <span class="n">AbstractWrapperObject</span>
<span class="kn">from</span> <span class="nn">ccpn.core._implementation.SpectrumTraits</span> <span class="kn">import</span> <span class="n">SpectrumTraits</span>
<span class="kn">from</span> <span class="nn">ccpn.core._implementation.SpectrumData</span> <span class="kn">import</span> <span class="n">SliceData</span><span class="p">,</span> <span class="n">PlaneData</span><span class="p">,</span> <span class="n">RegionData</span>

<span class="kn">from</span> <span class="nn">ccpn.core.Project</span> <span class="kn">import</span> <span class="n">Project</span>
<span class="kn">from</span> <span class="nn">ccpn.core.lib</span> <span class="kn">import</span> <span class="n">Pid</span>

<span class="kn">import</span> <span class="nn">ccpn.core.lib.SpectrumLib</span> <span class="k">as</span> <span class="nn">specLib</span>
<span class="kn">from</span> <span class="nn">ccpn.core.lib.SpectrumLib</span> <span class="kn">import</span> <span class="n">MagnetisationTransferTuple</span><span class="p">,</span> <span class="n">_getProjection</span><span class="p">,</span> <span class="n">getDefaultSpectrumColours</span>
<span class="kn">from</span> <span class="nn">ccpn.core.lib.SpectrumLib</span> <span class="kn">import</span> <span class="n">_includeInDimensionalCopy</span><span class="p">,</span> <span class="n">_includeInCopy</span><span class="p">,</span> <span class="n">_includeInCopyList</span><span class="p">,</span> \
    <span class="n">checkSpectrumPropertyValue</span><span class="p">,</span> <span class="n">_setDefaultAxisOrdering</span>

<span class="kn">from</span> <span class="nn">ccpn.core.lib.ContextManagers</span> <span class="kn">import</span> \
    <span class="n">newObject</span><span class="p">,</span> <span class="n">deleteObject</span><span class="p">,</span> <span class="n">ccpNmrV3CoreSimple</span><span class="p">,</span> \
    <span class="n">undoStackBlocking</span><span class="p">,</span> <span class="n">renameObject</span><span class="p">,</span> <span class="n">undoBlock</span><span class="p">,</span> <span class="n">notificationBlanking</span><span class="p">,</span> \
    <span class="n">ccpNmrV3CoreSetter</span><span class="p">,</span> <span class="n">inactivity</span><span class="p">,</span> <span class="n">undoBlockWithoutSideBar</span>

<span class="kn">from</span> <span class="nn">ccpn.core.lib.DataStore</span> <span class="kn">import</span> <span class="n">DataStore</span><span class="p">,</span> <span class="n">DataStoreTrait</span>

<span class="kn">from</span> <span class="nn">ccpn.core.lib.SpectrumDataSources.SpectrumDataSourceABC</span> <span class="kn">import</span> \
    <span class="n">getDataFormats</span><span class="p">,</span> <span class="n">getSpectrumDataSource</span><span class="p">,</span> <span class="n">checkPathForSpectrumFormats</span><span class="p">,</span> <span class="n">DataSourceTrait</span>
<span class="kn">from</span> <span class="nn">ccpn.core.lib.SpectrumDataSources.EmptySpectrumDataSource</span> <span class="kn">import</span> <span class="n">EmptySpectrumDataSource</span>
<span class="kn">from</span> <span class="nn">ccpn.core.lib.SpectrumDataSources.Hdf5SpectrumDataSource</span> <span class="kn">import</span> <span class="n">Hdf5SpectrumDataSource</span>

<span class="kn">from</span> <span class="nn">ccpn.core.lib.Cache</span> <span class="kn">import</span> <span class="n">cached</span>

<span class="kn">from</span> <span class="nn">ccpn.core.lib.PeakPickers.PeakPickerABC</span> <span class="kn">import</span> <span class="n">PeakPickerTrait</span>

<span class="kn">from</span> <span class="nn">ccpn.util.traits.CcpNmrJson</span> <span class="kn">import</span> <span class="n">CcpNmrJson</span><span class="p">,</span> <span class="n">jsonHandler</span>
<span class="kn">from</span> <span class="nn">ccpn.util.traits.CcpNmrTraits</span> <span class="kn">import</span> <span class="n">Int</span><span class="p">,</span> <span class="n">Float</span><span class="p">,</span> <span class="n">Instance</span><span class="p">,</span> <span class="n">Any</span>
<span class="kn">from</span> <span class="nn">ccpn.core.lib.SpectrumLib</span> <span class="kn">import</span> <span class="n">SpectrumDimensionTrait</span>

<span class="kn">from</span> <span class="nn">ccpn.framework.PathsAndUrls</span> <span class="kn">import</span> <span class="n">CCPN_STATE_DIRECTORY</span><span class="p">,</span> <span class="n">CCPN_SPECTRA_DIRECTORY</span>
<span class="kn">from</span> <span class="nn">ccpn.framework.Application</span> <span class="kn">import</span> <span class="n">getApplication</span>

<span class="kn">from</span> <span class="nn">ccpn.util.Constants</span> <span class="kn">import</span> <span class="n">SCALETOLERANCE</span>
<span class="kn">from</span> <span class="nn">ccpn.util.Common</span> <span class="kn">import</span> <span class="n">isIterable</span><span class="p">,</span> <span class="n">_getObjectsByPids</span>
<span class="kn">from</span> <span class="nn">ccpn.core.lib.AxisCodeLib</span> <span class="kn">import</span> <span class="n">getAxisCodeMatch</span>
<span class="kn">from</span> <span class="nn">ccpn.util.Logging</span> <span class="kn">import</span> <span class="n">getLogger</span>
<span class="kn">from</span> <span class="nn">ccpn.util.decorators</span> <span class="kn">import</span> <span class="n">logCommand</span><span class="p">,</span> <span class="n">singleton</span>
<span class="kn">from</span> <span class="nn">ccpn.util.Path</span> <span class="kn">import</span> <span class="n">Path</span><span class="p">,</span> <span class="n">aPath</span>

<span class="c1"># defined here too as imported from Spectrum throughout the code base</span>
<span class="n">MAXALIASINGRANGE</span> <span class="o">=</span> <span class="n">specLib</span><span class="o">.</span><span class="n">MAXALIASINGRANGE</span>

<span class="c1">#=========================================================================================</span>
<span class="c1"># Spectrum class</span>
<span class="c1">#=========================================================================================</span>

<span class="kn">from</span> <span class="nn">ccpn.core._implementation.updates.update_3_0_4</span> <span class="kn">import</span> <span class="n">_updateSpectrum_3_0_4_to_3_1_0</span>
<span class="kn">from</span> <span class="nn">ccpn.core._implementation.Updater</span> <span class="kn">import</span> <span class="n">updateObject</span><span class="p">,</span> <span class="n">UPDATE_POST_PROJECT_INITIALISATION</span>

<div class="viewcode-block" id="Spectrum"><a class="viewcode-back" href="../../../ccpn/ccpn.core.html#ccpn.core.Spectrum.Spectrum">[docs]</a><span class="nd">@updateObject</span><span class="p">(</span><span class="n">fromVersion</span> <span class="o">=</span> <span class="s1">&#39;3.0.4&#39;</span><span class="p">,</span>
              <span class="n">toVersion</span> <span class="o">=</span> <span class="s1">&#39;3.1.0&#39;</span><span class="p">,</span>
              <span class="n">updateFunction</span> <span class="o">=</span><span class="n">_updateSpectrum_3_0_4_to_3_1_0</span><span class="p">,</span>
              <span class="n">updateMethod</span> <span class="o">=</span> <span class="n">UPDATE_POST_PROJECT_INITIALISATION</span>
              <span class="p">)</span>
<span class="k">class</span> <span class="nc">Spectrum</span><span class="p">(</span><span class="n">AbstractWrapperObject</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A Spectrum object contains all the stored properties of an NMR spectrum, as well as the</span>
<span class="sd">    path to the NMR (binary) data file. The Spectrum object has methods to get the binary data</span>
<span class="sd">    as SpectrumData (i.e. numpy.ndarray) objects.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#-----------------------------------------------------------------------------------------</span>

    <span class="c1">#: Short class name, for PID.</span>
    <span class="n">shortClassName</span> <span class="o">=</span> <span class="s1">&#39;SP&#39;</span>
    <span class="c1"># Attribute it necessary as subclasses must use superclass className</span>
    <span class="n">className</span> <span class="o">=</span> <span class="s1">&#39;Spectrum&#39;</span>

    <span class="n">_parentClass</span> <span class="o">=</span> <span class="n">Project</span>

    <span class="c1">#: Name of plural link to instances of class</span>
    <span class="n">_pluralLinkName</span> <span class="o">=</span> <span class="s1">&#39;spectra&#39;</span>

    <span class="c1">#: List of child classes.</span>
    <span class="n">_childClasses</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Qualified name of matching API class</span>
    <span class="n">_apiClassQualifiedName</span> <span class="o">=</span> <span class="n">Nmr</span><span class="o">.</span><span class="n">DataSource</span><span class="o">.</span><span class="n">_metaclass</span><span class="o">.</span><span class="n">qualifiedName</span><span class="p">()</span>

    <span class="c1">#-----------------------------------------------------------------------------------------</span>
    <span class="c1"># &#39;local&#39; definition of MAXDIM; defining defs in SpectrumLib to prevent circular imports</span>
    <span class="n">MAXDIM</span> <span class="o">=</span> <span class="n">specLib</span><span class="o">.</span><span class="n">MAXDIM</span>  <span class="c1"># 8  # Maximum dimensionality</span>

    <span class="c1">#-----------------------------------------------------------------------------------------</span>
    <span class="c1"># Internal NameSpace  and other definitions</span>
    <span class="c1">#-----------------------------------------------------------------------------------------</span>

    <span class="c1"># Key for storing the dataStore info in the Ccpn internal parameter store</span>
    <span class="n">_DATASTORE_KEY</span> <span class="o">=</span> <span class="s1">&#39;_dataStore&#39;</span>
    <span class="n">_REFERENCESUBSTANCESCACHE</span> <span class="o">=</span> <span class="s1">&#39;_referenceSubstances&#39;</span>

    <span class="n">_AdditionalAttribute</span> <span class="o">=</span> <span class="s1">&#39;AdditionalAttribute&#39;</span>
    <span class="n">_ReferenceSubstancesPids</span> <span class="o">=</span> <span class="s1">&#39;_ReferenceSubstancesPids&#39;</span>
    <span class="n">_REFERENCESUBSTANCES</span> <span class="o">=</span> <span class="s1">&#39;referenceSubstances&#39;</span>

    <span class="n">_INCLUDEPOSITIVECONTOURS</span> <span class="o">=</span> <span class="s1">&#39;includePositiveContours&#39;</span>
    <span class="n">_INCLUDENEGATIVECONTOURS</span> <span class="o">=</span> <span class="s1">&#39;includeNegativeContours&#39;</span>
    <span class="n">_PREFERREDAXISORDERING</span> <span class="o">=</span> <span class="s1">&#39;_preferredAxisOrdering&#39;</span>
    <span class="n">_SERIESITEMS</span> <span class="o">=</span> <span class="s1">&#39;_seriesItems&#39;</span>
    <span class="n">_DISPLAYFOLDEDCONTOURS</span> <span class="o">=</span> <span class="s1">&#39;displayFoldedContours&#39;</span>
    <span class="n">_NEGATIVENOISELEVEL</span> <span class="o">=</span> <span class="s1">&#39;negativeNoiseLevel&#39;</span>

    <span class="c1">#-----------------------------------------------------------------------------------------</span>
    <span class="c1"># Attributes of the data structure (incomplete?)</span>
    <span class="c1">#-----------------------------------------------------------------------------------------</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">peakLists</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;STUB: hot-fixed later&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">multipletLists</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;STUB: hot-fixed later&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">integralLists</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;STUB: hot-fixed later&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spectrumViews</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return a tuple of SpectrumView instances associated with this spectrum&quot;&quot;&quot;</span>
        <span class="n">specViews</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_project</span><span class="o">.</span><span class="n">_data2Obj</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">sortedSpectrumViews</span><span class="p">()</span>
                     <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">sortedStripSpectrumViews</span><span class="p">()]</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">specViews</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">chemicalShiftList</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;STUB: hot-fixed later&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spectrumReferences</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;list of spectrumReferences objects</span>
<span class="sd">        STUB: hot-fixed later</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spectrumDimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;:return A tuple with the spectrum dimensions (== SpectrumReference or PseudoDimension) instances</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spectrumDimensions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data2obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">project</span><span class="o">.</span><span class="n">_data2Obj</span>

            <span class="n">dataDims</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">sortedDataDims</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">dim</span><span class="o">.</span><span class="n">className</span> <span class="o">==</span> <span class="s1">&#39;FreqDataDim&#39;</span><span class="p">:</span>
                    <span class="n">dataDims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">dim</span><span class="o">.</span><span class="n">dataDimRefs</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dataDims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>

            <span class="n">sDims</span> <span class="o">=</span> <span class="p">[</span><span class="n">data2obj</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">dataDims</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_spectrumDimensions</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">sDims</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_spectrumDimensions</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spectrumHits</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;STUB: hot-fixed later&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;STUB: hot-fixed later&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># Inherited from AbstractWrapperObject</span>
    <span class="c1"># @property</span>
    <span class="c1"># def project(self) -&gt; &#39;Project&#39;:</span>
    <span class="c1">#     &quot;&quot;&quot;The Project (root)containing the object.&quot;&quot;&quot;</span>
    <span class="c1">#     return self._project</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_parent</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Project</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Parent (containing) object.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_project</span>

    <span class="c1">#-----------------------------------------------------------------------------------------</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">project</span><span class="p">:</span> <span class="n">Project</span><span class="p">,</span> <span class="n">wrappedData</span><span class="p">:</span> <span class="n">Nmr</span><span class="o">.</span><span class="n">DataSource</span><span class="p">):</span>

        <span class="c1"># super().__init__(project, wrappedData)</span>
        <span class="c1"># CcpNmrJson.__init__(self)</span>
        <span class="n">AbstractWrapperObject</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">project</span><span class="p">,</span> <span class="n">wrappedData</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_spectrumTraits</span> <span class="o">=</span> <span class="n">SpectrumTraits</span><span class="p">(</span><span class="n">spectrum</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># 1D data references</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_intensities</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_positions</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_spectrumDimensions</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># A tuple of SpectrumReferences instances; set once and retained for speed</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">doubleCrosshairOffsets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensionCount</span> <span class="o">*</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># TBD: do we need this to be a property?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scaleChanged</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1">#-----------------------------------------------------------------------------------------</span>
    <span class="c1"># end __init__</span>
    <span class="c1">#-----------------------------------------------------------------------------------------</span>

    <span class="c1"># References to DataStore / DataSource instances for filePath manipulation and (binary)</span>
    <span class="c1"># data reading;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_dataStore</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A DataStore instance encoding the filePath and dataFormat of the (binary) spectrum data.</span>
<span class="sd">           None indicates no spectrum filePile path has been defined</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spectrumTraits</span><span class="o">.</span><span class="n">dataStore</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dataSource</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A SpectrumDataSource instance for reading (writing) of the (binary) spectrum data.</span>
<span class="sd">        None indicates no valid spectrum data file has been defined</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spectrumTraits</span><span class="o">.</span><span class="n">dataSource</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">peakPicker</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A PeakPicker instance for region picking in this spectrum.</span>
<span class="sd">        None indicates no valid PeakPicker has been defined</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># GWV: this should not happen; a default is set on restore or newSpectrum</span>
        <span class="c1"># if self._spectrumTraits.peakPicker is None:</span>
        <span class="c1">#     if (_peakPicker := self._getPeakPicker()) is not None:</span>
        <span class="c1">#         self.peakPicker = _peakPicker</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spectrumTraits</span><span class="o">.</span><span class="n">peakPicker</span>

    <span class="nd">@peakPicker</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">peakPicker</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">peakPicker</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the current peakPicker or deassign when None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">peakPicker</span> <span class="ow">and</span> <span class="n">peakPicker</span><span class="o">.</span><span class="n">spectrum</span> <span class="o">!=</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Invalid peakPicker: already linked to </span><span class="si">{</span><span class="n">peakPicker</span><span class="o">.</span><span class="n">spectrum</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">peakPicker</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">undoBlockWithoutSideBar</span><span class="p">():</span>
                <span class="c1"># set the current peakPicker</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_spectrumTraits</span><span class="o">.</span><span class="n">peakPicker</span> <span class="o">=</span> <span class="n">peakPicker</span>
                <span class="c1"># automatically store in the spectrum CCPN internal store</span>
                <span class="n">peakPicker</span><span class="o">.</span><span class="n">_storeAttributes</span><span class="p">()</span>
                <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Setting peakPicker to </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">peakPicker</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">undoBlockWithoutSideBar</span><span class="p">():</span>
                <span class="c1"># clear the current peakPicker</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spectrumTraits</span><span class="o">.</span><span class="n">peakPicker</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_spectrumTraits</span><span class="o">.</span><span class="n">peakPicker</span><span class="o">.</span><span class="n">_detachFromSpectrum</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_spectrumTraits</span><span class="o">.</span><span class="n">peakPicker</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Clearing current peakPicker&#39;</span><span class="p">)</span>

    <span class="c1">#-----------------------------------------------------------------------------------------</span>
    <span class="c1"># Spectrum properties</span>
    <span class="c1">#-----------------------------------------------------------------------------------------</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;short form of name, used for id&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">name</span>

    <span class="nd">@name</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;set name of Spectrum.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dimensionCount</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Number of dimensions in spectrum&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">numDim</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Convenience: tuple (len dimensionCount) with the dimension integers (1-based);</span>
<span class="sd">        e.g. (1,2,3,..).</span>
<span class="sd">        Useful for mapping in axisCodes order: eg: self.getByAxisCodes(&#39;dimensions&#39;, [&#39;N&#39;,&#39;C&#39;,&#39;H&#39;])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensionCount</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dimensionIndices</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Convenience: tuple (len dimensionCount) with the dimension indices (0-based);</span>
<span class="sd">        e.g. (0,1,2,3).</span>
<span class="sd">        Useful for mapping in axisCodes order: eg: self.getByAxisCodes(&#39;dimensionIndices&#39;, [&#39;N&#39;,&#39;C&#39;,&#39;H&#39;])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensionCount</span><span class="p">))</span>

    <span class="c1"># legacy</span>
    <span class="n">axisIndices</span> <span class="o">=</span> <span class="n">dimensionIndices</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dimensionTriples</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Convenience: return a tuple of triples (dimensionIndex, axisCode, dimension) for each dimension</span>

<span class="sd">        Useful for iterating over axis codes; eg in an H-N-CO ordered spectrum</span>
<span class="sd">            for dimIndex, axisCode, dimension in self.getByAxisCodes(&#39;dimensionTriples&#39;, (&#39;N&#39;,&#39;C&#39;,&#39;H&#39;), exactMatch=False)</span>

<span class="sd">            would yield:</span>
<span class="sd">                (1, &#39;N&#39;, 2)</span>
<span class="sd">                (2, &#39;CO&#39;, 3)</span>
<span class="sd">                (0, &#39;H&#39;, 1)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">z</span> <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensionIndices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axisCodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="nd">@_includeInCopy</span>
    <span class="k">def</span> <span class="nf">positiveContourCount</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;number of positive contours to draw&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">positiveContourCount</span>

    <span class="nd">@positiveContourCount</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@logCommand</span><span class="p">(</span><span class="n">get</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">,</span> <span class="n">isProperty</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">positiveContourCount</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">positiveContourCount</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="nd">@_includeInCopy</span>
    <span class="k">def</span> <span class="nf">positiveContourBase</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;base level of positive contours&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">positiveContourBase</span>

    <span class="nd">@positiveContourBase</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@logCommand</span><span class="p">(</span><span class="n">get</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">,</span> <span class="n">isProperty</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">positiveContourBase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">positiveContourBase</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="nd">@_includeInCopy</span>
    <span class="k">def</span> <span class="nf">positiveContourFactor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;level multiplier for positive contours&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">positiveContourFactor</span>

    <span class="nd">@positiveContourFactor</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@logCommand</span><span class="p">(</span><span class="n">get</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">,</span> <span class="n">isProperty</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">positiveContourFactor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">positiveContourFactor</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="nd">@_includeInCopy</span>
    <span class="k">def</span> <span class="nf">positiveContourColour</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;colour of positive contours&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">positiveContourColour</span>

    <span class="nd">@positiveContourColour</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@logCommand</span><span class="p">(</span><span class="n">get</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">,</span> <span class="n">isProperty</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">positiveContourColour</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">positiveContourColour</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="nd">@_includeInCopy</span>
    <span class="k">def</span> <span class="nf">includePositiveContours</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Include flag for the positive contours</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getInternalParameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_INCLUDEPOSITIVECONTOURS</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># default to True</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@includePositiveContours</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@logCommand</span><span class="p">(</span><span class="n">get</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">,</span> <span class="n">isProperty</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nd">@ccpNmrV3CoreSetter</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">includePositiveContours</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Include flag for the positive contours</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Spectrum.includePositiveContours: must be True/False&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_setInternalParameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_INCLUDEPOSITIVECONTOURS</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="nd">@_includeInCopy</span>
    <span class="k">def</span> <span class="nf">negativeContourCount</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;number of negative contours to draw&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">negativeContourCount</span>

    <span class="nd">@negativeContourCount</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@logCommand</span><span class="p">(</span><span class="n">get</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">,</span> <span class="n">isProperty</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">negativeContourCount</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">negativeContourCount</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="nd">@_includeInCopy</span>
    <span class="k">def</span> <span class="nf">negativeContourBase</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;base level of negative contours&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">negativeContourBase</span>

    <span class="nd">@negativeContourBase</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@logCommand</span><span class="p">(</span><span class="n">get</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">,</span> <span class="n">isProperty</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">negativeContourBase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">negativeContourBase</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="nd">@_includeInCopy</span>
    <span class="k">def</span> <span class="nf">negativeContourFactor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;level multiplier for negative contours&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">negativeContourFactor</span>

    <span class="nd">@negativeContourFactor</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@logCommand</span><span class="p">(</span><span class="n">get</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">,</span> <span class="n">isProperty</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">negativeContourFactor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">negativeContourFactor</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="nd">@_includeInCopy</span>
    <span class="k">def</span> <span class="nf">negativeContourColour</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;colour of negative contours&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">negativeContourColour</span>

    <span class="nd">@negativeContourColour</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@logCommand</span><span class="p">(</span><span class="n">get</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">,</span> <span class="n">isProperty</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">negativeContourColour</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">negativeContourColour</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="nd">@_includeInCopy</span>
    <span class="k">def</span> <span class="nf">includeNegativeContours</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Include flag for the negative contours</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getInternalParameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_INCLUDENEGATIVECONTOURS</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># default to True</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@includeNegativeContours</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@logCommand</span><span class="p">(</span><span class="n">get</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">,</span> <span class="n">isProperty</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nd">@ccpNmrV3CoreSetter</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">includeNegativeContours</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Include flag for the negative contours</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Spectrum.includeNegativeContours: must be True/False&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_setInternalParameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_INCLUDENEGATIVECONTOURS</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="nd">@_includeInCopy</span>
    <span class="k">def</span> <span class="nf">sliceColour</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;colour of 1D slices</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">sliceColour</span>

    <span class="nd">@sliceColour</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@logCommand</span><span class="p">(</span><span class="n">get</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">,</span> <span class="n">isProperty</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">sliceColour</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">sliceColour</span> <span class="o">=</span> <span class="n">value</span>
        <span class="c1"># for spectrumView in self.spectrumViews:</span>
        <span class="c1">#     spectrumView.setSliceColour()  # ejb - update colour here</span>

    <span class="nd">@property</span>
    <span class="nd">@_includeInCopy</span>
    <span class="k">def</span> <span class="nf">scale</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Scaling factor for data in the spectrum.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">scale</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Scaling </span><span class="si">{}</span><span class="s1"> changed from None to 1.0&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="n">value</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="k">if</span> <span class="o">-</span><span class="n">SCALETOLERANCE</span> <span class="o">&lt;</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="n">SCALETOLERANCE</span><span class="p">:</span>
            <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Scaling </span><span class="si">{}</span><span class="s1"> by minimum tolerance (±</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">SCALETOLERANCE</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">value</span>

    <span class="nd">@scale</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@logCommand</span><span class="p">(</span><span class="n">get</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">,</span> <span class="n">isProperty</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nd">@ccpNmrV3CoreSimple</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">scale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Scaling </span><span class="si">{}</span><span class="s1"> changed from None to 1.0&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="n">value</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Spectrum.scale </span><span class="si">{}</span><span class="s1"> must be a float or integer&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="o">-</span><span class="n">SCALETOLERANCE</span> <span class="o">&lt;</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="n">SCALETOLERANCE</span><span class="p">:</span>
            <span class="c1"># Display a warning, but allow to be set</span>
            <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Scaling </span><span class="si">{}</span><span class="s1"> by minimum tolerance (±</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">SCALETOLERANCE</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_scaleChanged</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensionCount</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intensities</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># some 1D data were read before; update the intensities as the scale has changed</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_intensities</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getSliceData</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="nd">@_includeInCopy</span>
    <span class="k">def</span> <span class="nf">spinningRate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;NMR tube spinning rate (in Hz)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">experiment</span><span class="o">.</span><span class="n">spinningRate</span>

    <span class="nd">@spinningRate</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@logCommand</span><span class="p">(</span><span class="n">get</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">,</span> <span class="n">isProperty</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">spinningRate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">experiment</span><span class="o">.</span><span class="n">spinningRate</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="nd">@_includeInCopy</span>
    <span class="k">def</span> <span class="nf">noiseLevel</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Noise level for the spectrum</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">noiseLevel</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mf">1.0</span>
        <span class="k">if</span> <span class="n">noise</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">debug2</span><span class="p">(</span><span class="s1">&#39;Noise Level is None.&#39;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">noiseLevel</span> <span class="o">*</span> <span class="n">scale</span>

    <span class="nd">@noiseLevel</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@logCommand</span><span class="p">(</span><span class="n">get</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">,</span> <span class="n">isProperty</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">noiseLevel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mf">1.0</span>
        <span class="n">val</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">scale</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">/</span><span class="n">scale</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">noiseLevel</span> <span class="o">=</span> <span class="n">val</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">noiseLevel</span> <span class="o">=</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="nd">@_includeInCopy</span>
    <span class="k">def</span> <span class="nf">negativeNoiseLevel</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Negative noise level value. Stored in Internal&quot;&quot;&quot;</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getInternalParameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_NEGATIVENOISELEVEL</span><span class="p">)</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mf">1.0</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">debug2</span><span class="p">(</span><span class="s1">&#39;Returning negativeNoiseLevel=None&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">value</span> <span class="o">*</span> <span class="n">scale</span>

    <span class="nd">@negativeNoiseLevel</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@logCommand</span><span class="p">(</span><span class="n">get</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">,</span> <span class="n">isProperty</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">negativeNoiseLevel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Stored in Internal &quot;&quot;&quot;</span>

        <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mf">1.0</span>
        <span class="n">value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">scale</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">value</span> <span class="o">/</span> <span class="n">scale</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_setInternalParameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_NEGATIVENOISELEVEL</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">synonym</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Systematic experiment type descriptor (CCPN system).&quot;&quot;&quot;</span>
        <span class="n">refExperiment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">experiment</span><span class="o">.</span><span class="n">refExperiment</span>
        <span class="k">if</span> <span class="n">refExperiment</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">refExperiment</span><span class="o">.</span><span class="n">synonym</span>

    <span class="nd">@property</span>
    <span class="nd">@_includeInCopy</span>
    <span class="k">def</span> <span class="nf">experimentType</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Systematic experiment type descriptor (CCPN system).&quot;&quot;&quot;</span>
        <span class="n">refExperiment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">experiment</span><span class="o">.</span><span class="n">refExperiment</span>
        <span class="k">if</span> <span class="n">refExperiment</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">refExperiment</span><span class="o">.</span><span class="n">name</span>

    <span class="nd">@experimentType</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@logCommand</span><span class="p">(</span><span class="n">get</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">,</span> <span class="n">isProperty</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">experimentType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">ccpn.core.lib.SpectrumLib</span> <span class="kn">import</span> <span class="n">_setApiExpTransfers</span><span class="p">,</span> <span class="n">_setApiRefExperiment</span><span class="p">,</span> <span class="n">_clearLinkToRefExp</span>

        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">experiment</span><span class="o">.</span><span class="n">refExperiment</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">experimentName</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">_clearLinkToRefExp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">experiment</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="c1"># nmrExpPrototype = self._wrappedData.root.findFirstNmrExpPrototype(name=value) # Why not findFirst instead of looping all sortedNmrExpPrototypes</span>
        <span class="k">for</span> <span class="n">nmrExpPrototype</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">sortedNmrExpPrototypes</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">refExperiment</span> <span class="ow">in</span> <span class="n">nmrExpPrototype</span><span class="o">.</span><span class="n">sortedRefExperiments</span><span class="p">():</span>
                <span class="c1"># check if the given value is in the STD nomenclature rather than the CCPN! E.g.: standard=COSY; CCPN=HH</span>
                <span class="n">ccpnName</span> <span class="o">=</span> <span class="n">refExperiment</span><span class="o">.</span><span class="n">name</span>
                <span class="n">standardName</span> <span class="o">=</span> <span class="n">refExperiment</span><span class="o">.</span><span class="n">synonym</span>
                <span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="p">[</span><span class="n">ccpnName</span><span class="p">,</span> <span class="n">standardName</span><span class="p">]</span> <span class="p">:</span>
                    <span class="c1"># set API RefExperiment and ExpTransfer</span>
                    <span class="n">_setApiRefExperiment</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">experiment</span><span class="p">,</span> <span class="n">refExperiment</span><span class="p">)</span>
                    <span class="n">_setApiExpTransfers</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">experiment</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">standardName</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">experimentName</span> <span class="o">=</span> <span class="n">standardName</span>
                    <span class="k">return</span>
        <span class="c1"># No reason to raise an error if cannot find a CCPN experimentType definition!</span>
        <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Could not set ExperimentType. No reference experiment matches name &quot;</span><span class="si">%s</span><span class="s1">.&quot;&#39;</span> <span class="o">%</span> <span class="n">value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">experiment</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the experiment assigned to the spectrum</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">experiment</span>

    <span class="nd">@property</span>
    <span class="nd">@_includeInCopy</span>
    <span class="k">def</span> <span class="nf">experimentName</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Common experiment type descriptor (May not be unique).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">experiment</span><span class="o">.</span><span class="n">name</span>

    <span class="nd">@experimentName</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@logCommand</span><span class="p">(</span><span class="n">get</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">,</span> <span class="n">isProperty</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">experimentName</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="c1"># force to a string</span>
        <span class="c1"># because: reading from .nef files extracts the name from the end of the experiment_type in nef reader</span>
        <span class="c1">#           which is not wrapped with quotes, so defaults to an int if it can?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">experiment</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">filePath</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Definition of the NMR (binary) dataSource file; can contain redirections (e.g. $DATA)</span>
<span class="sd">        Use Spectrum.path attribute for an absolute, decoded path</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dataStore</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;dataStore not defined&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dataStore</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>

    <span class="nd">@filePath</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@logCommand</span><span class="p">(</span><span class="n">get</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">,</span> <span class="n">isProperty</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nd">@ccpNmrV3CoreSetter</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">filePath</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dataStore</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;dataStore not defined&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_close</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dataStore</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_openFile</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="n">value</span><span class="p">,</span> <span class="n">dataFormat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dataFormat</span><span class="p">,</span> <span class="n">checkParameters</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dataFormat</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;The spectrum data-format identifier (e.g. Hdf5, NMRPipe);</span>
<span class="sd">        Automatically determined upon creating newSpectrum from a path containing spectral data.</span>
<span class="sd">        (change at your own peril!)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dataStore</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;dataStore not defined&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dataStore</span><span class="o">.</span><span class="n">dataFormat</span>

    <span class="nd">@dataFormat</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">dataFormat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_openFile</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">filePath</span><span class="p">,</span> <span class="n">dataFormat</span><span class="o">=</span><span class="n">value</span><span class="p">,</span> <span class="n">checkParameters</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_openFile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span> <span class="n">dataFormat</span><span class="p">,</span> <span class="n">checkParameters</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Open the spectrum as defined by path, creating a dataSource object</span>
<span class="sd">        :param path: a path to the spectrum; may contain redirections (e.g. $DATA)</span>
<span class="sd">        :param dataFormat: a dataFormat defined by one of the SpectrumDataSource types</span>

<span class="sd">        CCPNMRINTERNAL: also used in nef loader</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Undefined path&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_close</span><span class="p">()</span>
        <span class="n">newDataStore</span> <span class="o">=</span> <span class="n">DataStore</span><span class="o">.</span><span class="n">newFromPath</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="n">path</span><span class="p">,</span> <span class="n">dataFormat</span><span class="o">=</span><span class="n">dataFormat</span><span class="p">)</span>
        <span class="n">newDataStore</span><span class="o">.</span><span class="n">spectrum</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_spectrumTraits</span><span class="o">.</span><span class="n">dataStore</span> <span class="o">=</span> <span class="n">newDataStore</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dataStore</span><span class="o">.</span><span class="n">_saveInternal</span><span class="p">()</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">newDataSource</span> <span class="o">:=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getDataSource</span><span class="p">(</span><span class="n">dataStore</span><span class="o">=</span><span class="n">newDataStore</span><span class="p">,</span> <span class="n">checkParameters</span><span class="o">=</span><span class="n">checkParameters</span><span class="p">))</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Spectrum._openFile: unable to open &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="n">path</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># we defined a new file</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_spectrumTraits</span><span class="o">.</span><span class="n">dataSource</span> <span class="o">=</span> <span class="n">newDataSource</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_saveSpectrumMetaData</span><span class="p">()</span>

<div class="viewcode-block" id="Spectrum.reload"><a class="viewcode-back" href="../../../ccpn/ccpn.core.html#ccpn.core.Spectrum.Spectrum.reload">[docs]</a>    <span class="nd">@logCommand</span><span class="p">(</span><span class="n">get</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">reload</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span><span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reload the spectrum as defined by path;</span>
<span class="sd">        DataFormat and dimensionality need to match with the current Spectrum instance.</span>
<span class="sd">        All other parameters will be pulled from the (binary) spectrum data.</span>

<span class="sd">        :param path: a path to the spectrum; may contain redirections (e.g. $DATA)</span>
<span class="sd">                     defaults to self.filePath.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filePath</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_close</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_openFile</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="n">path</span><span class="p">,</span> <span class="n">dataFormat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dataFormat</span><span class="p">,</span> <span class="n">checkParameters</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataSource</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dataSource</span><span class="o">.</span><span class="n">exportToSpectrum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">includePath</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">path</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Path</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;return a Path instance defining the absolute, decoded path of filePath</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dataStore</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;dataStore not defined&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dataStore</span><span class="o">.</span><span class="n">aPath</span><span class="p">()</span>

<div class="viewcode-block" id="Spectrum.hasValidPath"><a class="viewcode-back" href="../../../ccpn/ccpn.core.html#ccpn.core.Spectrum.Spectrum.hasValidPath">[docs]</a>    <span class="k">def</span> <span class="nf">hasValidPath</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return true if the spectrum&#39;s dataSource currently defines an valid dataSource object</span>
<span class="sd">        with a valid path defined</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataSource</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataSource</span><span class="o">.</span><span class="n">hasValidPath</span><span class="p">()</span></div>

<div class="viewcode-block" id="Spectrum.isEmptySpectrum"><a class="viewcode-back" href="../../../ccpn/ccpn.core.html#ccpn.core.Spectrum.Spectrum.isEmptySpectrum">[docs]</a>    <span class="k">def</span> <span class="nf">isEmptySpectrum</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return True if instance refers to an empty spectrum; i.e. as in without actual spectral data&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dataStore</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;dataStore not defined&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dataStore</span><span class="o">.</span><span class="n">dataFormat</span> <span class="o">==</span> <span class="n">EmptySpectrumDataSource</span><span class="o">.</span><span class="n">dataFormat</span></div>

    <span class="c1">#-----------------------------------------------------------------------------------------</span>
    <span class="c1"># Dimensional Attributes</span>
    <span class="c1">#-----------------------------------------------------------------------------------------</span>

    <span class="k">def</span> <span class="nf">_setDimensionalAttributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attributeName</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot;Conveniance function set the spectrumReference.attributeName to the items of value</span>
<span class="sd">        Assumes all checks have been done</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">specDims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrumDimensions</span>  <span class="c1"># local copy to avoid getting it N-times</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">specDims</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">attributeName</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_getDimensionalAttributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attributeName</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Conveniance function get the values for each spectrumReference.attributeName</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">specDims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrumDimensions</span>  <span class="c1"># local copy to avoid getting it N-times</span>
        <span class="k">return</span> <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="n">specDim</span><span class="p">,</span> <span class="n">attributeName</span><span class="p">)</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">specDim</span><span class="p">,</span> <span class="n">attributeName</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">specDim</span> <span class="ow">in</span> <span class="n">specDims</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="nd">@_includeInDimensionalCopy</span>
    <span class="k">def</span> <span class="nf">pointCounts</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Number of points per dimension&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getDimensionalAttributes</span><span class="p">(</span><span class="s1">&#39;pointCount&#39;</span><span class="p">)</span>

    <span class="nd">@pointCounts</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@checkSpectrumPropertyValue</span><span class="p">(</span><span class="n">iterable</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">types</span><span class="o">=</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span>
    <span class="k">def</span> <span class="nf">pointCounts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setDimensionalAttributes</span><span class="p">(</span><span class="s1">&#39;pointCount&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="c1"># @property</span>
    <span class="c1"># def totalPointCounts(self) -&gt; List[int]:</span>
    <span class="c1">#     &quot;&quot;&quot;Total number of points per dimension; i.e. twice pointCounts in case of complex data&quot;&quot;&quot;</span>
    <span class="c1">#     result = self.pointCounts</span>
    <span class="c1">#     for axis, isC in enumerate(self.isComplex):</span>
    <span class="c1">#         if isC:</span>
    <span class="c1">#             result[axis] *= 2</span>
    <span class="c1">#     return result</span>

    <span class="nd">@property</span>
    <span class="nd">@_includeInDimensionalCopy</span>
    <span class="k">def</span> <span class="nf">isComplex</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">bool</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Boolean denoting Complex data per dimension&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getDimensionalAttributes</span><span class="p">(</span><span class="s1">&#39;isComplex&#39;</span><span class="p">)</span>

    <span class="nd">@isComplex</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@checkSpectrumPropertyValue</span><span class="p">(</span><span class="n">iterable</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">types</span><span class="o">=</span><span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span>
    <span class="k">def</span> <span class="nf">isComplex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setDimensionalAttributes</span><span class="p">(</span><span class="s1">&#39;isComplex&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="nd">@_includeInDimensionalCopy</span>
    <span class="k">def</span> <span class="nf">isAcquisition</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">bool</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Boolean per dimension denoting if it is the acquisition dimension&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getDimensionalAttributes</span><span class="p">(</span><span class="s1">&#39;isAcquisition&#39;</span><span class="p">)</span>

    <span class="nd">@isAcquisition</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@checkSpectrumPropertyValue</span><span class="p">(</span><span class="n">iterable</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">types</span><span class="o">=</span><span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span>
    <span class="k">def</span> <span class="nf">isAcquisition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">):</span>
        <span class="n">trues</span> <span class="o">=</span> <span class="p">[</span><span class="n">val</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">value</span> <span class="k">if</span> <span class="n">val</span> <span class="o">==</span> <span class="kc">True</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">trues</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Spectrum.isAcquisition: expected zero or one dimension; got </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setDimensionalAttributes</span><span class="p">(</span><span class="s1">&#39;isAcquisition&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="nd">@_includeInDimensionalCopy</span>
    <span class="k">def</span> <span class="nf">axisCodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;List of an unique axisCode per dimension&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getDimensionalAttributes</span><span class="p">(</span><span class="s1">&#39;axisCode&#39;</span><span class="p">)</span>

    <span class="nd">@axisCodes</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@checkSpectrumPropertyValue</span><span class="p">(</span><span class="n">iterable</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allowNone</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">types</span><span class="o">=</span><span class="p">(</span><span class="nb">str</span><span class="p">,))</span>
    <span class="k">def</span> <span class="nf">axisCodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setDimensionalAttributes</span><span class="p">(</span><span class="s1">&#39;axisCode&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">acquisitionAxisCode</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Axis code of acquisition axis - None if not known&quot;&quot;&quot;</span>
        <span class="n">trues</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">isAcquisition</span><span class="p">)</span> <span class="k">if</span> <span class="n">val</span> <span class="o">==</span> <span class="kc">True</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">trues</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">trues</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">axisCodes</span><span class="p">[</span><span class="n">trues</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s1">&#39;Spectrum.acquisitionAxisCode: this should not happen; more then one dimension defined as acquisition dimension&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dimensionTypes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Dimension types (&#39;Time&#39; / &#39;Frequency&#39; / &#39;Sampled&#39;) per dimension&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getDimensionalAttributes</span><span class="p">(</span><span class="s1">&#39;dimensionType&#39;</span><span class="p">)</span>

    <span class="nd">@dimensionTypes</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@checkSpectrumPropertyValue</span><span class="p">(</span><span class="n">iterable</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allowNone</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">types</span><span class="o">=</span><span class="p">(</span><span class="nb">str</span><span class="p">,),</span> <span class="n">enumerated</span><span class="o">=</span><span class="n">specLib</span><span class="o">.</span><span class="n">DIMENSIONTYPES</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">dimensionTypes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setDimensionalAttributes</span><span class="p">(</span><span class="s1">&#39;dimensionType&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">isTimeDomains</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Conveniance: A list of booleans per dimension indicating if dimension is</span>
<span class="sd">          time domain</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[(</span><span class="n">dimType</span> <span class="o">==</span> <span class="n">specLib</span><span class="o">.</span><span class="n">DIMENSION_TIME</span><span class="p">)</span> <span class="k">for</span> <span class="n">dimType</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensionTypes</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">isSampledDomains</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Conveniance: A list of booleans per dimension indicating if dimension is</span>
<span class="sd">          sampled</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[(</span><span class="n">dimType</span> <span class="o">==</span> <span class="n">specLib</span><span class="o">.</span><span class="n">DIMENSION_SAMPLED</span><span class="p">)</span> <span class="k">for</span> <span class="n">dimType</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensionTypes</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="nd">@_includeInDimensionalCopy</span>
    <span class="k">def</span> <span class="nf">spectralWidthsHz</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;spectral width (in Hz) per dimension&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getDimensionalAttributes</span><span class="p">(</span><span class="s1">&#39;spectralWidthHz&#39;</span><span class="p">)</span>

    <span class="nd">@spectralWidthsHz</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@checkSpectrumPropertyValue</span><span class="p">(</span><span class="n">iterable</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">types</span><span class="o">=</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">))</span>
    <span class="k">def</span> <span class="nf">spectralWidthsHz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setDimensionalAttributes</span><span class="p">(</span><span class="s1">&#39;spectralWidthHz&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="nd">@_includeInDimensionalCopy</span>
    <span class="k">def</span> <span class="nf">spectralWidths</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;spectral width (in ppm) per dimension &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getDimensionalAttributes</span><span class="p">(</span><span class="s1">&#39;spectralWidth&#39;</span><span class="p">)</span>

    <span class="nd">@spectralWidths</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@checkSpectrumPropertyValue</span><span class="p">(</span><span class="n">iterable</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">types</span><span class="o">=</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">))</span>
    <span class="k">def</span> <span class="nf">spectralWidths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setDimensionalAttributes</span><span class="p">(</span><span class="s1">&#39;spectralWidth&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ppmPerPoints</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Convenience; ppm-per-point for each dimension&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getDimensionalAttributes</span><span class="p">(</span><span class="s1">&#39;ppmPerPoint&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_valuePerPoints</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;For backward compatibility; _valuePerPoint for each dimension</span>
<span class="sd">        CCPNINTERNAL: used by Peak.pointLineWidths</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getDimensionalAttributes</span><span class="p">(</span><span class="s1">&#39;_valuePerPoint&#39;</span><span class="p">)</span>

    <span class="c1"># @property</span>
    <span class="c1"># def valuesPerPoint(self) -&gt; List[Optional[float]]:</span>
    <span class="c1">#     &quot;&quot;&quot;valuePerPoint for each dimension:</span>
    <span class="c1">#     in ppm for Frequency dimensions</span>
    <span class="c1">#     in time units (seconds) for Time (Fid) dimensions</span>
    <span class="c1">#     1.0 for sampled dimensions</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     result = []</span>
    <span class="c1">#     _widths = self.spectralWidths</span>
    <span class="c1">#     _widthsHz = self.spectralWidthsHz</span>
    <span class="c1">#     _pCounts = self.pointCounts</span>
    <span class="c1">#     _isComplex = self.isComplex</span>
    <span class="c1">#     for axis, dimType in enumerate(self.dimensionTypes):</span>
    <span class="c1">#</span>
    <span class="c1">#         if dimType == specLib.DIMENSION_FREQUENCY:</span>
    <span class="c1">#             valuePerPoint = _widths[axis] / _pCounts[axis]</span>
    <span class="c1">#</span>
    <span class="c1">#         elif dimType == specLib.DIMENSION_TIME:</span>
    <span class="c1">#             # valuePerPoint is dwell time</span>
    <span class="c1">#             valuePerPoint = 1.0 / _widthsHz[axis] if _isComplex[axis] \</span>
    <span class="c1">#                 else 0.5 / _widthsHz[axis]</span>
    <span class="c1">#</span>
    <span class="c1">#         elif dimType == specLib.DIMENSION_SAMPLED:</span>
    <span class="c1">#             valuePerPoint = 1.0</span>
    <span class="c1">#         else:</span>
    <span class="c1">#             valuePerPoint = None</span>
    <span class="c1">#</span>
    <span class="c1">#         result.append(valuePerPoint)</span>
    <span class="c1">#</span>
    <span class="c1">#     return result</span>

    <span class="nd">@property</span>
    <span class="nd">@_includeInDimensionalCopy</span>
    <span class="k">def</span> <span class="nf">phases0</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Zero-order phase correction (or None), per dimension&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getDimensionalAttributes</span><span class="p">(</span><span class="s1">&#39;phase0&#39;</span><span class="p">)</span>

    <span class="nd">@phases0</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@checkSpectrumPropertyValue</span><span class="p">(</span><span class="n">iterable</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allowNone</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">types</span><span class="o">=</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">))</span>
    <span class="k">def</span> <span class="nf">phases0</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setDimensionalAttributes</span><span class="p">(</span><span class="s1">&#39;phase0&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="nd">@_includeInDimensionalCopy</span>
    <span class="k">def</span> <span class="nf">phases1</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;First-order phase correction (or None) per dimension&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getDimensionalAttributes</span><span class="p">(</span><span class="s1">&#39;phase1&#39;</span><span class="p">)</span>

    <span class="nd">@phases1</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@checkSpectrumPropertyValue</span><span class="p">(</span><span class="n">iterable</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allowNone</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">types</span><span class="o">=</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">))</span>
    <span class="k">def</span> <span class="nf">phases1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setDimensionalAttributes</span><span class="p">(</span><span class="s1">&#39;phase1&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="nd">@_includeInDimensionalCopy</span>
    <span class="k">def</span> <span class="nf">windowFunctions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Window function name (or None); per dimension</span>
<span class="sd">        e.g. &#39;EM&#39;, &#39;GM&#39;, &#39;SINE&#39;, &#39;QSINE&#39;, .... (defined in SpectrumLib.WINDOW_FUNCTIONS)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getDimensionalAttributes</span><span class="p">(</span><span class="s1">&#39;windowFunction&#39;</span><span class="p">)</span>

    <span class="nd">@windowFunctions</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@checkSpectrumPropertyValue</span><span class="p">(</span><span class="n">iterable</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allowNone</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">types</span><span class="o">=</span><span class="p">(</span><span class="nb">str</span><span class="p">,),</span> <span class="n">enumerated</span><span class="o">=</span><span class="n">specLib</span><span class="o">.</span><span class="n">WINDOW_FUNCTIONS</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">windowFunctions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setDimensionalAttributes</span><span class="p">(</span><span class="s1">&#39;windowFunction&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="nd">@_includeInDimensionalCopy</span>
    <span class="k">def</span> <span class="nf">lorentzianBroadenings</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Lorenzian broadening (in Hz) or None; per dimension&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getDimensionalAttributes</span><span class="p">(</span><span class="s1">&#39;lorentzianBroadening&#39;</span><span class="p">)</span>

    <span class="nd">@lorentzianBroadenings</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@checkSpectrumPropertyValue</span><span class="p">(</span><span class="n">iterable</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allowNone</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">types</span><span class="o">=</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">))</span>
    <span class="k">def</span> <span class="nf">lorentzianBroadenings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setDimensionalAttributes</span><span class="p">(</span><span class="s1">&#39;lorentzianBroadening&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="nd">@_includeInDimensionalCopy</span>
    <span class="k">def</span> <span class="nf">gaussianBroadenings</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Gaussian broadening or None; per dimension&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getDimensionalAttributes</span><span class="p">(</span><span class="s1">&#39;gaussianBroadening&#39;</span><span class="p">)</span>

    <span class="nd">@gaussianBroadenings</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@checkSpectrumPropertyValue</span><span class="p">(</span><span class="n">iterable</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allowNone</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">types</span><span class="o">=</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">))</span>
    <span class="k">def</span> <span class="nf">gaussianBroadenings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setDimensionalAttributes</span><span class="p">(</span><span class="s1">&#39;gaussianBroadening&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="nd">@_includeInDimensionalCopy</span>
    <span class="k">def</span> <span class="nf">sineWindowShifts</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Shift of sine/sine-square window function (in degrees) or None; per dimension&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getDimensionalAttributes</span><span class="p">(</span><span class="s1">&#39;sineWindowShift&#39;</span><span class="p">)</span>

    <span class="nd">@sineWindowShifts</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@checkSpectrumPropertyValue</span><span class="p">(</span><span class="n">iterable</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allowNone</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">types</span><span class="o">=</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">))</span>
    <span class="k">def</span> <span class="nf">sineWindowShifts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setDimensionalAttributes</span><span class="p">(</span><span class="s1">&#39;sineWindowShift&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="nd">@_includeInDimensionalCopy</span>
    <span class="k">def</span> <span class="nf">spectrometerFrequencies</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Spectrometer frequency; per dimension&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getDimensionalAttributes</span><span class="p">(</span><span class="s1">&#39;spectrometerFrequency&#39;</span><span class="p">)</span>

    <span class="nd">@spectrometerFrequencies</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@checkSpectrumPropertyValue</span><span class="p">(</span><span class="n">iterable</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">types</span><span class="o">=</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">))</span>
    <span class="k">def</span> <span class="nf">spectrometerFrequencies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setDimensionalAttributes</span><span class="p">(</span><span class="s1">&#39;spectrometerFrequency&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="nd">@_includeInDimensionalCopy</span>
    <span class="k">def</span> <span class="nf">measurementTypes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Type of value being measured, per dimension.</span>
<span class="sd">        In normal cases the measurementType will be &#39;Shift&#39;, but other values might be</span>
<span class="sd">        &#39;MQSHift&#39; (for multiple quantum axes), JCoupling (for J-resolved experiments),</span>
<span class="sd">        &#39;T1&#39;, &#39;T2&#39;, --- defined SpectrumLib.MEASUREMENT_TYPES</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getDimensionalAttributes</span><span class="p">(</span><span class="s1">&#39;measurementType&#39;</span><span class="p">)</span>

    <span class="nd">@measurementTypes</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@checkSpectrumPropertyValue</span><span class="p">(</span><span class="n">iterable</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">types</span><span class="o">=</span><span class="p">(</span><span class="nb">str</span><span class="p">,),</span> <span class="n">enumerated</span><span class="o">=</span><span class="n">specLib</span><span class="o">.</span><span class="n">MEASUREMENT_TYPES</span><span class="p">,</span>
                                <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;shift&#39;</span><span class="p">:</span> <span class="s1">&#39;Shift&#39;</span><span class="p">},</span> <span class="n">allowNone</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">measurementTypes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setDimensionalAttributes</span><span class="p">(</span><span class="s1">&#39;measurementType&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="nd">@_includeInDimensionalCopy</span>
    <span class="k">def</span> <span class="nf">isotopeCodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;isotopeCode or None; per dimension&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getDimensionalAttributes</span><span class="p">(</span><span class="s1">&#39;isotopeCode&#39;</span><span class="p">)</span>

    <span class="nd">@isotopeCodes</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@logCommand</span><span class="p">(</span><span class="n">get</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">,</span> <span class="n">isProperty</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nd">@checkSpectrumPropertyValue</span><span class="p">(</span><span class="n">iterable</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allowNone</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">types</span><span class="o">=</span><span class="p">(</span><span class="nb">str</span><span class="p">,))</span>
    <span class="k">def</span> <span class="nf">isotopeCodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setDimensionalAttributes</span><span class="p">(</span><span class="s1">&#39;isotopeCode&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="nd">@_includeInDimensionalCopy</span>
    <span class="k">def</span> <span class="nf">mqIsotopeCodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;multiple quantum isotopeCodes or [None, ...]; per dimension&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getDimensionalAttributes</span><span class="p">(</span><span class="s1">&#39;mqIsotopeCodes&#39;</span><span class="p">)</span>

    <span class="nd">@mqIsotopeCodes</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@logCommand</span><span class="p">(</span><span class="n">get</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">,</span> <span class="n">isProperty</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nd">@checkSpectrumPropertyValue</span><span class="p">(</span><span class="n">iterable</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allowNone</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">types</span><span class="o">=</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,))</span>
    <span class="k">def</span> <span class="nf">mqIsotopeCodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setDimensionalAttributes</span><span class="p">(</span><span class="s1">&#39;mqIsotopeCodes&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="nd">@_includeInDimensionalCopy</span>
    <span class="k">def</span> <span class="nf">coherenceOrders</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;multiple-quantum coherence orders or [None, ...]; per dimension&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getDimensionalAttributes</span><span class="p">(</span><span class="s1">&#39;coherenceOrder&#39;</span><span class="p">)</span>

    <span class="nd">@coherenceOrders</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@logCommand</span><span class="p">(</span><span class="n">get</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">,</span> <span class="n">isProperty</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nd">@checkSpectrumPropertyValue</span><span class="p">(</span><span class="n">iterable</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allowNone</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">types</span><span class="o">=</span><span class="p">(</span><span class="nb">str</span><span class="p">,))</span>
    <span class="k">def</span> <span class="nf">coherenceOrders</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setDimensionalAttributes</span><span class="p">(</span><span class="s1">&#39;coherenceOrder&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="nd">@_includeInDimensionalCopy</span>
    <span class="k">def</span> <span class="nf">referenceExperimentDimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="o">...</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;dimensions of reference experiment - None if no code&quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">dataDim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">sortedDataDims</span><span class="p">():</span>
            <span class="n">expDim</span> <span class="o">=</span> <span class="n">dataDim</span><span class="o">.</span><span class="n">expDim</span>
            <span class="k">if</span> <span class="n">expDim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">referenceExperimentDimension</span> <span class="o">=</span> <span class="p">(</span><span class="n">expDim</span><span class="o">.</span><span class="n">ccpnInternalData</span> <span class="ow">and</span> <span class="n">expDim</span><span class="o">.</span><span class="n">ccpnInternalData</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;expDimToRefExpDim&#39;</span><span class="p">))</span> <span class="ow">or</span> <span class="kc">None</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">referenceExperimentDimension</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="nd">@referenceExperimentDimensions</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@logCommand</span><span class="p">(</span><span class="n">get</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">,</span> <span class="n">isProperty</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nd">@ccpNmrV3CoreSetter</span><span class="p">()</span>
    <span class="nd">@checkSpectrumPropertyValue</span><span class="p">(</span><span class="n">iterable</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allowNone</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">types</span><span class="o">=</span><span class="p">(</span><span class="nb">str</span><span class="p">,))</span>
    <span class="k">def</span> <span class="nf">referenceExperimentDimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">):</span>
        <span class="n">apiDataSource</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span>

        <span class="c1"># if not isinstance(values, (tuple, list)):</span>
        <span class="c1">#     raise ValueError(&#39;referenceExperimentDimensions must be a list or tuple&#39;)</span>
        <span class="c1"># if len(values) != apiDataSource.numDim:</span>
        <span class="c1">#     raise ValueError(&#39;referenceExperimentDimensions must have length %s, was %s&#39; % (apiDataSource.numDim, values))</span>
        <span class="c1"># if not all(isinstance(dimVal, (str, type(None))) for dimVal in values):</span>
        <span class="c1">#     raise ValueError(&#39;referenceExperimentDimensions must be str, None&#39;)</span>

        <span class="c1"># _vals = [val for val in values if val is not None]</span>
        <span class="c1"># if len(_vals) != len(set(_vals)):</span>
        <span class="c1">#     raise ValueError(&#39;referenceExperimentDimensions must be unique&#39;)</span>

        <span class="c1">#TODO: use self.spectrumDimensions and its attributes/methods (if needed add method)</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="p">(</span><span class="n">dataDim</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">apiDataSource</span><span class="o">.</span><span class="n">sortedDataDims</span><span class="p">(),</span> <span class="n">values</span><span class="p">)):</span>
            <span class="n">expDim</span> <span class="o">=</span> <span class="n">dataDim</span><span class="o">.</span><span class="n">expDim</span>
            <span class="k">if</span> <span class="n">expDim</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot set referenceExperimentDimension </span><span class="si">%s</span><span class="s1"> in dimension </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">ii</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_update</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;expDimToRefExpDim&#39;</span><span class="p">:</span> <span class="n">val</span><span class="p">}</span>
                <span class="n">_ccpnInt</span> <span class="o">=</span> <span class="n">expDim</span><span class="o">.</span><span class="n">ccpnInternalData</span>
                <span class="k">if</span> <span class="n">_ccpnInt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">expDim</span><span class="o">.</span><span class="n">ccpnInternalData</span> <span class="o">=</span> <span class="n">_update</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">_expDimCID</span> <span class="o">=</span> <span class="n">expDim</span><span class="o">.</span><span class="n">ccpnInternalData</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="n">_ccpnInt</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">_update</span><span class="p">)</span>
                    <span class="n">expDim</span><span class="o">.</span><span class="n">ccpnInternalData</span> <span class="o">=</span> <span class="n">_ccpnInt</span>

<div class="viewcode-block" id="Spectrum.getAvailableReferenceExperimentDimensions"><a class="viewcode-back" href="../../../ccpn/ccpn.core.html#ccpn.core.Spectrum.Spectrum.getAvailableReferenceExperimentDimensions">[docs]</a>    <span class="k">def</span> <span class="nf">getAvailableReferenceExperimentDimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_experimentType</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return list of available reference experiment dimensions based on spectrum isotopeCodes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_refExperiment</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">_experimentType</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># search for the named reference experiment</span>
            <span class="n">_refExperiment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">project</span><span class="o">.</span><span class="n">_getReferenceExperimentFromType</span><span class="p">(</span><span class="n">_experimentType</span><span class="p">)</span>

        <span class="c1"># get the nucleus codes from the current isotope codes</span>
        <span class="n">nCodes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;0123456789&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">isotopeCodes</span><span class="p">)</span>

        <span class="c1"># match against the current reference experiment or passed in value</span>
        <span class="n">apiExperiment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">experiment</span>
        <span class="n">apiRefExperiment</span> <span class="o">=</span> <span class="n">_refExperiment</span> <span class="ow">or</span> <span class="n">apiExperiment</span><span class="o">.</span><span class="n">refExperiment</span>

        <span class="k">if</span> <span class="n">apiRefExperiment</span><span class="p">:</span>
            <span class="c1"># get the permutations of the axisCodes and nucleusCodes</span>
            <span class="n">axisCodePerms</span> <span class="o">=</span> <span class="n">permutations</span><span class="p">(</span><span class="n">apiRefExperiment</span><span class="o">.</span><span class="n">axisCodes</span><span class="p">)</span>
            <span class="n">nucleusPerms</span> <span class="o">=</span> <span class="n">permutations</span><span class="p">(</span><span class="n">apiRefExperiment</span><span class="o">.</span><span class="n">nucleusCodes</span><span class="p">)</span>

            <span class="c1"># return only those that match the current nucleusCodes (from isotopeCodes)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ac</span> <span class="k">for</span> <span class="n">ac</span><span class="p">,</span> <span class="n">nc</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">axisCodePerms</span><span class="p">,</span> <span class="n">nucleusPerms</span><span class="p">)</span> <span class="k">if</span> <span class="n">nCodes</span> <span class="o">==</span> <span class="n">nc</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">()</span></div>

    <span class="nd">@property</span>
    <span class="nd">@_includeInDimensionalCopy</span>
    <span class="k">def</span> <span class="nf">foldingModes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;List of folding modes (values: &#39;circular&#39;, &#39;mirror&#39;, None); per dimension&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getDimensionalAttributes</span><span class="p">(</span><span class="s1">&#39;foldingMode&#39;</span><span class="p">)</span>
        <span class="c1"># dd = {True: &#39;mirror&#39;, False: &#39;circular&#39;, None: None}</span>
        <span class="c1"># return tuple(dd[x and x.isFolded] for x in self._mainExpDimRefs())</span>

    <span class="nd">@foldingModes</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@logCommand</span><span class="p">(</span><span class="n">get</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">,</span> <span class="n">isProperty</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nd">@checkSpectrumPropertyValue</span><span class="p">(</span><span class="n">iterable</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allowNone</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">types</span><span class="o">=</span><span class="p">(</span><span class="nb">str</span><span class="p">,),</span> <span class="n">enumerated</span><span class="o">=</span><span class="n">specLib</span><span class="o">.</span><span class="n">FOLDING_MODES</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">foldingModes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setDimensionalAttributes</span><span class="p">(</span><span class="s1">&#39;foldingMode&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

        <span class="c1"># dd = {&#39;circular&#39;: False, &#39;mirror&#39;: True, None: False}</span>
        <span class="c1">#</span>
        <span class="c1"># if len(values) != self.dimensionCount:</span>
        <span class="c1">#     raise ValueError(&quot;Length of %s does not match number of dimensions.&quot; % str(values))</span>
        <span class="c1"># if not all(isinstance(dimVal, (str, type(None))) and dimVal in dd.keys() for dimVal in values):</span>
        <span class="c1">#     raise ValueError(&quot;Folding modes must be &#39;circular&#39;, &#39;mirror&#39;, None&quot;)</span>
        <span class="c1">#</span>
        <span class="c1"># self._setExpDimRefAttribute(&#39;isFolded&#39;, [dd[x] for x in values])</span>

    <span class="nd">@property</span>
    <span class="nd">@_includeInDimensionalCopy</span>
    <span class="k">def</span> <span class="nf">axisUnits</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;List of axis units (most commonly &#39;ppm&#39;) or None; per dimension&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getDimensionalAttributes</span><span class="p">(</span><span class="s1">&#39;axisUnit&#39;</span><span class="p">)</span>

    <span class="nd">@axisUnits</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@checkSpectrumPropertyValue</span><span class="p">(</span><span class="n">iterable</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allowNone</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">types</span><span class="o">=</span><span class="p">(</span><span class="nb">str</span><span class="p">,))</span>
    <span class="k">def</span> <span class="nf">axisUnits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setDimensionalAttributes</span><span class="p">(</span><span class="s1">&#39;axisUnit&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="nd">@_includeInDimensionalCopy</span>
    <span class="k">def</span> <span class="nf">referencePoints</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;List of points used for axis (chemical shift) referencing; per dimension.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getDimensionalAttributes</span><span class="p">(</span><span class="s1">&#39;referencePoint&#39;</span><span class="p">)</span>

    <span class="nd">@referencePoints</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@checkSpectrumPropertyValue</span><span class="p">(</span><span class="n">iterable</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allowNone</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">types</span><span class="o">=</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">))</span>
    <span class="k">def</span> <span class="nf">referencePoints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setDimensionalAttributes</span><span class="p">(</span><span class="s1">&#39;referencePoint&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="nd">@_includeInDimensionalCopy</span>
    <span class="k">def</span> <span class="nf">referenceValues</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;List of ppm-values used for axis (chemical shift) referencing; per dimension.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getDimensionalAttributes</span><span class="p">(</span><span class="s1">&#39;referenceValue&#39;</span><span class="p">)</span>

    <span class="nd">@referenceValues</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@checkSpectrumPropertyValue</span><span class="p">(</span><span class="n">iterable</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allowNone</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">types</span><span class="o">=</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">))</span>
    <span class="nd">@ccpNmrV3CoreSetter</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">referenceValues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setDimensionalAttributes</span><span class="p">(</span><span class="s1">&#39;referenceValue&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="c1"># @cached(_REFERENCESUBSTANCESCACHE, maxItems=5000, debug=False)</span>
    <span class="k">def</span> <span class="nf">referenceSubstances</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: a list of substances</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getInternalParameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_REFERENCESUBSTANCES</span><span class="p">)</span> <span class="ow">or</span> <span class="p">[]</span>
        <span class="n">objs</span> <span class="o">=</span> <span class="n">_getObjectsByPids</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">project</span><span class="p">,</span> <span class="n">pids</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">objs</span>

    <span class="nd">@referenceSubstances</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">referenceSubstances</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">substances</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">ccpn.core.Substance</span> <span class="kn">import</span> <span class="n">Substance</span>

        <span class="n">pids</span> <span class="o">=</span> <span class="p">[</span><span class="n">su</span><span class="o">.</span><span class="n">pid</span> <span class="k">for</span> <span class="n">su</span> <span class="ow">in</span> <span class="n">substances</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">su</span><span class="p">,</span> <span class="n">Substance</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setInternalParameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_REFERENCESUBSTANCES</span><span class="p">,</span> <span class="n">pids</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">referenceSubstance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Deprecated. See referenceSubstances</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;spectrum.referenceSubstance is deprecated. Use referenceSubstances instead. &#39;</span><span class="p">)</span>
        <span class="n">substance</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">referenceSubstances</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">substance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">referenceSubstances</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">substance</span>

    <span class="nd">@referenceSubstance</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">referenceSubstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">substance</span><span class="p">):</span>
        <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;spectrum.referenceSubstance is deprecated. Use referenceSubstances instead. &#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">referenceSubstances</span> <span class="o">=</span> <span class="p">[</span><span class="n">substance</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="nd">@_includeInDimensionalCopy</span>
    <span class="k">def</span> <span class="nf">assignmentTolerances</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Assignment tolerance in axis unit (ppm); per dimension;</span>
<span class="sd">        set to default value on basis of isotopeCode</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getDimensionalAttributes</span><span class="p">(</span><span class="s1">&#39;assignmentTolerance&#39;</span><span class="p">)</span>

    <span class="nd">@assignmentTolerances</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@checkSpectrumPropertyValue</span><span class="p">(</span><span class="n">iterable</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allowNone</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">types</span><span class="o">=</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">))</span>
    <span class="k">def</span> <span class="nf">assignmentTolerances</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setDimensionalAttributes</span><span class="p">(</span><span class="s1">&#39;assignmentTolerance&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="c1"># @property</span>
    <span class="c1"># def defaultAssignmentTolerances(self) -&gt; List[Optional[float]]:</span>
    <span class="c1">#     &quot;&quot;&quot;Default assignment tolerances per dimension (in ppm), upward adjusted (if needed) for</span>
    <span class="c1">#     digital resolution.</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     return self._getDimensionalAttributes(&#39;defaultAssignmentTolerance&#39;)</span>

    <span class="nd">@property</span>
    <span class="nd">@_includeInDimensionalCopy</span>
    <span class="k">def</span> <span class="nf">aliasingLimits</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;List of tuples of sorted(minAliasingLimit, maxAliasingLimit) per dimension.</span>
<span class="sd">        Setting these values will round them to the nearest multiple of the spectralWidth.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getDimensionalAttributes</span><span class="p">(</span><span class="s1">&#39;aliasingLimits&#39;</span><span class="p">)</span>

    <span class="nd">@aliasingLimits</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@logCommand</span><span class="p">(</span><span class="n">get</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">,</span> <span class="n">isProperty</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nd">@checkSpectrumPropertyValue</span><span class="p">(</span><span class="n">iterable</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allowNone</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">types</span><span class="o">=</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">))</span>
    <span class="k">def</span> <span class="nf">aliasingLimits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setDimensionalAttributes</span><span class="p">(</span><span class="s1">&#39;aliasingLimits&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">aliasingPointLimits</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span><span class="nb">int</span><span class="p">],</span> <span class="o">...</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return a tuple of sorted(minAliasingPointLimit, maxAliasingPointLimit) per dimension.</span>
<span class="sd">        i.e. The actual point limits of the full (including the aliased regions) limits.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getDimensionalAttributes</span><span class="p">(</span><span class="s1">&#39;aliasingPointLimits&#39;</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">aliasingIndexes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span><span class="nb">int</span><span class="p">],</span> <span class="o">...</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return a tuple of the number of times the spectralWidth are folded in each dimension.</span>
<span class="sd">        This is a derived property from the aliasingLimits; setting aliasingIndexes value will alter</span>
<span class="sd">        the aliasingLimits parameter accordingly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getDimensionalAttributes</span><span class="p">(</span><span class="s1">&#39;aliasingIndexes&#39;</span><span class="p">))</span>

    <span class="nd">@aliasingIndexes</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@checkSpectrumPropertyValue</span><span class="p">(</span><span class="n">iterable</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allowNone</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">types</span><span class="o">=</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">))</span>
    <span class="k">def</span> <span class="nf">aliasingIndexes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setDimensionalAttributes</span><span class="p">(</span><span class="s1">&#39;aliasingIndexes&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="c1"># GWV, plural of index is indices</span>
    <span class="n">aliasingIndices</span> <span class="o">=</span> <span class="n">aliasingIndexes</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spectrumLimits</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;list of tuples of (ppmPoint(1), ppmPoint(n)) for each dimension</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getDimensionalAttributes</span><span class="p">(</span><span class="s1">&#39;spectrumLimits&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">foldingLimits</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;list of tuples of (ppmPoint(0.5), ppmPoint(n+0.5)) for each dimension</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getDimensionalAttributes</span><span class="p">(</span><span class="s1">&#39;foldingLimits&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="Spectrum.get1Dlimits"><a class="viewcode-back" href="../../../ccpn/ccpn.core.html#ccpn.core.Spectrum.Spectrum.get1Dlimits">[docs]</a>    <span class="k">def</span> <span class="nf">get1Dlimits</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the 1D spectrum ppm-limits and the intensity limits</span>
<span class="sd">        :return ((ppm1, ppm2), (minValue, maxValue)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensionCount</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Spectrum.get1Dlimits() is only implemented for 1D spectra&#39;</span><span class="p">)</span>
        <span class="n">ppmLimits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrumLimits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">sliceData</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getSliceData</span><span class="p">()</span>
        <span class="n">minValue</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">sliceData</span><span class="p">))</span>
        <span class="n">maxValue</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">sliceData</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">ppmLimits</span><span class="p">,</span> <span class="p">(</span><span class="n">minValue</span><span class="p">,</span> <span class="n">maxValue</span><span class="p">))</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">axesReversed</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="o">...</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return True if the axis is reversed per dimension</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_getDimensionalAttributes</span><span class="p">(</span><span class="s1">&#39;isReversed&#39;</span><span class="p">))</span>

    <span class="nd">@axesReversed</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@ccpNmrV3CoreSetter</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">axesReversed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setDimensionalAttributes</span><span class="p">(</span><span class="s1">&#39;isReversed&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">magnetisationTransfers</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">MagnetisationTransferTuple</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;tuple of MagnetisationTransferTuple describing magnetisation transfer between</span>
<span class="sd">        the spectrum dimensions.</span>

<span class="sd">        MagnetisationTransferTuple is a namedtuple with the fields</span>
<span class="sd">        [&#39;dimension1&#39;, &#39;dimension2&#39;, &#39;transferType&#39;, &#39;isIndirect&#39;] of types [int, int, str, bool]</span>
<span class="sd">        The dimensions are dimension numbers (one-origin]</span>
<span class="sd">        transfertype is one of (in order of increasing priority):</span>
<span class="sd">        &#39;onebond&#39;, &#39;Jcoupling&#39;, &#39;Jmultibond&#39;, &#39;relayed&#39;, &#39;relayed-alternate&#39;, &#39;through-space&#39;</span>
<span class="sd">        isIndirect is used where there is more than one successive transfer step;</span>
<span class="sd">        it is combined with the highest-priority transferType in the transfer path.</span>

<span class="sd">        The magnetisationTransfers are deduced from the experimentType and axisCodes.</span>
<span class="sd">        Only when the experimentType is unset or does not match any known reference experiment</span>
<span class="sd">        magnetisationTransfers are kept separately in the API layer.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">apiExperiment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">experiment</span>
        <span class="n">apiRefExperiment</span> <span class="o">=</span> <span class="n">apiExperiment</span><span class="o">.</span><span class="n">refExperiment</span>

        <span class="k">if</span> <span class="n">apiRefExperiment</span><span class="p">:</span>
            <span class="c1"># We should use the refExperiment - if present</span>
            <span class="n">magnetisationTransferDict</span> <span class="o">=</span> <span class="n">apiRefExperiment</span><span class="o">.</span><span class="n">magnetisationTransferDict</span><span class="p">()</span>
            <span class="n">mainExpDimRefs</span> <span class="o">=</span> <span class="p">[</span><span class="n">dim</span><span class="o">.</span><span class="n">_expDimRef</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrumReferences</span><span class="p">]</span>
            <span class="n">refExpDimRefs</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">x</span><span class="o">.</span><span class="n">refExpDimRef</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">mainExpDimRefs</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">rxdr</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">refExpDimRefs</span><span class="p">):</span>
                <span class="n">dim1</span> <span class="o">=</span> <span class="n">ii</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">rxdr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">refExpDimRefs</span><span class="p">)):</span>
                        <span class="n">rxdr2</span> <span class="o">=</span> <span class="n">refExpDimRefs</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">rxdr2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">tt</span> <span class="o">=</span> <span class="n">magnetisationTransferDict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">frozenset</span><span class="p">((</span><span class="n">rxdr</span><span class="p">,</span> <span class="n">rxdr2</span><span class="p">)))</span>
                            <span class="k">if</span> <span class="n">tt</span><span class="p">:</span>
                                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">MagnetisationTransferTuple</span><span class="p">(</span><span class="n">dim1</span><span class="p">,</span> <span class="n">jj</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tt</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Without a refExperiment use parameters stored in the API (for reproducibility)</span>
            <span class="n">ll</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">apiExpTransfer</span> <span class="ow">in</span> <span class="n">apiExperiment</span><span class="o">.</span><span class="n">expTransfers</span><span class="p">:</span>
                <span class="n">item</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">expDim</span><span class="o">.</span><span class="n">dim</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">apiExpTransfer</span><span class="o">.</span><span class="n">expDimRefs</span><span class="p">]</span>
                <span class="n">item</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
                <span class="n">item</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">apiExpTransfer</span><span class="o">.</span><span class="n">transferType</span><span class="p">)</span>
                <span class="n">item</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="ow">not</span> <span class="p">(</span><span class="n">apiExpTransfer</span><span class="o">.</span><span class="n">isDirect</span><span class="p">))</span>
                <span class="n">ll</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">ll</span><span class="p">):</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">MagnetisationTransferTuple</span><span class="p">(</span><span class="o">*</span><span class="n">item</span><span class="p">))</span>

        <span class="c1">#</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_setMagnetisationTransfers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">MagnetisationTransferTuple</span><span class="p">,</span> <span class="o">...</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Setter for magnetisation transfers</span>

<span class="sd">        The magnetisationTransfers are deduced from the experimentType and axisCodes.</span>
<span class="sd">        When the experimentType is set this function is a No-op.</span>
<span class="sd">        Only when the experimentType is unset or does not match any known reference experiment</span>
<span class="sd">        does this function set the magnetisation transfers, and the corresponding values are</span>
<span class="sd">        ignored if the experimentType is later set</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">apiExperiment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">experiment</span>
        <span class="n">apiRefExperiment</span> <span class="o">=</span> <span class="n">apiExperiment</span><span class="o">.</span><span class="n">refExperiment</span>
        <span class="k">if</span> <span class="n">apiRefExperiment</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">et</span> <span class="ow">in</span> <span class="n">apiExperiment</span><span class="o">.</span><span class="n">expTransfers</span><span class="p">:</span>
                <span class="n">et</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
            <span class="n">mainExpDimRefs</span> <span class="o">=</span> <span class="p">[</span><span class="n">dim</span><span class="o">.</span><span class="n">_expDimRef</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrumReferences</span><span class="p">]</span>  <span class="c1"># self._mainExpDimRefs()</span>
            <span class="k">for</span> <span class="n">tt</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">dim1</span><span class="p">,</span> <span class="n">dim2</span><span class="p">,</span> <span class="n">transferType</span><span class="p">,</span> <span class="n">isIndirect</span> <span class="o">=</span> <span class="n">tt</span>
                    <span class="n">expDimRefs</span> <span class="o">=</span> <span class="p">(</span><span class="n">mainExpDimRefs</span><span class="p">[</span><span class="n">dim1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">mainExpDimRefs</span><span class="p">[</span><span class="n">dim2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s2">&quot;Attempt to set incorrect magnetisationTransfer value </span><span class="si">%s</span><span class="s2"> in spectrum </span><span class="si">%s</span><span class="s2">&quot;</span>
                            <span class="o">%</span> <span class="p">(</span><span class="n">tt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pid</span><span class="p">)</span>
                            <span class="p">)</span>
                <span class="n">apiExperiment</span><span class="o">.</span><span class="n">newExpTransfer</span><span class="p">(</span><span class="n">expDimRefs</span><span class="o">=</span><span class="n">expDimRefs</span><span class="p">,</span> <span class="n">transferType</span><span class="o">=</span><span class="n">transferType</span><span class="p">,</span>
                                             <span class="n">isDirect</span><span class="o">=</span><span class="p">(</span><span class="ow">not</span> <span class="n">isIndirect</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="sd">&quot;&quot;&quot;An attempt to set Spectrum.magnetisationTransfers directly was ignored</span>
<span class="sd">                  because the spectrum experimentType was defined.</span>
<span class="sd">                  Use axisCodes to set magnetisation transfers instead.&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">intensities</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SliceData</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; spectral intensities as a SliceData (i.e. NumPy array) for 1D spectra</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensionCount</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Currently this method only works for 1D spectra&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">SliceData</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">pointCounts</span><span class="p">[</span><span class="mi">0</span><span class="p">],))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intensities</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Assignment is Redundant as getSliceData does that;</span>
            <span class="c1"># Nevertheless for clarity</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_intensities</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getSliceData</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intensities</span>

    <span class="nd">@intensities</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">intensities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_intensities</span> <span class="o">=</span> <span class="n">value</span>

        <span class="c1"># NOTE:ED - temporary hack for showing straight the result of intensities change</span>
        <span class="k">for</span> <span class="n">spectrumView</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrumViews</span><span class="p">:</span>
            <span class="n">spectrumView</span><span class="o">.</span><span class="n">refreshData</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">positions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; spectral region in ppm as NumPy array for 1D spectra &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensionCount</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Currently this method only works for 1D spectra&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_positions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_positions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getPpmArray</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_positions</span>

    <span class="nd">@positions</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">positions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="c1"># self._scaleChanged = True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_positions</span> <span class="o">=</span> <span class="n">value</span>

        <span class="c1"># NOTE:ED - temporary hack for showing straight the result of intensities change</span>
        <span class="k">for</span> <span class="n">spectrumView</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrumViews</span><span class="p">:</span>
            <span class="n">spectrumView</span><span class="o">.</span><span class="n">refreshData</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="nd">@_includeInCopy</span>
    <span class="k">def</span> <span class="nf">displayFoldedContours</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return whether the folded spectrum contours are to be displayed</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getInternalParameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_DISPLAYFOLDEDCONTOURS</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># default to True</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@displayFoldedContours</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">displayFoldedContours</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set whether the folded spectrum contours are to be displayed</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Spectrum.displayFoldedContours: must be True/False.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_setInternalParameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_DISPLAYFOLDEDCONTOURS</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_seriesItems</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a tuple of the series items for the spectrumGroups</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">items</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getInternalParameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_SERIESITEMS</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">items</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">series</span> <span class="o">=</span> <span class="p">()</span>
            <span class="k">for</span> <span class="n">sg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrumGroups</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">sg</span><span class="o">.</span><span class="n">pid</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
                    <span class="n">series</span> <span class="o">+=</span> <span class="p">(</span><span class="n">items</span><span class="p">[</span><span class="n">sg</span><span class="o">.</span><span class="n">pid</span><span class="p">],)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">series</span> <span class="o">+=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span>
            <span class="k">return</span> <span class="n">series</span>

    <span class="nd">@_seriesItems</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@ccpNmrV3CoreSetter</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">_seriesItems</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">items</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the series items for all spectrumGroups that spectrum is attached to.</span>
<span class="sd">        Must be of the form ( &lt;item1&gt;,</span>
<span class="sd">                              &lt;item2&gt;,</span>
<span class="sd">                              ...</span>
<span class="sd">                              &lt;itemN&gt;</span>
<span class="sd">                            )</span>
<span class="sd">            where &lt;itemsN&gt; are of the same type (or None)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">items</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;items is not defined&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">))):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;items is not of type tuple/None&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">items</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spectrumGroups</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Number of items does not match number of spectrumGroups&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">diffItems</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">items</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">diffItems</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">diffItems</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">diffItems</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Items must be of the same type (or None)&#39;</span><span class="p">)</span>

            <span class="n">seriesItems</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getInternalParameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_SERIESITEMS</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">sg</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spectrumGroups</span><span class="p">,</span> <span class="n">items</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">seriesItems</span><span class="p">:</span>
                    <span class="n">seriesItems</span><span class="p">[</span><span class="n">sg</span><span class="o">.</span><span class="n">pid</span><span class="p">]</span> <span class="o">=</span> <span class="n">item</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">seriesItems</span> <span class="o">=</span> <span class="p">{</span><span class="n">sg</span><span class="o">.</span><span class="n">pid</span><span class="p">:</span> <span class="n">item</span><span class="p">}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_setInternalParameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_SERIESITEMS</span><span class="p">,</span> <span class="n">seriesItems</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_setInternalParameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_SERIESITEMS</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_getSeriesItem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spectrumGroup</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the series item for the current spectrum for the selected spectrumGroup</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">ccpn.core.SpectrumGroup</span> <span class="kn">import</span> <span class="n">SpectrumGroup</span>

        <span class="n">spectrumGroup</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">project</span><span class="o">.</span><span class="n">getByPid</span><span class="p">(</span><span class="n">spectrumGroup</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spectrumGroup</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">spectrumGroup</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spectrumGroup</span><span class="p">,</span> <span class="n">SpectrumGroup</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> is not a spectrumGroup&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">spectrumGroup</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">spectrumGroup</span><span class="o">.</span><span class="n">spectra</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Spectrum </span><span class="si">%s</span><span class="s1"> does not belong to spectrumGroup </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">spectrumGroup</span><span class="p">)))</span>

        <span class="n">seriesItems</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getInternalParameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_SERIESITEMS</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">seriesItems</span> <span class="ow">and</span> <span class="n">spectrumGroup</span><span class="o">.</span><span class="n">pid</span> <span class="ow">in</span> <span class="n">seriesItems</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">seriesItems</span><span class="p">[</span><span class="n">spectrumGroup</span><span class="o">.</span><span class="n">pid</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_setSeriesItem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spectrumGroup</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the series item for the current spectrum for the selected spectrumGroup</span>
<span class="sd">        MUST be called from spectrumGroup - error checking for item types is handled there</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">ccpn.core.SpectrumGroup</span> <span class="kn">import</span> <span class="n">SpectrumGroup</span>

        <span class="c1"># check that the spectrumGroup and spectrum are valid</span>
        <span class="n">spectrumGroup</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">project</span><span class="o">.</span><span class="n">getByPid</span><span class="p">(</span><span class="n">spectrumGroup</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spectrumGroup</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">spectrumGroup</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spectrumGroup</span><span class="p">,</span> <span class="n">SpectrumGroup</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> is not a spectrumGroup&#39;</span><span class="p">,</span> <span class="n">spectrumGroup</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">spectrumGroup</span><span class="o">.</span><span class="n">spectra</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Spectrum </span><span class="si">%s</span><span class="s1"> does not belong to spectrumGroup </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">spectrumGroup</span><span class="p">)))</span>

        <span class="n">seriesItems</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getInternalParameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_SERIESITEMS</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">seriesItems</span><span class="p">:</span>
            <span class="n">seriesItems</span><span class="p">[</span><span class="n">spectrumGroup</span><span class="o">.</span><span class="n">pid</span><span class="p">]</span> <span class="o">=</span> <span class="n">item</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">seriesItems</span> <span class="o">=</span> <span class="p">{</span><span class="n">spectrumGroup</span><span class="o">.</span><span class="n">pid</span><span class="p">:</span> <span class="n">item</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setInternalParameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_SERIESITEMS</span><span class="p">,</span> <span class="n">seriesItems</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_renameSeriesItems</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spectrumGroup</span><span class="p">,</span> <span class="n">oldPid</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;rename the keys in the seriesItems to reflect the updated spectrumGroup name</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">seriesItems</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getInternalParameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_SERIESITEMS</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">oldPid</span> <span class="ow">in</span> <span class="p">(</span><span class="n">seriesItems</span> <span class="k">if</span> <span class="n">seriesItems</span> <span class="k">else</span> <span class="p">()):</span>
            <span class="c1"># insert new items with the new pid</span>
            <span class="n">oldItems</span> <span class="o">=</span> <span class="n">seriesItems</span><span class="p">[</span><span class="n">oldPid</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">seriesItems</span><span class="p">[</span><span class="n">oldPid</span><span class="p">]</span>
            <span class="n">seriesItems</span><span class="p">[</span><span class="n">spectrumGroup</span><span class="o">.</span><span class="n">pid</span><span class="p">]</span> <span class="o">=</span> <span class="n">oldItems</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_setInternalParameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_SERIESITEMS</span><span class="p">,</span> <span class="n">seriesItems</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_getSeriesItemsById</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pid</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the series item for the current spectrum by &#39;pid&#39;</span>
<span class="sd">        CCPNINTERNAL: used in creating new spectrumGroups - not for external use</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">seriesItems</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getInternalParameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_SERIESITEMS</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">seriesItems</span> <span class="ow">and</span> <span class="n">pid</span> <span class="ow">in</span> <span class="n">seriesItems</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">seriesItems</span><span class="p">[</span><span class="n">pid</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_setSeriesItemsById</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the series item for the current spectrum by &#39;pid&#39;</span>
<span class="sd">        CCPNINTERNAL: used in creating new spectrumGroups - not for external use</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">seriesItems</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getInternalParameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_SERIESITEMS</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">seriesItems</span><span class="p">:</span>
            <span class="n">seriesItems</span><span class="p">[</span><span class="n">pid</span><span class="p">]</span> <span class="o">=</span> <span class="n">item</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">seriesItems</span> <span class="o">=</span> <span class="p">{</span><span class="n">pid</span><span class="p">:</span> <span class="n">item</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setInternalParameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_SERIESITEMS</span><span class="p">,</span> <span class="n">seriesItems</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_removeSeriesItemsById</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pid</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove the keys in the seriesItems allocated to &#39;pid&#39;</span>
<span class="sd">        CCPNINTERNAL: used in creating new spectrumGroups - not for external use</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># useful for storing an item</span>
        <span class="n">seriesItems</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getInternalParameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_SERIESITEMS</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pid</span> <span class="ow">in</span> <span class="n">seriesItems</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">seriesItems</span><span class="p">[</span><span class="n">pid</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_setInternalParameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_SERIESITEMS</span><span class="p">,</span> <span class="n">seriesItems</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">temperature</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The temperature of the spectrometer when the spectrum was recorded</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">experiment</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">experiment</span><span class="o">.</span><span class="n">temperature</span>

    <span class="nd">@temperature</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">temperature</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The temperature of the spectrometer when the spectrum was recorded</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">experiment</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">experiment</span><span class="o">.</span><span class="n">temperature</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_preferredAxisOrdering</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the preferred ordering for the axes (i.e zero-based); e.g. used when opening a</span>
<span class="sd">        new spectrumDisplay</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getInternalParameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_PREFERREDAXISORDERING</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensionIndices</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@_preferredAxisOrdering</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@checkSpectrumPropertyValue</span><span class="p">(</span><span class="n">iterable</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">types</span><span class="o">=</span><span class="p">(</span><span class="nb">int</span><span class="p">,))</span>
    <span class="k">def</span> <span class="nf">_preferredAxisOrdering</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setInternalParameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_PREFERREDAXISORDERING</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

<div class="viewcode-block" id="Spectrum.setPreferredDimensionOrdering"><a class="viewcode-back" href="../../../ccpn/ccpn.core.html#ccpn.core.Spectrum.Spectrum.setPreferredDimensionOrdering">[docs]</a>    <span class="nd">@checkSpectrumPropertyValue</span><span class="p">(</span><span class="n">iterable</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">types</span><span class="o">=</span><span class="p">(</span><span class="nb">int</span><span class="p">,))</span>
    <span class="k">def</span> <span class="nf">setPreferredDimensionOrdering</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimensionOrder</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the preferred dimension ordering</span>
<span class="sd">        ;param dimensionOrder: tuple,list of dimensions (1-based; len dimensionCount)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_preferredAxisOrdering</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dimensionOrder</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">_setDefaultAxisOrdering</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the default axis ordering based on some hierarchy rules (defined in the</span>
<span class="sd">        core/lib/SpectrumLib.oy file</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_setDefaultAxisOrdering</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="c1">#-----------------------------------------------------------------------------------------</span>
    <span class="c1"># Library functions</span>
    <span class="c1">#-----------------------------------------------------------------------------------------</span>

<div class="viewcode-block" id="Spectrum.ppm2point"><a class="viewcode-back" href="../../../ccpn/ccpn.core.html#ccpn.core.Spectrum.Spectrum.ppm2point">[docs]</a>    <span class="k">def</span> <span class="nf">ppm2point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">axisCode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert ppm value to point value for axis corresponding to either axisCode or</span>
<span class="sd">        dimension (1-based)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dimension</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">axisCode</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Spectrum.ppm2point: either axisCode or dimension needs to be defined&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dimension</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">axisCode</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Spectrum.ppm2point: axisCode and dimension cannot be both defined&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">axisCode</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dimension</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getByAxisCodes</span><span class="p">(</span><span class="s1">&#39;dimensions&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">axisCode</span><span class="p">],</span> <span class="n">exactMatch</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">dimension</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">dimension</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">dimension</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensionCount</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Invalid dimension (</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">dimension</span><span class="p">,))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrumDimensions</span><span class="p">[</span><span class="n">dimension</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">valueToPoint</span><span class="p">(</span><span class="n">value</span><span class="p">)</span></div>

<div class="viewcode-block" id="Spectrum.point2ppm"><a class="viewcode-back" href="../../../ccpn/ccpn.core.html#ccpn.core.Spectrum.Spectrum.point2ppm">[docs]</a>    <span class="k">def</span> <span class="nf">point2ppm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">axisCode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert point value to ppm for axis corresponding to to either axisCode or</span>
<span class="sd">        dimension (1-based)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dimension</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">axisCode</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Spectrum.point2ppm: either axisCode or dimension needs to be defined&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dimension</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">axisCode</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Spectrum.point2ppm: axisCode and dimension cannot be both defined&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">axisCode</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dimension</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getByAxisCodes</span><span class="p">(</span><span class="s1">&#39;dimensions&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">axisCode</span><span class="p">],</span> <span class="n">exactMatch</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">dimension</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">dimension</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">dimension</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensionCount</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Invalid dimension (</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">dimension</span><span class="p">,))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrumDimensions</span><span class="p">[</span><span class="n">dimension</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">pointToValue</span><span class="p">(</span><span class="n">value</span><span class="p">)</span></div>

<div class="viewcode-block" id="Spectrum.getPpmArray"><a class="viewcode-back" href="../../../ccpn/ccpn.core.html#ccpn.core.Spectrum.Spectrum.getPpmArray">[docs]</a>    <span class="k">def</span> <span class="nf">getPpmArray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axisCode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return a numpy array with ppm values of the grid points along axisCode or dimension</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dimension</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">axisCode</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Spectrum.getPpmArray: either axisCode or dimension needs to be defined&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dimension</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">axisCode</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Spectrum.getPpmArray: axisCode and dimension cannot be both defined&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">axisCode</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dimension</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getByAxisCodes</span><span class="p">(</span><span class="s1">&#39;dimensions&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">axisCode</span><span class="p">],</span> <span class="n">exactMatch</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">dimension</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">dimension</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">dimension</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensionCount</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Invalid dimension (</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">dimension</span><span class="p">,))</span>

        <span class="n">spectrumLimits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrumLimits</span><span class="p">[</span><span class="n">dimension</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">spectrumLimits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">spectrumLimits</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointCounts</span><span class="p">[</span><span class="n">dimension</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">result</span></div>

    <span class="c1"># def _verifyAxisCodeDimension(self, axisCode, dimension):</span>
    <span class="c1">#     &quot;&quot;&quot;Verify the axisCode and dimension</span>
    <span class="c1">#     Return the aliasing information for the given axis</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     if dimension is None and axisCode is None:</span>
    <span class="c1">#         raise ValueError(&#39;Spectrum._verifyAxisCodeDimension: either axisCode or dimension needs to be defined&#39;)</span>
    <span class="c1">#     if dimension is not None and axisCode is not None:</span>
    <span class="c1">#         raise ValueError(&#39;Spectrum._verifyAxisCodeDimension: axisCode and dimension cannot be both defined&#39;)</span>
    <span class="c1">#     if axisCode is not None:</span>
    <span class="c1">#         dimension = self.getByAxisCodes(&#39;dimensions&#39;, [axisCode], exactMatch=False)[0]</span>
    <span class="c1">#     if dimension is None or dimension &lt; 1 or dimension &gt; self.dimensionCount:</span>
    <span class="c1">#         raise RuntimeError(&#39;Invalid dimension (%s)&#39; % (dimension,))</span>
    <span class="c1">#</span>
    <span class="c1">#     aliasLims = self.aliasingLimits[dimension - 1]</span>
    <span class="c1">#     axisRevd = self.axesReversed[dimension - 1]</span>
    <span class="c1">#     pCount = self.pointCounts[dimension - 1]</span>
    <span class="c1">#     vpp = self.valuesPerPoint[dimension - 1] * 0.5  # offset for aliasingLimits</span>
    <span class="c1">#     if axisRevd:</span>
    <span class="c1">#         aliasLims = list(reversed(aliasLims))</span>
    <span class="c1">#         vpp = -vpp</span>
    <span class="c1">#     ppmL, ppmR = aliasLims[0] + vpp, aliasLims[1] - vpp</span>
    <span class="c1">#     pL, pR = round(self.ppm2point(ppmL, dimension=dimension)), round(self.ppm2point(ppmR, dimension=dimension))</span>
    <span class="c1">#</span>
    <span class="c1">#     # clip to the maximum allowed aliasing limits</span>
    <span class="c1">#     pL = min((MAXALIASINGRANGE + 1) * pCount, max(-MAXALIASINGRANGE * pCount, pL))</span>
    <span class="c1">#     pR = min((MAXALIASINGRANGE + 1) * pCount, max(-MAXALIASINGRANGE * pCount, pR))</span>
    <span class="c1">#     return ppmL, ppmR, pL, pR</span>

    <span class="c1"># def getPpmAliasingLimitsArray(self, axisCode=None, dimension=None) -&gt; numpy.array:</span>
    <span class="c1">#     &quot;&quot;&quot;Return a numpy array of ppm values of the grid points along axisCode or dimension</span>
    <span class="c1">#     for the points contained by the aliasing limits, end points are inclusive</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     ppmL, ppmR, pL, pR = self._verifyAxisCodeDimension(axisCode, dimension)</span>
    <span class="c1">#     return numpy.linspace(ppmL, ppmR, pR - pL + 1)</span>
    <span class="c1">#</span>
    <span class="c1"># def getPpmAliasingLimits(self, axisCode=None, dimension=None):</span>
    <span class="c1">#     &quot;&quot;&quot;Return a tuple of ppm values of the (first, last) grid points along axisCode or dimension</span>
    <span class="c1">#     for the points contained by the aliasing limits, end points are inclusive</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     ppmL, ppmR, _tmp1, _tmp2 = self._verifyAxisCodeDimension(axisCode, dimension)</span>
    <span class="c1">#     return (ppmL, ppmR)</span>

    <span class="c1"># def getPointAliasingLimitsArray(self, axisCode=None, dimension=None) -&gt; numpy.array:</span>
    <span class="c1">#     &quot;&quot;&quot;Return a numpy array with point values of the grid points along axisCode or dimension</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     _tmp1, _tmp2, pL, pR = self._verifyAxisCodeDimension(axisCode, dimension)</span>
    <span class="c1">#     return numpy.linspace(pL, pR, pR - pL + 1)</span>

    <span class="c1"># def getPointAliasingLimits(self, axisCode=None, dimension=None):</span>
    <span class="c1">#     &quot;&quot;&quot;Return a tuple of point values of the (first, last) grid points along axisCode or dimension</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     _tmp1, _tmp2, pL, pR = self._verifyAxisCodeDimension(axisCode, dimension)</span>
    <span class="c1">#     return (pL, pR)</span>

    <span class="c1"># def automaticIntegration(self, spectralData):</span>
    <span class="c1">#     return self._apiDataSource.automaticIntegration(spectralData)</span>

    <span class="k">def</span> <span class="nf">_mapAxisCodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axisCodes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Map axisCodes on self.axisCodes</span>
<span class="sd">        :return mapped axisCodes as list</span>

<span class="sd">        CCPNMRINTERNAL: used in SpectrumDisplay._getDimensionsMapping()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># find the map of newAxisCodeOrder to self.axisCodes; eg. &#39;H&#39; to &#39;Hn&#39;</span>
        <span class="n">axisCodeMap</span> <span class="o">=</span> <span class="n">getAxisCodeMatch</span><span class="p">(</span><span class="n">axisCodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axisCodes</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axisCodeMap</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;axisCodes </span><span class="si">%r</span><span class="s1"> contains an invalid element&#39;</span> <span class="o">%</span> <span class="n">axisCodes</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">axisCodeMap</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">axisCodes</span><span class="p">]</span>

<div class="viewcode-block" id="Spectrum.orderByAxisCodes"><a class="viewcode-back" href="../../../ccpn/ccpn.core.html#ccpn.core.Spectrum.Spectrum.orderByAxisCodes">[docs]</a>    <span class="k">def</span> <span class="nf">orderByAxisCodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterable</span><span class="p">,</span> <span class="n">axisCodes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">exactMatch</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return a list with values of an iterable in order defined by axisCodes (default order if None).</span>
<span class="sd">        Perform a mapping if exactMatch=False (eg. &#39;H&#39; to &#39;Hn&#39;)</span>

<span class="sd">        :param iterable: an iterable (tuple, list)</span>
<span class="sd">        :param axisCodes: a tuple or list of axisCodes</span>
<span class="sd">        :param exactMatch: a boolean optional testing for an exact match with the instance axisCodes</span>
<span class="sd">        :return: the values defined by iterable in axisCode order</span>

<span class="sd">        Related:</span>
<span class="sd">        Use getByDimensions() for dimensions (1..dimensionCount) based access of dimensional parameters of the</span>
<span class="sd">            Spectrum class.</span>
<span class="sd">        Use getByAxisCodes() for axisCode based access of dimensional parameters of the Spectrum class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">ccpn.core.lib.SpectrumLib</span> <span class="kn">import</span> <span class="n">_orderByDimensions</span>

        <span class="k">if</span> <span class="n">axisCodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axisCodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axisCodes</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">isIterable</span><span class="p">(</span><span class="n">axisCodes</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">.orderByAxisCodes: axisCodes is not iterable &quot;</span><span class="si">%s</span><span class="s1">&quot;; expected list or tuple&#39;</span> <span class="o">%</span>
                                 <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">className</span><span class="p">,</span> <span class="n">axisCodes</span><span class="p">))</span>

            <span class="c1"># do some optional axis code matching</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">exactMatch</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">_axisCodes</span> <span class="o">:=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mapAxisCodes</span><span class="p">(</span><span class="n">axisCodes</span><span class="p">))</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">.orderByAxisCodes: Failed mapping axisCodes &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span>
                                     <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">className</span><span class="p">,</span> <span class="n">axisCodes</span><span class="p">))</span>
                <span class="n">axisCodes</span> <span class="o">=</span> <span class="n">_axisCodes</span>

        <span class="c1"># we now should have valid axisCodes</span>
        <span class="k">for</span> <span class="n">ac</span> <span class="ow">in</span> <span class="n">axisCodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">ac</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axisCodes</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">.orderByAxisCodes: invalid axisCode &quot;</span><span class="si">%s</span><span class="s1">&quot; in </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span>
                                 <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">className</span><span class="p">,</span> <span class="n">ac</span><span class="p">,</span> <span class="n">axisCodes</span><span class="p">))</span>

        <span class="c1"># create an (axisCode, dimension) mapping</span>
        <span class="n">mapping</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">ac</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span> <span class="k">for</span> <span class="n">dimIndx</span><span class="p">,</span> <span class="n">ac</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensionTriples</span><span class="p">])</span>
        <span class="c1"># get the dimensions in axisCode order</span>
        <span class="n">dimensions</span> <span class="o">=</span> <span class="p">[</span><span class="n">mapping</span><span class="p">[</span><span class="n">ac</span><span class="p">]</span> <span class="k">for</span> <span class="n">ac</span> <span class="ow">in</span> <span class="n">axisCodes</span><span class="p">]</span>
        <span class="c1"># get the values of iterable in axisCode==dimensions order</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">_orderByDimensions</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">=</span><span class="n">dimensions</span><span class="p">,</span> <span class="n">dimensionCount</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensionCount</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">values</span></div>

<div class="viewcode-block" id="Spectrum.getByAxisCodes"><a class="viewcode-back" href="../../../ccpn/ccpn.core.html#ccpn.core.Spectrum.Spectrum.getByAxisCodes">[docs]</a>    <span class="k">def</span> <span class="nf">getByAxisCodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameterName</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">axisCodes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                       <span class="n">exactMatch</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return a list of values defined by parameterName in order defined by axisCodes (default order if None).</span>
<span class="sd">        Perform a mapping if exactMatch=False (eg. &#39;H&#39; to &#39;Hn&#39;)</span>

<span class="sd">        :param parameterName: a str denoting a Spectrum dimensional attribute</span>
<span class="sd">        :param axisCodes: a tuple or list of axisCodes</span>
<span class="sd">        :param exactMatch: a boolean optional testing for an exact match with the instance axisCodes</span>
<span class="sd">        :return: the values defined by parameterName in axisCode order</span>

<span class="sd">        Related:</span>
<span class="sd">        Use getByDimensions() for dimensions (1..dimensionCount) based access of dimensional parameters of the</span>
<span class="sd">            Spectrum class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">ccpn.core.lib.SpectrumLib</span> <span class="kn">import</span> <span class="n">_getParameterValues</span>

        <span class="k">if</span> <span class="n">axisCodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dimensions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dimensions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">orderByAxisCodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">,</span> <span class="n">axisCodes</span><span class="o">=</span><span class="n">axisCodes</span><span class="p">,</span> <span class="n">exactMatch</span><span class="o">=</span><span class="n">exactMatch</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">newValues</span> <span class="o">=</span> <span class="n">_getParameterValues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameterName</span><span class="p">,</span>
                                            <span class="n">dimensions</span><span class="o">=</span><span class="n">dimensions</span><span class="p">,</span> <span class="n">dimensionCount</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensionCount</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">es</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">.getByAxisCodes: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">es</span><span class="p">)))</span>

        <span class="k">return</span> <span class="n">newValues</span></div>

<div class="viewcode-block" id="Spectrum.setByAxisCodes"><a class="viewcode-back" href="../../../ccpn/ccpn.core.html#ccpn.core.Spectrum.Spectrum.setByAxisCodes">[docs]</a>    <span class="k">def</span> <span class="nf">setByAxisCodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameterName</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span><span class="n">Sequence</span><span class="p">,</span> <span class="n">axisCodes</span><span class="p">:</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                       <span class="n">exactMatch</span><span class="p">:</span><span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Set attributeName to values in order defined by axisCodes (default order if None)</span>
<span class="sd">        Perform a mapping if exactMatch=False (eg. &#39;H&#39; to &#39;Hn&#39;)</span>

<span class="sd">        :param parameterName: a str denoting a Spectrum dimensional attribute</span>
<span class="sd">        :param values: an iterable with values</span>
<span class="sd">        :param axisCodes: a tuple or list of axisCodes</span>
<span class="sd">        :param exactMatch: a boolean optional testing for an exact match with the instance axisCodes</span>
<span class="sd">        :return: a list of newly set values of parameterName (in default order)</span>

<span class="sd">        Related:</span>
<span class="sd">        Use setByDimensions() for dimensions (1..dimensionCount) based setting of dimensional parameters of the</span>
<span class="sd">            Spectrum class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">ccpn.core.lib.SpectrumLib</span> <span class="kn">import</span> <span class="n">_setParameterValues</span>

        <span class="k">if</span> <span class="n">axisCodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dimensions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dimensions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">orderByAxisCodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">,</span> <span class="n">axisCodes</span><span class="o">=</span><span class="n">axisCodes</span><span class="p">,</span> <span class="n">exactMatch</span><span class="o">=</span><span class="n">exactMatch</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">newValues</span> <span class="o">=</span> <span class="n">_setParameterValues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameterName</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span>
                                            <span class="n">dimensions</span><span class="o">=</span><span class="n">dimensions</span><span class="p">,</span> <span class="n">dimensionCount</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensionCount</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">es</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">.setByAxisCodes: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">es</span><span class="p">)))</span>

        <span class="k">return</span> <span class="n">newValues</span></div>

<div class="viewcode-block" id="Spectrum.orderByDimensions"><a class="viewcode-back" href="../../../ccpn/ccpn.core.html#ccpn.core.Spectrum.Spectrum.orderByDimensions">[docs]</a>    <span class="k">def</span> <span class="nf">orderByDimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterable</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return a list of values of iterable in order defined by dimensions (default order if None).</span>

<span class="sd">        :param iterable: an iterable (tuple, list)</span>
<span class="sd">        :param dimensions: a tuple or list of dimensions (1..dimensionCount)</span>
<span class="sd">        :return: a list with values defined by iterable in dimensions order</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">ccpn.core.lib.SpectrumLib</span> <span class="kn">import</span> <span class="n">_orderByDimensions</span>
        <span class="k">if</span> <span class="n">dimensions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dimensions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span>
        <span class="k">return</span> <span class="n">_orderByDimensions</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">=</span><span class="n">dimensions</span><span class="p">,</span> <span class="n">dimensionCount</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensionCount</span><span class="p">)</span></div>

<div class="viewcode-block" id="Spectrum.getByDimensions"><a class="viewcode-back" href="../../../ccpn/ccpn.core.html#ccpn.core.Spectrum.Spectrum.getByDimensions">[docs]</a>    <span class="k">def</span> <span class="nf">getByDimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameterName</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">:</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return a list of values of Spectrum dimensional attribute parameterName in order defined</span>
<span class="sd">        by dimensions (default order if None).</span>

<span class="sd">        :param parameterName: a str denoting a Spectrum dimensional attribute</span>
<span class="sd">        :param dimensions: a tuple or list of dimensions (1..dimensionCount)</span>
<span class="sd">        :return: a list of values defined by parameterName in dimensions order</span>

<span class="sd">        Related:</span>
<span class="sd">        Use getByAxisCodes() for axisCode based access of dimensional parameters of the Spectrum class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">ccpn.core.lib.SpectrumLib</span> <span class="kn">import</span> <span class="n">_getParameterValues</span>

        <span class="k">if</span> <span class="n">dimensions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dimensions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">newValues</span> <span class="o">=</span> <span class="n">_getParameterValues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameterName</span><span class="p">,</span>
                                            <span class="n">dimensions</span><span class="o">=</span><span class="n">dimensions</span><span class="p">,</span> <span class="n">dimensionCount</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensionCount</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">es</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">.getByDimensions: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">es</span><span class="p">)))</span>

        <span class="k">return</span> <span class="n">newValues</span></div>

<div class="viewcode-block" id="Spectrum.setByDimensions"><a class="viewcode-back" href="../../../ccpn/ccpn.core.html#ccpn.core.Spectrum.Spectrum.setByDimensions">[docs]</a>    <span class="k">def</span> <span class="nf">setByDimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameterName</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span><span class="n">Sequence</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">:</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Set Spectrum dimensional attribute parameterName to values in the order as defined by</span>
<span class="sd">        dimensions (1..dimensionCount)(default order if None)</span>

<span class="sd">        :param parameterName: a str denoting a Spectrum dimensional attribute</span>
<span class="sd">        :param values: a list of values to set for each dimension</span>
<span class="sd">        :param dimensions: a tuple or list of dimensions (1..dimensionCount)</span>
<span class="sd">        :return: a list of newly set values of parameterName (in default order)</span>

<span class="sd">        Related:</span>
<span class="sd">        Use setByAxisCodes() for axisCode based setting of dimensional parameters of the Spectrum class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">ccpn.core.lib.SpectrumLib</span> <span class="kn">import</span> <span class="n">_setParameterValues</span>

        <span class="k">if</span> <span class="n">dimensions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dimensions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">newValues</span> <span class="o">=</span> <span class="n">_setParameterValues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameterName</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span>
                                            <span class="n">dimensions</span><span class="o">=</span><span class="n">dimensions</span><span class="p">,</span> <span class="n">dimensionCount</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensionCount</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">es</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">.setByDimensions: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">es</span><span class="p">)))</span>

        <span class="k">return</span> <span class="n">newValues</span></div>

    <span class="k">def</span> <span class="nf">_setDefaultContourValues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">multiplier</span><span class="o">=</span><span class="mf">1.41</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set default contour values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">base</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">noiseLevel</span> <span class="o">*</span> <span class="n">multiplier</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">noiseLevel</span> <span class="k">else</span> <span class="mf">1e6</span>
        <span class="n">base</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>  <span class="c1"># Contour bases have to be &gt; 0.0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">positiveContourBase</span> <span class="o">=</span> <span class="n">base</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">positiveContourFactor</span> <span class="o">=</span> <span class="n">multiplier</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">positiveContourCount</span> <span class="o">=</span> <span class="n">count</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">negativeContourBase</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">base</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">negativeContourFactor</span> <span class="o">=</span> <span class="n">multiplier</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">negativeContourCount</span> <span class="o">=</span> <span class="n">count</span>

    <span class="k">def</span> <span class="nf">_setDefaultContourColours</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set default contour colours</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">positiveContourColour</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">negativeContourColour</span><span class="p">)</span> <span class="o">=</span> <span class="n">getDefaultSpectrumColours</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sliceColour</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">positiveContourColour</span>

<div class="viewcode-block" id="Spectrum.getPeakAliasingRanges"><a class="viewcode-back" href="../../../ccpn/ccpn.core.html#ccpn.core.Spectrum.Spectrum.getPeakAliasingRanges">[docs]</a>    <span class="k">def</span> <span class="nf">getPeakAliasingRanges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the min/max aliasing Values for the peakLists in the spectrum, if there are no peakLists with peaks, return None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get the aliasingRanges for non-empty peakLists</span>
        <span class="n">aliasRanges</span> <span class="o">=</span> <span class="p">[</span><span class="n">peakList</span><span class="o">.</span><span class="n">getPeakAliasingRanges</span><span class="p">()</span> <span class="k">for</span> <span class="n">peakList</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">peakLists</span> <span class="k">if</span> <span class="n">peakList</span><span class="o">.</span><span class="n">peaks</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">aliasRanges</span><span class="p">:</span>
            <span class="c1"># if there is only one then return it (for clarity)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">aliasRanges</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">aliasRanges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># get the value from all the peakLists</span>
            <span class="n">newRanges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">aliasRanges</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">alias</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">aliasRanges</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
                <span class="k">if</span> <span class="n">alias</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">newRanges</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">((</span><span class="nb">min</span><span class="p">(</span><span class="n">minL</span><span class="p">,</span> <span class="n">minR</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">maxL</span><span class="p">,</span> <span class="n">maxR</span><span class="p">))</span> <span class="k">for</span> <span class="p">(</span><span class="n">minL</span><span class="p">,</span> <span class="n">maxL</span><span class="p">),</span> <span class="p">(</span><span class="n">minR</span><span class="p">,</span> <span class="n">maxR</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">alias</span><span class="p">,</span> <span class="n">newRanges</span><span class="p">))</span>

            <span class="k">return</span> <span class="n">newRanges</span></div>

    <span class="k">def</span> <span class="nf">_copyDimensionalParameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axisCodes</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Copy dimensional parameters for axisCodes from self to target</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">_includeInCopyList</span><span class="p">()</span><span class="o">.</span><span class="n">getMultiDimensional</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getByAxisCodes</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">axisCodes</span><span class="p">,</span> <span class="n">exactMatch</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">target</span><span class="o">.</span><span class="n">setByAxisCodes</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">axisCodes</span><span class="p">,</span> <span class="n">exactMatch</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">es</span><span class="p">:</span>
                <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Copying &quot;</span><span class="si">%s</span><span class="s1">&quot; from </span><span class="si">%s</span><span class="s1"> to </span><span class="si">%s</span><span class="s1"> for axisCodes </span><span class="si">%s</span><span class="s1">: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span>
                                  <span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">axisCodes</span><span class="p">,</span> <span class="n">es</span><span class="p">)</span>
                                  <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_copyNonDimensionalParameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Copy non-dimensional parameters from self to target</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">parameterName</span> <span class="ow">in</span> <span class="n">_includeInCopyList</span><span class="p">()</span><span class="o">.</span><span class="n">getNoneDimensional</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameterName</span><span class="p">)</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">parameterName</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">es</span><span class="p">:</span>
                <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Copying parameter </span><span class="si">%r</span><span class="s1"> from </span><span class="si">%s</span><span class="s1"> to </span><span class="si">%s</span><span class="s1">: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">parameterName</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">es</span><span class="p">))</span>

<div class="viewcode-block" id="Spectrum.copyParameters"><a class="viewcode-back" href="../../../ccpn/ccpn.core.html#ccpn.core.Spectrum.Spectrum.copyParameters">[docs]</a>    <span class="k">def</span> <span class="nf">copyParameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axisCodes</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Copy non-dimensional and dimensional parameters for axisCodes from self to target</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_copyNonDimensionalParameters</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_copyDimensionalParameters</span><span class="p">(</span><span class="n">axisCodes</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span></div>

<div class="viewcode-block" id="Spectrum.estimateNoise"><a class="viewcode-back" href="../../../ccpn/ccpn.core.html#ccpn.core.Spectrum.Spectrum.estimateNoise">[docs]</a>    <span class="k">def</span> <span class="nf">estimateNoise</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Estimate and return the noise level, or None if it cannot be</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataSource</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">noise</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataSource</span><span class="o">.</span><span class="n">estimateNoise</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">noise</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">noise</span></div>

    <span class="c1">#-----------------------------------------------------------------------------------------</span>
    <span class="c1"># data access functions</span>
    <span class="c1">#-----------------------------------------------------------------------------------------</span>

<div class="viewcode-block" id="Spectrum.isBuffered"><a class="viewcode-back" href="../../../ccpn/ccpn.core.html#ccpn.core.Spectrum.Spectrum.isBuffered">[docs]</a>    <span class="k">def</span> <span class="nf">isBuffered</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if dataSource of spectrum is buffered</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataSource</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataSource</span><span class="o">.</span><span class="n">isBuffered</span></div>

<div class="viewcode-block" id="Spectrum.setBuffering"><a class="viewcode-back" href="../../../ccpn/ccpn.core.html#ccpn.core.Spectrum.Spectrum.setBuffering">[docs]</a>    <span class="k">def</span> <span class="nf">setBuffering</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">isBuffered</span><span class="p">:</span><span class="nb">bool</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span><span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set Hdf5-buffering.</span>
<span class="sd">        Buffering status is retained (upon exit/save) if path is None; i.e. autobuffering, until</span>
<span class="sd">        buffering is disabled by isBuffered=False</span>

<span class="sd">        :param isBuffered: set the buffering status</span>
<span class="sd">        :param path: store hdf5buffer file at path; implies non-temporary buffer</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataSource</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;No proper (filePath, dataFormat) set for </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">isBuffered</span><span class="p">:</span>
            <span class="n">bufferIsTemporary</span> <span class="o">=</span> <span class="p">(</span><span class="n">path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">_bufferStore</span> <span class="o">=</span> <span class="n">DataStore</span><span class="o">.</span><span class="n">newFromPath</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="n">path</span><span class="p">,</span>
                                                     <span class="n">autoVersioning</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                     <span class="n">dataFormat</span><span class="o">=</span><span class="n">Hdf5SpectrumDataSource</span><span class="o">.</span><span class="n">dataFormat</span><span class="p">,</span>
                                                     <span class="n">withSuffix</span><span class="o">=</span><span class="n">Hdf5SpectrumDataSource</span><span class="o">.</span><span class="n">suffixes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                                                   <span class="p">)</span>
                <span class="n">path</span> <span class="o">=</span> <span class="n">_bufferStore</span><span class="o">.</span><span class="n">aPath</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_dataStore</span><span class="o">.</span><span class="n">useBuffer</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># Explicit path, no autobuffering</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_dataStore</span><span class="o">.</span><span class="n">useBuffer</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">dataSource</span><span class="o">.</span><span class="n">setBuffering</span><span class="p">(</span><span class="n">isBuffered</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">bufferIsTemporary</span><span class="o">=</span><span class="n">bufferIsTemporary</span><span class="p">,</span> <span class="n">bufferPath</span><span class="o">=</span><span class="n">path</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Turn off buffering</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataSource</span><span class="o">.</span><span class="n">isBuffered</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dataSource</span><span class="o">.</span><span class="n">closeHdf5Buffer</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dataSource</span><span class="o">.</span><span class="n">setBuffering</span><span class="p">(</span><span class="n">isBuffered</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dataStore</span><span class="o">.</span><span class="n">useBuffer</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_dataStore</span><span class="o">.</span><span class="n">_saveInternal</span><span class="p">()</span></div>

<div class="viewcode-block" id="Spectrum.getIntensity"><a class="viewcode-back" href="../../../ccpn/ccpn.core.html#ccpn.core.Spectrum.Spectrum.getIntensity">[docs]</a>    <span class="nd">@logCommand</span><span class="p">(</span><span class="n">get</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">getIntensity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ppmPositions</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the interpolated height at the ppm position</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># The height below is not derived from any fitting</span>
        <span class="c1"># but is a weighted average of the values at the neighbouring grid points</span>

        <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;This routine has been replaced with getHeight&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getHeight</span><span class="p">(</span><span class="n">ppmPositions</span><span class="p">)</span></div>

<div class="viewcode-block" id="Spectrum.getHeight"><a class="viewcode-back" href="../../../ccpn/ccpn.core.html#ccpn.core.Spectrum.Spectrum.getHeight">[docs]</a>    <span class="nd">@logCommand</span><span class="p">(</span><span class="n">get</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">getHeight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ppmPositions</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the interpolated height at the ppm position</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ppmPositions</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensionCount</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Length of </span><span class="si">%s</span><span class="s1"> does not match number of dimensions&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">ppmPositions</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">dimVal</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span> <span class="k">for</span> <span class="n">dimVal</span> <span class="ow">in</span> <span class="n">ppmPositions</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;ppmPositions values must be floats&#39;</span><span class="p">)</span>

        <span class="n">pointPositions</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ppm2point</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ppmPositions</span><span class="p">)]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getPointValue</span><span class="p">(</span><span class="n">pointPositions</span><span class="p">)</span></div>

<div class="viewcode-block" id="Spectrum.getPointValue"><a class="viewcode-back" href="../../../ccpn/ccpn.core.html#ccpn.core.Spectrum.Spectrum.getPointValue">[docs]</a>    <span class="nd">@logCommand</span><span class="p">(</span><span class="n">get</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">getPointValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pointPositions</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the value interpolated at the position given in points (1-based, float values).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pointPositions</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensionCount</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Length of </span><span class="si">%s</span><span class="s1"> does not match number of dimensions.&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">pointPositions</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">dimVal</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span> <span class="k">for</span> <span class="n">dimVal</span> <span class="ow">in</span> <span class="n">pointPositions</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;position values must be floats.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataSource</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;No proper (filePath, dataFormat) set for </span><span class="si">%s</span><span class="s1">; Returning zero&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span>
            <span class="k">return</span> <span class="mf">0.0</span>

        <span class="c1"># need to check folding/circular/±sign</span>

        <span class="c1"># pointPositions = []</span>
        <span class="c1"># aliasing = []</span>
        <span class="c1"># for idx, (p, np) in enumerate(zip(ppmPos, spectrum.pointCounts)):</span>
        <span class="c1">#     pp = spectrum.ppm2point(p, dimension=idx + 1)</span>
        <span class="c1">#     pointPositions.append(((pp - 1) % np) + 1)</span>
        <span class="c1">#     aliasing.append((pp - 1) // np)</span>

        <span class="n">aliasingFlags</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensionCount</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataSource</span><span class="o">.</span><span class="n">getPointValue</span><span class="p">(</span><span class="n">pointPositions</span><span class="p">,</span> <span class="n">aliasingFlags</span><span class="o">=</span><span class="n">aliasingFlags</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">value</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span></div>

<div class="viewcode-block" id="Spectrum.getSliceData"><a class="viewcode-back" href="../../../ccpn/ccpn.core.html#ccpn.core.Spectrum.Spectrum.getSliceData">[docs]</a>    <span class="nd">@logCommand</span><span class="p">(</span><span class="n">get</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">getSliceData</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sliceDim</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SliceData</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get a slice defined by sliceDim and a position vector as a SliceData object</span>
<span class="sd">        (i.e. a numpy array).</span>

<span class="sd">        :param position: An optional list/tuple of point positions (1-based);</span>
<span class="sd">                         defaults to [1,1,1,1]</span>
<span class="sd">        :param sliceDim: Dimension of the slice axis (1-based); defaults to 1</span>

<span class="sd">        :return: SliceData 1D data array</span>

<span class="sd">        NB: use getSlice() method for axisCode based access</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataSource</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;No proper (filePath, dataFormat) set for </span><span class="si">%s</span><span class="s1">; Returning zeros only&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">SliceData</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pointCounts</span><span class="p">[</span><span class="n">sliceDim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],),</span>
                             <span class="n">dimensions</span><span class="o">=</span><span class="p">(</span><span class="n">sliceDim</span><span class="p">,),</span>
                             <span class="n">position</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensionCount</span>
                             <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">position</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataSource</span><span class="o">.</span><span class="n">checkForValidSlice</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="n">sliceDim</span><span class="p">)</span>
                <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataSource</span><span class="o">.</span><span class="n">getSliceData</span><span class="p">(</span><span class="n">position</span><span class="o">=</span><span class="n">position</span><span class="p">,</span> <span class="n">sliceDim</span><span class="o">=</span><span class="n">sliceDim</span><span class="p">)</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;K&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span>

            <span class="k">except</span> <span class="p">(</span><span class="ne">RuntimeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">)</span> <span class="k">as</span> <span class="n">es</span><span class="p">:</span>
                <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Spectrum.getSliceData: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">es</span><span class="p">)</span>
                <span class="k">raise</span> <span class="n">es</span>

        <span class="c1"># For 1D, save as intensities attribute;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_intensities</span> <span class="o">=</span> <span class="n">data</span>
        <span class="k">return</span> <span class="n">data</span></div>

<div class="viewcode-block" id="Spectrum.getSlice"><a class="viewcode-back" href="../../../ccpn/ccpn.core.html#ccpn.core.Spectrum.Spectrum.getSlice">[docs]</a>    <span class="nd">@logCommand</span><span class="p">(</span><span class="n">get</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">getSlice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axisCode</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SliceData</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get a slice defined by axisCode and a position vector a SliceData object</span>
<span class="sd">        (i.e. a numpy array)</span>

<span class="sd">        :param axisCode: valid axisCode of the slice axis</span>
<span class="sd">        :param position: An optional list/tuple of point positions (1-based);</span>
<span class="sd">                         defaults to [1,1,1,1]</span>

<span class="sd">        :return: SliceData 1D data array</span>

<span class="sd">        NB: use getSliceData() method for dimension based access</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dimensions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getByAxisCodes</span><span class="p">(</span><span class="s1">&#39;dimensions&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">axisCode</span><span class="p">],</span> <span class="n">exactMatch</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getSliceData</span><span class="p">(</span><span class="n">position</span><span class="o">=</span><span class="n">position</span><span class="p">,</span> <span class="n">sliceDim</span><span class="o">=</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span></div>

<div class="viewcode-block" id="Spectrum.setSliceData"><a class="viewcode-back" href="../../../ccpn/ccpn.core.html#ccpn.core.Spectrum.Spectrum.setSliceData">[docs]</a>    <span class="k">def</span> <span class="nf">setSliceData</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">position</span><span class="p">:</span> <span class="n">Sequence</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">sliceDim</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set data as slice defined by sliceDim and position (all 1-based)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataSource</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;No proper (filePath, dataFormat) set for </span><span class="si">%s</span><span class="s1">; cannot set plane data&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">position</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataSource</span><span class="o">.</span><span class="n">checkForValidSlice</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="n">sliceDim</span><span class="o">=</span><span class="n">sliceDim</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">RuntimeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">)</span> <span class="k">as</span> <span class="n">es</span><span class="p">:</span>
            <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;invalid arguments: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">es</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">es</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dataSource</span><span class="o">.</span><span class="n">setSliceData</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="n">position</span><span class="p">,</span> <span class="n">sliceDim</span><span class="o">=</span><span class="n">sliceDim</span><span class="p">)</span></div>

<div class="viewcode-block" id="Spectrum.extractSliceToFile"><a class="viewcode-back" href="../../../ccpn/ccpn.core.html#ccpn.core.Spectrum.Spectrum.extractSliceToFile">[docs]</a>    <span class="nd">@logCommand</span><span class="p">(</span><span class="n">get</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">extractSliceToFile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axisCode</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dataFormat</span><span class="o">=</span><span class="s1">&#39;Hdf5&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Extract 1D slice from self as new Spectrum instance;</span>
<span class="sd">        saved to path (autogenerated if None)</span>
<span class="sd">        if 1D it effectively yields a copy of self</span>

<span class="sd">        :param axisCode: axiscode of slice to extract</span>
<span class="sd">        :param position: position vector (1-based)</span>
<span class="sd">        :param path: optional path; if None, constructed from current filePath</span>
<span class="sd">        :param dataFormat: string identifier for dataFormat of resulting file;</span>
<span class="sd">                           dataFormat need to have writing abilty (currently only for Hdf5)</span>

<span class="sd">        :return: Spectrum instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataSource</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">=</span> <span class="s1">&#39;No proper (filePath, dataFormat) set for </span><span class="si">%s</span><span class="s1">; unable to extract slice&#39;</span> <span class="o">%</span> <span class="bp">self</span>
            <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">axisCode</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">axisCode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axisCodes</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid axisCode </span><span class="si">%r</span><span class="s1">, should be one of </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">axisCode</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axisCodes</span><span class="p">))</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">dimensions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getByAxisCodes</span><span class="p">(</span><span class="s1">&#39;dimensions&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">axisCode</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dataSource</span><span class="o">.</span><span class="n">checkForValidSlice</span><span class="p">(</span><span class="n">position</span><span class="o">=</span><span class="n">position</span><span class="p">,</span> <span class="n">sliceDim</span><span class="o">=</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">newSpectrum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extractToFile</span><span class="p">(</span><span class="n">axisCodes</span><span class="o">=</span><span class="p">[</span><span class="n">axisCode</span><span class="p">],</span> <span class="n">position</span><span class="o">=</span><span class="n">position</span><span class="p">,</span>
                                              <span class="n">path</span><span class="o">=</span><span class="n">path</span><span class="p">,</span> <span class="n">dataFormat</span><span class="o">=</span><span class="n">dataFormat</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="s1">&#39;slice&#39;</span><span class="p">)</span>

        <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">RuntimeError</span><span class="p">)</span> <span class="k">as</span> <span class="n">es</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">=</span> <span class="s1">&#39;Spectrum.extractSliceToFile: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">es</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">newSpectrum</span></div>

<div class="viewcode-block" id="Spectrum.getPlaneData"><a class="viewcode-back" href="../../../ccpn/ccpn.core.html#ccpn.core.Spectrum.Spectrum.getPlaneData">[docs]</a>    <span class="nd">@logCommand</span><span class="p">(</span><span class="n">get</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">getPlaneData</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xDim</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">yDim</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PlaneData</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get a plane defined by by xDim and yDim (&#39;1&#39;-based), and a position vector (&#39;1&#39;-based)</span>
<span class="sd">        as a PlaneData object (i.e. a 2D numpy.ndarray). Dimensionality must be &gt;= 2</span>

<span class="sd">        :param position: A list/tuple of point-positions (1-based)</span>
<span class="sd">        :param xDim: Dimension of the first axis (1-based)</span>
<span class="sd">        :param yDim: Dimension of the second axis (1-based)</span>

<span class="sd">        :return: a PlaneData object (i.e. a 2D numpy.ndarray in order (yDim, xDim))</span>

<span class="sd">        NB: use getPlane() method for axisCode based access</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensionCount</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Spectrum.getPlaneData: dimensionality &lt; 2&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataSource</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;No proper (filePath, dataFormat) set for </span><span class="si">%s</span><span class="s1">; Returning zeros only&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">PlaneData</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pointCounts</span><span class="p">[</span><span class="n">yDim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointCounts</span><span class="p">[</span><span class="n">xDim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]),</span>
                             <span class="n">dimensions</span><span class="o">=</span><span class="p">(</span><span class="n">xDim</span><span class="p">,</span> <span class="n">yDim</span><span class="p">),</span>
                             <span class="n">position</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensionCount</span>
                            <span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">position</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataSource</span><span class="o">.</span><span class="n">checkForValidPlane</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="n">xDim</span><span class="o">=</span><span class="n">xDim</span><span class="p">,</span> <span class="n">yDim</span><span class="o">=</span><span class="n">yDim</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">RuntimeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">)</span> <span class="k">as</span> <span class="n">es</span><span class="p">:</span>
            <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;invalid arguments: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">es</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">es</span>

        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataSource</span><span class="o">.</span><span class="n">getPlaneData</span><span class="p">(</span><span class="n">position</span><span class="o">=</span><span class="n">position</span><span class="p">,</span> <span class="n">xDim</span><span class="o">=</span><span class="n">xDim</span><span class="p">,</span> <span class="n">yDim</span><span class="o">=</span><span class="n">yDim</span><span class="p">)</span>
        <span class="c1"># Make a copy in order to preserve the original data and apply scaling</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;K&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span>

        <span class="c1">#TODO: settle on the axisReversed issue</span>

        <span class="c1"># if self.axesReversed[xDim-1]:</span>
        <span class="c1">#     data = numpy.flip(data, axis=0)  # data are [y,x] ordered</span>
        <span class="c1"># if self.axesReversed[yDim-1]:</span>
        <span class="c1">#     data = numpy.flip(data, axis=1)  # data are [y,x] ordered</span>

        <span class="k">return</span> <span class="n">data</span></div>

<div class="viewcode-block" id="Spectrum.getPlane"><a class="viewcode-back" href="../../../ccpn/ccpn.core.html#ccpn.core.Spectrum.Spectrum.getPlane">[docs]</a>    <span class="nd">@logCommand</span><span class="p">(</span><span class="n">get</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">getPlane</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axisCodes</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PlaneData</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get a plane defined by axisCodes and position as a a PlaneData object</span>
<span class="sd">        (i.e. a 2D numpy.ndarray in order (yDim, xDim)). Dimensionality must be &gt;= 2</span>

<span class="sd">        :param axisCodes: tuple/list of two axisCodes; expand if exactMatch=False</span>
<span class="sd">        :param position: A list/tuple of point-positions (1-based)</span>
<span class="sd">        :param axisCodes: A list/tuple of axisCodes that define the plane dimensions</span>

<span class="sd">        :return: a PlaneData object (i.e. a 2D numpy.ndarray in order (yDim, xDim))</span>

<span class="sd">        NB: use getPlaneData method for dimension based access</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axisCodes</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid axisCodes </span><span class="si">%s</span><span class="s1">, len should be 2&#39;</span> <span class="o">%</span> <span class="n">axisCodes</span><span class="p">)</span>

        <span class="n">xDim</span><span class="p">,</span> <span class="n">yDim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getByAxisCodes</span><span class="p">(</span><span class="s1">&#39;dimensions&#39;</span><span class="p">,</span> <span class="n">axisCodes</span><span class="p">,</span> <span class="n">exactMatch</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getPlaneData</span><span class="p">(</span><span class="n">position</span><span class="o">=</span><span class="n">position</span><span class="p">,</span> <span class="n">xDim</span><span class="o">=</span><span class="n">xDim</span><span class="p">,</span> <span class="n">yDim</span><span class="o">=</span><span class="n">yDim</span><span class="p">)</span></div>

<div class="viewcode-block" id="Spectrum.setPlaneData"><a class="viewcode-back" href="../../../ccpn/ccpn.core.html#ccpn.core.Spectrum.Spectrum.setPlaneData">[docs]</a>    <span class="k">def</span> <span class="nf">setPlaneData</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">position</span><span class="p">:</span> <span class="n">Sequence</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">xDim</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">yDim</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the plane data as defined by xDim, yDim and position (all 1-based).</span>

<span class="sd">        :param data: A 2-dimensional float32 numpy array in order (yDim, xDim)</span>
<span class="sd">        :param position: position: A list/tuple of point-positions (1-based)</span>
<span class="sd">        :param xDim: Dimension of the first axis (1-based)</span>
<span class="sd">        :param yDim: Dimension of the second axis (1-based)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensionCount</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Spectrum.gstPlaneData: dimensionality &lt; 2&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataSource</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;No proper (filePath, dataFormat) set for </span><span class="si">%s</span><span class="s1">; cannot set plane data&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">position</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataSource</span><span class="o">.</span><span class="n">checkForValidPlane</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="n">xDim</span><span class="o">=</span><span class="n">xDim</span><span class="p">,</span> <span class="n">yDim</span><span class="o">=</span><span class="n">yDim</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">RuntimeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">)</span> <span class="k">as</span> <span class="n">es</span><span class="p">:</span>
            <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;invalid arguments: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">es</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">es</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dataSource</span><span class="o">.</span><span class="n">setPlaneData</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="n">position</span><span class="p">,</span> <span class="n">xDim</span><span class="o">=</span><span class="n">xDim</span><span class="p">,</span> <span class="n">yDim</span><span class="o">=</span><span class="n">yDim</span><span class="p">)</span></div>

<div class="viewcode-block" id="Spectrum.extractPlaneToFile"><a class="viewcode-back" href="../../../ccpn/ccpn.core.html#ccpn.core.Spectrum.Spectrum.extractPlaneToFile">[docs]</a>    <span class="nd">@logCommand</span><span class="p">(</span><span class="n">get</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">extractPlaneToFile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axisCodes</span><span class="p">:</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">),</span> <span class="n">position</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dataFormat</span><span class="o">=</span><span class="s1">&#39;Hdf5&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Save a plane, defined by axisCodes and position, to path using dataFormat</span>
<span class="sd">        Dimensionality must be &gt;= 2</span>

<span class="sd">        :param axisCodes: tuple/list of two axisCodes</span>
<span class="sd">        :param position: a list/tuple of point-positions (1-based)</span>
<span class="sd">        :param path: path of the resulting file; auto-generated if None</span>
<span class="sd">        :param dataFormat: a data format valid for writing (default=&#39;Hdf5&#39;)</span>

<span class="sd">        :returns plane as Spectrum instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataSource</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">=</span> <span class="s1">&#39;No proper (filePath, dataFormat) set for </span><span class="si">%s</span><span class="s1">; unable to extract plane&#39;</span> <span class="o">%</span> <span class="bp">self</span>
            <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">axisCodes</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">axisCodes</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid parameter axisCodes &quot;</span><span class="si">%s</span><span class="s1">&quot;, should be two of </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">axisCodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axisCodes</span><span class="p">))</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">dimensions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getByAxisCodes</span><span class="p">(</span><span class="s1">&#39;dimensions&#39;</span><span class="p">,</span> <span class="n">axisCodes</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dataSource</span><span class="o">.</span><span class="n">checkForValidPlane</span><span class="p">(</span><span class="n">position</span><span class="o">=</span><span class="n">position</span><span class="p">,</span> <span class="n">xDim</span><span class="o">=</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">yDim</span><span class="o">=</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">newSpectrum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extractToFile</span><span class="p">(</span><span class="n">axisCodes</span><span class="o">=</span><span class="n">axisCodes</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="n">position</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="n">path</span><span class="p">,</span> <span class="n">dataFormat</span><span class="o">=</span><span class="n">dataFormat</span><span class="p">,</span>
                                              <span class="n">tag</span><span class="o">=</span><span class="s1">&#39;plane&#39;</span><span class="p">)</span>

        <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">RuntimeError</span><span class="p">)</span> <span class="k">as</span> <span class="n">es</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">=</span> <span class="s1">&#39;Spectrum.extractPlaneToFile: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">es</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">newSpectrum</span></div>

<div class="viewcode-block" id="Spectrum.getProjection"><a class="viewcode-back" href="../../../ccpn/ccpn.core.html#ccpn.core.Spectrum.Spectrum.getProjection">[docs]</a>    <span class="nd">@logCommand</span><span class="p">(</span><span class="n">get</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">getProjection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axisCodes</span><span class="p">:</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">),</span> <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;max&#39;</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PlaneData</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get projected plane defined by two axisCodes, using method and an optional threshold</span>

<span class="sd">        :param axisCodes: tuple/list of two axisCodes; expand if exactMatch=False</span>
<span class="sd">        :param method: &#39;max&#39;, &#39;max above threshold&#39;, &#39;min&#39;, &#39;min below threshold&#39;,</span>
<span class="sd">                       &#39;sum&#39;, &#39;sum above threshold&#39;, &#39;sum below threshold&#39;</span>
<span class="sd">        :param threshold: threshold value for relevant method</span>

<span class="sd">        :return: projected spectrum data as a PlaneData object (i.e. a 2D numpy.ndarray in order (yDim, xDim))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">projectedData</span> <span class="o">=</span> <span class="n">_getProjection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axisCodes</span><span class="o">=</span><span class="n">axisCodes</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">projectedData</span></div>

<div class="viewcode-block" id="Spectrum.extractProjectionToFile"><a class="viewcode-back" href="../../../ccpn/ccpn.core.html#ccpn.core.Spectrum.Spectrum.extractProjectionToFile">[docs]</a>    <span class="nd">@logCommand</span><span class="p">(</span><span class="n">get</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">extractProjectionToFile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axisCodes</span><span class="p">:</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">),</span> <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;max&#39;</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dataFormat</span><span class="o">=</span><span class="s1">&#39;Hdf5&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Save a projected plane, defined by axisCodes and position, using method and an optional threshold,</span>
<span class="sd">        to path using dataFormat</span>
<span class="sd">        Dimensionality must be &gt;= 2</span>

<span class="sd">        :param axisCodes: tuple/list of two axisCodes</span>
<span class="sd">        :param method: &#39;max&#39;, &#39;max above threshold&#39;, &#39;min&#39;, &#39;min below threshold&#39;,</span>
<span class="sd">                       &#39;sum&#39;, &#39;sum above threshold&#39;, &#39;sum below threshold&#39;</span>
<span class="sd">        :param threshold: threshold value for relevant method</span>
<span class="sd">        :param path: path of the resulting file; auto-generated if None</span>
<span class="sd">        :param dataFormat: a data format valid for writing</span>

<span class="sd">        :returns projected plane as Spectrum instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataSource</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">=</span> <span class="s1">&#39;No proper (filePath, dataFormat) set for </span><span class="si">%s</span><span class="s1">; unable to extract plane&#39;</span> <span class="o">%</span> <span class="bp">self</span>
            <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">axisCodes</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">axisCodes</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid parameter axisCodes &quot;</span><span class="si">%s</span><span class="s1">&quot;, should be two of </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">axisCodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axisCodes</span><span class="p">))</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">xDim</span><span class="p">,</span> <span class="n">yDim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getByAxisCodes</span><span class="p">(</span><span class="s1">&#39;dimensions&#39;</span><span class="p">,</span> <span class="n">axisCodes</span><span class="p">)</span>
            <span class="n">position</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensionCount</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dataSource</span><span class="o">.</span><span class="n">checkForValidPlane</span><span class="p">(</span><span class="n">position</span><span class="o">=</span><span class="n">position</span><span class="p">,</span> <span class="n">xDim</span><span class="o">=</span><span class="n">xDim</span><span class="p">,</span> <span class="n">yDim</span><span class="o">=</span><span class="n">yDim</span><span class="p">)</span>
            <span class="n">newSpectrum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extractToFile</span><span class="p">(</span><span class="n">axisCodes</span><span class="o">=</span><span class="n">axisCodes</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="n">position</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="n">path</span><span class="p">,</span> <span class="n">dataFormat</span><span class="o">=</span><span class="n">dataFormat</span><span class="p">,</span>
                                              <span class="n">tag</span><span class="o">=</span><span class="s1">&#39;projection&#39;</span><span class="p">)</span>
            <span class="n">projectionData</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getProjection</span><span class="p">(</span><span class="n">axisCodes</span><span class="o">=</span><span class="n">axisCodes</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">)</span>
            <span class="c1"># For writing, we need to remap the axisCodes onto the newSpectrum</span>
            <span class="n">xDim2</span><span class="p">,</span> <span class="n">yDim2</span> <span class="o">=</span> <span class="n">newSpectrum</span><span class="o">.</span><span class="n">getByAxisCodes</span><span class="p">(</span><span class="s1">&#39;dimensions&#39;</span><span class="p">,</span> <span class="n">axisCodes</span><span class="p">)</span>
            <span class="n">newSpectrum</span><span class="o">.</span><span class="n">dataSource</span><span class="o">.</span><span class="n">setPlaneData</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">projectionData</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="n">position</span><span class="p">,</span> <span class="n">xDim</span><span class="o">=</span><span class="n">xDim2</span><span class="p">,</span> <span class="n">yDim</span><span class="o">=</span><span class="n">yDim2</span><span class="p">)</span>

        <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">RuntimeError</span><span class="p">)</span> <span class="k">as</span> <span class="n">es</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">=</span> <span class="s1">&#39;Spectrum.extractProjectionToFile: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">es</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">newSpectrum</span></div>

<div class="viewcode-block" id="Spectrum.cloneAsHdf5"><a class="viewcode-back" href="../../../ccpn/ccpn.core.html#ccpn.core.Spectrum.Spectrum.cloneAsHdf5">[docs]</a>    <span class="nd">@logCommand</span><span class="p">(</span><span class="n">get</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">cloneAsHdf5</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="s1">&#39;_cloned&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Clone self and all peakLists as an Hdf5 type file</span>
<span class="sd">        :return: a Spectrum instance of the cloned spectrum</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">ccpn.core.lib.SpectrumDataSources.Hdf5SpectrumDataSource</span> <span class="kn">import</span> <span class="n">Hdf5SpectrumDataSource</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">hasValidPath</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Not valid path for </span><span class="si">%s</span><span class="s1"> &#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span>

        <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="n">suffix</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">path</span><span class="p">:</span>
            <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataSource</span><span class="o">.</span><span class="n">parentPath</span> <span class="o">/</span> <span class="n">name</span>
        <span class="n">suffix</span> <span class="o">=</span> <span class="n">Hdf5SpectrumDataSource</span><span class="o">.</span><span class="n">suffixes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">dataFormat</span> <span class="o">=</span> <span class="n">Hdf5SpectrumDataSource</span><span class="o">.</span><span class="n">dataFormat</span>

        <span class="n">dataStore</span> <span class="o">=</span> <span class="n">DataStore</span><span class="o">.</span><span class="n">newFromPath</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="n">path</span><span class="p">,</span>
                                          <span class="n">autoVersioning</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">withSuffix</span><span class="o">=</span><span class="n">suffix</span><span class="p">,</span>
                                          <span class="n">dataFormat</span><span class="o">=</span><span class="n">dataFormat</span><span class="p">)</span>

        <span class="c1"># Duplicate the data in an Hdf5 file</span>
        <span class="n">hdf5DataSource</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataSource</span><span class="o">.</span><span class="n">duplicateDataToHdf5</span><span class="p">(</span><span class="n">dataStore</span><span class="o">.</span><span class="n">aPath</span><span class="p">())</span>
        <span class="c1"># Update the dataSource parameters from self</span>
        <span class="c1"># hdf5DataSource.importFromSpectrum(self, includePath=False)</span>
        <span class="c1"># hdf5DataSource.writeParameters()</span>

        <span class="c1"># Create a new Spectrum instance</span>
        <span class="n">newSpectrum</span> <span class="o">=</span> <span class="n">_newSpectrumFromDataSource</span><span class="p">(</span><span class="n">project</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">project</span><span class="p">,</span>
                                                 <span class="n">dataStore</span><span class="o">=</span><span class="n">dataStore</span><span class="p">,</span>
                                                 <span class="n">dataSource</span><span class="o">=</span><span class="n">hdf5DataSource</span><span class="p">,</span>
                                                 <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>

        <span class="c1"># Copy the dimensional parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_copyDimensionalParameters</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axisCodes</span><span class="p">,</span> <span class="n">newSpectrum</span><span class="p">)</span>
        <span class="c1"># Copy/set some more parameters (e.g. noiseLevel)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_copyNonDimensionalParameters</span><span class="p">(</span><span class="n">newSpectrum</span><span class="p">)</span>
        <span class="n">newSpectrum</span><span class="o">.</span><span class="n">_updateParameterValues</span><span class="p">()</span>

        <span class="c1"># Copy the peakList/peaks</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">pl</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">peakLists</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">idx</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">newSpectrum</span><span class="o">.</span><span class="n">peakLists</span><span class="p">):</span>
                <span class="n">newSpectrum</span><span class="o">.</span><span class="n">newPeakList</span><span class="p">()</span>
            <span class="n">targetPl</span> <span class="o">=</span> <span class="n">newSpectrum</span><span class="o">.</span><span class="n">peakLists</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">pl</span><span class="o">.</span><span class="n">copyTo</span><span class="p">(</span><span class="n">targetSpectrum</span><span class="o">=</span><span class="n">newSpectrum</span><span class="p">,</span> <span class="n">targetPeakList</span><span class="o">=</span><span class="n">targetPl</span><span class="p">)</span>

        <span class="n">newSpectrum</span><span class="o">.</span><span class="n">appendComment</span><span class="p">(</span><span class="s1">&#39;Cloned from </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">newSpectrum</span></div>

    <span class="k">def</span> <span class="nf">_axisDictToSliceTuples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axisDict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Convert dict of (key,value) = (axisCode, (startPpm, stopPpm)) pairs</span>
<span class="sd">        to a list of (startPoint,stopPoint) sliceTuples (1-based) for each dimension</span>

<span class="sd">        if (axisDict[axisCode] is None) ==&gt; use spectrumLimits</span>
<span class="sd">        if (startPpm is None) ==&gt; point=1</span>
<span class="sd">        if (stopPpm is None) ==&gt; point=pointCounts[axis]</span>

<span class="sd">        :param axisDict: dict of (axisCode, (startPpm,stopPpm)) (key,value) pairs</span>
<span class="sd">        :return list of (startPoint,stopPoint) sliceTuples (1-based) for each dimension</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axisCodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">ac</span> <span class="k">for</span> <span class="n">ac</span> <span class="ow">in</span> <span class="n">axisDict</span><span class="o">.</span><span class="n">keys</span><span class="p">()]</span>

        <span class="c1"># augment axisDict with any missing axisCodes or replace any None values with spectrumLimits</span>
        <span class="n">inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getByAxisCodes</span><span class="p">(</span><span class="s1">&#39;dimensionIndices&#39;</span><span class="p">,</span> <span class="n">axisCodes</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">ac</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axisCodes</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">inds</span> <span class="ow">or</span> <span class="n">axisDict</span><span class="p">[</span><span class="n">ac</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">axisDict</span><span class="p">[</span><span class="n">ac</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrumLimits</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

        <span class="n">axisPpms</span> <span class="o">=</span> <span class="p">[</span><span class="n">ppm</span> <span class="k">for</span> <span class="n">ppm</span> <span class="ow">in</span> <span class="n">axisDict</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
        <span class="n">sliceTuples</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensionCount</span>
        <span class="k">for</span> <span class="n">dimIndex</span><span class="p">,</span> <span class="n">ac</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensionTriples</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">inds</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">dimIndex</span><span class="p">)</span>
            <span class="n">minPpm</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">axisPpms</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
            <span class="n">maxPpm</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">axisPpms</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>

            <span class="c1"># ppm axis runs backward</span>
            <span class="k">if</span> <span class="n">maxPpm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">startPoint</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">startPoint</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ppm2point</span><span class="p">(</span><span class="n">maxPpm</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">minPpm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">stopPoint</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointCounts</span><span class="p">[</span><span class="n">dimIndex</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">stopPoint</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ppm2point</span><span class="p">(</span><span class="n">minPpm</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span>

            <span class="n">sliceTuples</span><span class="p">[</span><span class="n">dimIndex</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">((</span><span class="n">startPoint</span><span class="p">,</span> <span class="n">stopPoint</span><span class="p">)))</span>

        <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Spectrum._axisDictToSliceTuples: axisDict = </span><span class="si">%s</span><span class="s1">; sliceTuples = </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span>
                          <span class="p">(</span><span class="n">axisDict</span><span class="p">,</span> <span class="n">sliceTuples</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">sliceTuples</span>

<div class="viewcode-block" id="Spectrum.getRegion"><a class="viewcode-back" href="../../../ccpn/ccpn.core.html#ccpn.core.Spectrum.Spectrum.getRegion">[docs]</a>    <span class="nd">@logCommand</span><span class="p">(</span><span class="n">get</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">getRegion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">axisDict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">RegionData</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the region of the spectrum data defined by the axis limits in ppm as a RegionData object,</span>
<span class="sd">        i.e. a numpy.ndarray of the same dimensionality as defined by the Spectrum instance.</span>

<span class="sd">        Axis limits  are passed in as a dict of (axisCode, tupleLimit) key, value pairs</span>
<span class="sd">        with the tupleLimit supplied as (startPpm,stopPpm) axis limits in ppm (lower ppm value first).</span>
<span class="sd">        For axisCodes that are not included in the axisDict, the limits will by taken from the</span>
<span class="sd">        spectrum limits along the relevant axis</span>
<span class="sd">        For axisCodes that are None, the limits will by taken from the spectrum limits along the</span>
<span class="sd">        relevant axis. Illegal axisCodes will raise an error.</span>

<span class="sd">        Example axisDict:</span>
<span class="sd">            {&#39;Hn&#39;: (7.0, 9.0), &#39;Nh&#39;: (110, 130)}</span>

<span class="sd">        Example calling function:</span>
<span class="sd">            regionData = spectrum.getRegion(**limitsDict)</span>
<span class="sd">            regionData = spectrum.getRegion(Hn=(7.0, 9.0), Nh=(110, 130))</span>

<span class="sd">        :param axisDict: dict of (axisCode, (startPpm,stopPpm)) key,value pairs</span>
<span class="sd">        :return: RegionData object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">hasValidPath</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Not valid path for </span><span class="si">%s</span><span class="s1"> &#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span>
        <span class="n">sliceTuples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_axisDictToSliceTuples</span><span class="p">(</span><span class="n">axisDict</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataSource</span><span class="o">.</span><span class="n">getRegionData</span><span class="p">(</span><span class="n">sliceTuples</span><span class="p">,</span> <span class="n">aliasingFlags</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensionCount</span><span class="p">)</span></div>

<div class="viewcode-block" id="Spectrum.createPeak"><a class="viewcode-back" href="../../../ccpn/ccpn.core.html#ccpn.core.Spectrum.Spectrum.createPeak">[docs]</a>    <span class="nd">@logCommand</span><span class="p">(</span><span class="n">get</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">createPeak</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">peakList</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">ppmPositions</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="s1">&#39;Peak&#39;</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Create and return peak at position specified by the ppmPositions dict.</span>

<span class="sd">        Ppm positions are passed in as a dict of (axisCode, ppmValue) key, value pairs</span>
<span class="sd">        with the ppmValue supplied mapping to the closest matching axis.</span>
<span class="sd">        Illegal or non-matching axisCodes will return None.</span>

<span class="sd">        Example ppmPosition dict:</span>
<span class="sd">            {&#39;Hn&#39;: 7.0, &#39;Nh&#39;: 110}</span>

<span class="sd">        Example calling function:</span>
<span class="sd">        &gt;&gt;&gt; peak = spectrum.createPeak(**ppmPositions)</span>
<span class="sd">        &gt;&gt;&gt; peak = spectrum.createPeak(peakList, **ppmPositions)</span>
<span class="sd">        &gt;&gt;&gt; peak = spectrum.createPeak(peakList=peakList, Hn=7.0, Nh=110)</span>

<span class="sd">        :param peakList: peakList to create new peak in, or None for the last peakList belonging to spectrum</span>
<span class="sd">        :param ppmPositions: dict of (axisCode, ppmValue) key,value pairs</span>
<span class="sd">        :return: new peak or None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">ccpn.core.lib.SpectrumLib</span> <span class="kn">import</span> <span class="n">_createPeak</span>
        <span class="k">return</span> <span class="n">_createPeak</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">peakList</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="n">height</span><span class="p">,</span> <span class="o">**</span><span class="n">ppmPositions</span><span class="p">)</span></div>

<div class="viewcode-block" id="Spectrum.pickPeaks"><a class="viewcode-back" href="../../../ccpn/ccpn.core.html#ccpn.core.Spectrum.Spectrum.pickPeaks">[docs]</a>    <span class="nd">@logCommand</span><span class="p">(</span><span class="n">get</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">pickPeaks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">peakList</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">positiveThreshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">negativeThreshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">ppmRegions</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Pick peaks in the region defined by the ppmRegions dict.</span>

<span class="sd">        Ppm regions are passed in as a dict containing the axis codes and the required limits.</span>
<span class="sd">        Each limit is defined as a key, value pair: (str, tuple), with the tuple supplied as (min, max) axis limits in ppm.</span>
<span class="sd">        Axis codes supplied are mapped to the closest matching axis.</span>
<span class="sd">        Illegal or non-matching axisCodes will return None.</span>

<span class="sd">        Example ppmRegions dict:</span>
<span class="sd">            {&#39;Hn&#39;: (7.0, 9.0), &#39;Nh&#39;: (110, 130)}</span>

<span class="sd">        Example calling function:</span>
<span class="sd">        &gt;&gt;&gt; peaks = spectrum.pickPeaks(**ppmRegions)</span>
<span class="sd">        &gt;&gt;&gt; peaks = spectrum.pickPeaks(peakList, **ppmRegions)</span>
<span class="sd">        &gt;&gt;&gt; peaks = spectrum.pickPeaks(peakList=peakList, Hn=(7.0, 9.0), Nh=(110, 130))</span>

<span class="sd">        :param peakList: peakList to create new peak in, or None for the last peakList belonging to spectrum</span>
<span class="sd">        :param positiveThreshold: float or None specifying the positive threshold above which to find peaks.</span>
<span class="sd">                                  if None, positive peak picking is disabled.</span>
<span class="sd">        :param negativeThreshold: float or None specifying the negative threshold below which to find peaks.</span>
<span class="sd">                                  if None, negative peak picking is disabled.</span>
<span class="sd">        :param ppmRegions: dict of (axisCode, tupleValue) key, value pairs</span>
<span class="sd">        :return: tuple of new Peak instances</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">ccpn.core.PeakList</span> <span class="kn">import</span> <span class="n">PeakList</span>
        <span class="kn">from</span> <span class="nn">ccpn.core.lib.SpectrumLib</span> <span class="kn">import</span> <span class="n">_pickPeaksByRegion</span>

        <span class="n">peakList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">project</span><span class="o">.</span><span class="n">getByPid</span><span class="p">(</span><span class="n">peakList</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">peakList</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">peakList</span>
        <span class="k">if</span> <span class="n">peakList</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">peakList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peakLists</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">peakList</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">peakList</span><span class="p">,</span> <span class="n">PeakList</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">.pickPeaks: required peakList instance, got:</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">peakList</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="c1"># get the dimensions by mapping the keys of the ppmRegions dict</span>
        <span class="n">_axisCodes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">ppmRegions</span><span class="o">.</span><span class="n">keys</span><span class="p">()])</span>
        <span class="n">dimensions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getByAxisCodes</span><span class="p">(</span><span class="s1">&#39;dimensions&#39;</span><span class="p">,</span> <span class="n">_axisCodes</span><span class="p">)</span>
        <span class="c1"># now get all other parameters in dimensions order</span>
        <span class="n">axisCodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getByDimensions</span><span class="p">(</span><span class="s1">&#39;axisCodes&#39;</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">)</span>
        <span class="n">ppmValues</span> <span class="o">=</span> <span class="p">[</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">region</span><span class="p">)</span> <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="n">ppmRegions</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
        <span class="n">ppmValues</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">orderByDimensions</span><span class="p">(</span><span class="n">ppmValues</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">)</span> <span class="c1"># now sorted in order of dimensions</span>

        <span class="n">axisDict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">axisCode</span><span class="p">,</span> <span class="n">region</span><span class="p">)</span> <span class="k">for</span> <span class="n">axisCode</span><span class="p">,</span> <span class="n">region</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">axisCodes</span><span class="p">,</span> <span class="n">ppmValues</span><span class="p">))</span>
        <span class="n">sliceTuples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_axisDictToSliceTuples</span><span class="p">(</span><span class="n">axisDict</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">_pickPeaksByRegion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                  <span class="n">sliceTuples</span><span class="o">=</span> <span class="n">sliceTuples</span><span class="p">,</span> <span class="n">peakList</span><span class="o">=</span><span class="n">peakList</span><span class="p">,</span>
                                  <span class="n">positiveThreshold</span><span class="o">=</span><span class="n">positiveThreshold</span><span class="p">,</span> <span class="n">negativeThreshold</span><span class="o">=</span><span class="n">negativeThreshold</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_extractToFile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axisCodes</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">dataFormat</span><span class="p">,</span> <span class="n">tag</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Local helper routine to prevent code duplication across extractSliceToFile, extractPlaneToFile,</span>
<span class="sd">        extractProjectionToFile.</span>
<span class="sd">        :return: new Spectrum instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dimensions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getByAxisCodes</span><span class="p">(</span><span class="s1">&#39;dimensions&#39;</span><span class="p">,</span> <span class="n">axisCodes</span><span class="p">)</span>

        <span class="n">dataFormats</span> <span class="o">=</span> <span class="n">getDataFormats</span><span class="p">()</span>
        <span class="n">validFormats</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="o">.</span><span class="n">dataFormat</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">dataFormats</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">hasWritingAbility</span><span class="p">]</span>
        <span class="n">klass</span> <span class="o">=</span> <span class="n">dataFormats</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">dataFormat</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">klass</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid dataFormat </span><span class="si">%r</span><span class="s1">; must be one of </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">dataFormat</span><span class="p">,</span> <span class="n">validFormats</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">klass</span><span class="o">.</span><span class="n">hasWritingAbility</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unable to write to dataFormat </span><span class="si">%r</span><span class="s1">; must be one of </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">dataFormat</span><span class="p">,</span> <span class="n">validFormats</span><span class="p">))</span>
        <span class="n">suffix</span> <span class="o">=</span> <span class="n">klass</span><span class="o">.</span><span class="n">suffixes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">klass</span><span class="o">.</span><span class="n">suffixes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="s1">&#39;.dat&#39;</span>

        <span class="n">tagStr</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">_</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">axisCodes</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">appendToFilename</span> <span class="o">=</span> <span class="s1">&#39;_</span><span class="si">%s</span><span class="s1">_</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">tagStr</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">position</span><span class="p">]))</span>
            <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataSource</span><span class="o">.</span><span class="n">parentPath</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="n">appendToFilename</span>

        <span class="n">dataStore</span> <span class="o">=</span> <span class="n">DataStore</span><span class="o">.</span><span class="n">newFromPath</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="n">path</span><span class="p">,</span>
                                          <span class="n">autoVersioning</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">withSuffix</span><span class="o">=</span><span class="n">suffix</span><span class="p">,</span>
                                          <span class="n">dataFormat</span><span class="o">=</span><span class="n">klass</span><span class="o">.</span><span class="n">dataFormat</span><span class="p">)</span>

        <span class="n">newSpectrum</span> <span class="o">=</span> <span class="n">_extractRegionToFile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">=</span><span class="n">dimensions</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="n">position</span><span class="p">,</span> <span class="n">dataStore</span><span class="o">=</span><span class="n">dataStore</span><span class="p">)</span>

        <span class="c1"># add some comment as to the origin of the data</span>
        <span class="n">comment</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> at (</span><span class="si">%s</span><span class="s1">) from </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">tagStr</span><span class="p">,</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">position</span><span class="p">]),</span> <span class="bp">self</span><span class="p">)</span>
        <span class="n">newSpectrum</span><span class="o">.</span><span class="n">appendComment</span><span class="p">(</span><span class="n">comment</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">newSpectrum</span>

<div class="viewcode-block" id="Spectrum.setPeakAliasing"><a class="viewcode-back" href="../../../ccpn/ccpn.core.html#ccpn.core.Spectrum.Spectrum.setPeakAliasing">[docs]</a>    <span class="nd">@logCommand</span><span class="p">(</span><span class="n">get</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">setPeakAliasing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">peaks</span><span class="p">,</span> <span class="n">aliasingIndexes</span><span class="p">,</span> <span class="n">updateSpectrumAliasingIndexes</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the peak aliasing for a set of peaks in the spectrum</span>

<span class="sd">        Peaks is an iterable of type str of Peak - bad strings are ignored</span>
<span class="sd">        Core objects that are not of type Peak will raise error</span>

<span class="sd">        :param peaks:</span>
<span class="sd">        :param aliasingIndexes: tuple(int, int)</span>
<span class="sd">        :param updateSpectrumAliasingIndexes: True/False</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># avoid circular import</span>
        <span class="kn">from</span> <span class="nn">ccpn.core.Peak</span> <span class="kn">import</span> <span class="n">Peak</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">pks</span> <span class="o">:=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">project</span><span class="o">.</span><span class="n">getByPid</span><span class="p">(</span><span class="n">pk</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pk</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">pk</span> <span class="k">for</span> <span class="n">pk</span> <span class="ow">in</span> <span class="n">peaks</span><span class="p">)</span> <span class="o">-</span> <span class="p">{</span><span class="kc">None</span><span class="p">}):</span>
            <span class="k">for</span> <span class="n">pk</span> <span class="ow">in</span> <span class="n">pks</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pk</span><span class="p">,</span> <span class="n">Peak</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Spectrum.setPeakAliasing: peaks must all be of type Peak&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">pk</span> <span class="ow">in</span> <span class="n">pkList</span><span class="o">.</span><span class="n">peaks</span> <span class="k">for</span> <span class="n">pkList</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">peakLists</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Spectrum.setPeakAliasing: peaks must belong to one of spectrum.peakLists&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">aliasingIndexes</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">aliasingIndexes</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensionCount</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Spectrum.setPeakAliasing: aliasingIndexes must be tuple/list of length </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensionCount</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="o">-</span><span class="n">MAXALIASINGRANGE</span> <span class="o">&lt;=</span> <span class="n">aa</span> <span class="o">&lt;=</span> <span class="n">MAXALIASINGRANGE</span> <span class="k">for</span> <span class="n">aa</span> <span class="ow">in</span> <span class="n">aliasingIndexes</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Spectrum.setPeakAliasing: aliasingIndexes must be in range [</span><span class="si">{</span><span class="o">-</span><span class="n">MAXALIASINGRANGE</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="n">MAXALIASINGRANGE</span><span class="si">}</span><span class="s1">]&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">updateSpectrumAliasingIndexes</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Spectrum.setPeakAliasing: updateSpectrumAliasingIndexes must be True/False&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">updateSpectrumAliasingIndexes</span><span class="p">:</span>
                <span class="c1"># update the aliasing limits for the spectrum</span>
                <span class="n">aliasInds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aliasingIndexes</span>
                <span class="n">folding</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">foldingLimits</span>
                <span class="n">widths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectralWidths</span>

                <span class="n">newLimits</span> <span class="o">=</span> <span class="p">[(</span><span class="nb">min</span><span class="p">(</span><span class="n">fold</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="o">*</span><span class="n">aa</span><span class="p">,</span> <span class="n">newAl</span><span class="p">)</span> <span class="o">*</span> <span class="n">width</span><span class="p">),</span>
                              <span class="nb">max</span><span class="p">(</span><span class="n">fold</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="o">*</span><span class="n">aa</span><span class="p">,</span> <span class="n">newAl</span><span class="p">)</span> <span class="o">*</span> <span class="n">width</span><span class="p">))</span>
                             <span class="k">for</span> <span class="n">dim</span><span class="p">,</span> <span class="p">(</span><span class="n">aa</span><span class="p">,</span> <span class="n">fold</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">newAl</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">aliasInds</span><span class="p">,</span> <span class="n">folding</span><span class="p">,</span> <span class="n">widths</span><span class="p">,</span> <span class="n">aliasingIndexes</span><span class="p">))]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">aliasingLimits</span> <span class="o">=</span> <span class="n">newLimits</span>

            <span class="k">for</span> <span class="n">pk</span> <span class="ow">in</span> <span class="n">pks</span><span class="p">:</span>
                <span class="n">pk</span><span class="o">.</span><span class="n">aliasing</span> <span class="o">=</span> <span class="n">aliasingIndexes</span></div>

    <span class="c1">#-----------------------------------------------------------------------------------------</span>
    <span class="c1"># Iterators</span>
    <span class="c1">#-----------------------------------------------------------------------------------------</span>

<div class="viewcode-block" id="Spectrum.allPlanes"><a class="viewcode-back" href="../../../ccpn/ccpn.core.html#ccpn.core.Spectrum.Spectrum.allPlanes">[docs]</a>    <span class="k">def</span> <span class="nf">allPlanes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axisCodes</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">exactMatch</span><span class="p">:</span><span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;An iterator over all planes defined by axisCodes, yielding (positions, data-array) tuples.</span>

<span class="sd">        :param axisCodes: a tuple/list of two axisCodes defining the plane</span>
<span class="sd">        :param exactMatch: match the axisCodes if True</span>
<span class="sd">        :return: iterator (position, data-array); position is a (1-based) tuple of length dimensionCount</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axisCodes</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid axisCodes </span><span class="si">%s</span><span class="s1">, len should be 2&#39;</span> <span class="o">%</span> <span class="n">axisCodes</span><span class="p">)</span>

        <span class="n">axisDims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getByAxisCodes</span><span class="p">(</span><span class="s1">&#39;dimensions&#39;</span><span class="p">,</span> <span class="n">axisCodes</span><span class="p">,</span> <span class="n">exactMatch</span><span class="o">=</span><span class="n">exactMatch</span><span class="p">)</span>  <span class="c1"># check and optionally expand axisCodes</span>
        <span class="k">if</span> <span class="n">axisDims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">axisDims</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid axisCodes </span><span class="si">%s</span><span class="s1">; identical&#39;</span> <span class="o">%</span> <span class="n">axisCodes</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">hasValidPath</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Not valid path for </span><span class="si">%s</span><span class="s1"> &#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataSource</span><span class="o">.</span><span class="n">allPlanes</span><span class="p">(</span><span class="n">xDim</span><span class="o">=</span><span class="n">axisDims</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">yDim</span><span class="o">=</span><span class="n">axisDims</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span></div>

<div class="viewcode-block" id="Spectrum.allSlices"><a class="viewcode-back" href="../../../ccpn/ccpn.core.html#ccpn.core.Spectrum.Spectrum.allSlices">[docs]</a>    <span class="k">def</span> <span class="nf">allSlices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axisCode</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span> <span class="n">exactMatch</span><span class="p">:</span><span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;An iterator over all slices defined by axisCode, yielding (positions, data-array) tuples.</span>

<span class="sd">        :param axisCode: an axisCodes defining the slice</span>
<span class="sd">        :param exactMatch: match the axisCodes if True</span>
<span class="sd">        :return: iterator (position, data-array); position is a (1-based) tuple of length dimensionCount</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sliceDim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getByAxisCodes</span><span class="p">(</span><span class="s1">&#39;dimensions&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">axisCode</span><span class="p">],</span> <span class="n">exactMatch</span><span class="o">=</span><span class="n">exactMatch</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">hasValidPath</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Not valid path for </span><span class="si">%s</span><span class="s1"> &#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataSource</span><span class="o">.</span><span class="n">allSlices</span><span class="p">(</span><span class="n">sliceDim</span><span class="o">=</span><span class="n">sliceDim</span><span class="p">)</span></div>

<div class="viewcode-block" id="Spectrum.allPoints"><a class="viewcode-back" href="../../../ccpn/ccpn.core.html#ccpn.core.Spectrum.Spectrum.allPoints">[docs]</a>    <span class="k">def</span> <span class="nf">allPoints</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;An iterator over all points yielding (positions, pointValue) tuples.</span>

<span class="sd">        :return: iterator (position, data-array); position is a (1-based) tuple of length dimensionCount</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">hasValidPath</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Not valid path for </span><span class="si">%s</span><span class="s1"> &#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataSource</span><span class="o">.</span><span class="n">allPoints</span><span class="p">()</span></div>

    <span class="c1">#-----------------------------------------------------------------------------------------</span>
    <span class="c1"># Implementation properties and functions</span>
    <span class="c1">#-----------------------------------------------------------------------------------------</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_serial</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the _wrappedData serial</span>
<span class="sd">        CCPN Internal</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">serial</span>

    <span class="k">def</span> <span class="nf">_getDataSourceFromPath</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">dataFormat</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">checkParameters</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return a (dataStore, dataSource) tuple if path points  a file compatible</span>
<span class="sd">        with dataFormat, or (None, None) otherwise.</span>

<span class="sd">        :param path: path to check, may contain redirections</span>
<span class="sd">        :param dataFormat: dataFormat string (default to self.dataFormat if None)</span>
<span class="sd">        :param checkParameters: Flag to invoke checking of parameters of dataSource to match those of the self</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dataFormat</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dataFormat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataFormat</span>

        <span class="n">dataStore</span> <span class="o">=</span> <span class="n">DataStore</span><span class="o">.</span><span class="n">newFromPath</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="n">path</span><span class="p">,</span> <span class="n">dataFormat</span><span class="o">=</span><span class="n">dataFormat</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">dataStore</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
            <span class="k">return</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">dataStore</span><span class="o">.</span><span class="n">spectrum</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">dataSource</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getDataSource</span><span class="p">(</span><span class="n">dataStore</span><span class="p">,</span> <span class="n">checkParameters</span><span class="o">=</span><span class="n">checkParameters</span><span class="p">)</span>

        <span class="k">except</span> <span class="ne">RuntimeError</span> <span class="k">as</span> <span class="n">es</span><span class="p">:</span>
            <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;_getDataSourceFromPath: caught error: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">es</span><span class="p">))</span>
            <span class="k">return</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">dataStore</span><span class="p">,</span> <span class="n">dataSource</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_getDataSource</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataStore</span><span class="p">,</span> <span class="n">checkParameters</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check the validity and access the file defined by dataStore;</span>
<span class="sd">        :param dataStore: A dataStore instance, defining a path, dataFormat and optional buffering</span>
<span class="sd">        :param checkParameters: flag to check essential parameters of the dataSource with the parameters of self (a Spectrum)</span>
<span class="sd">        :return SpectrumDataSource instance when path and/or dataFormat of the dataStore instance define something valid</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">dataStore</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;dataStore is not defined&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dataStore</span><span class="p">,</span> <span class="n">DataStore</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;dataStore has invalid type; got: </span><span class="si">{</span><span class="n">dataStore</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">dataStore</span><span class="o">.</span><span class="n">dataFormat</span> <span class="o">==</span> <span class="n">EmptySpectrumDataSource</span><span class="o">.</span><span class="n">dataFormat</span><span class="p">:</span>
            <span class="c1"># Special case, empty spectrum</span>
            <span class="n">dataSource</span> <span class="o">=</span> <span class="n">EmptySpectrumDataSource</span><span class="p">()</span>
            <span class="n">dataSource</span><span class="o">.</span><span class="n">importFromSpectrum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">includePath</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">checkParameters</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">elif</span> <span class="n">dataStore</span><span class="o">.</span><span class="n">dataFormat</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Special case, we do not (yet) know the dataFormat; this may occur due to Nef import</span>
            <span class="c1"># Attempt to get a dataSource from path alone</span>
            <span class="n">_path</span> <span class="o">=</span> <span class="n">dataStore</span><span class="o">.</span><span class="n">aPath</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">_path</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Spectrum._getDataSource: dataStore path &quot;</span><span class="si">{</span><span class="n">_path</span><span class="si">}</span><span class="s1">&quot; does not exist&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">dataSource</span> <span class="o">:=</span> <span class="n">checkPathForSpectrumFormats</span><span class="p">(</span><span class="n">_path</span><span class="p">))</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Spectrum._getDataSource: error for path &quot;</span><span class="si">{</span><span class="n">_path</span><span class="si">}</span><span class="s1">&quot; with undefined dataFormat&#39;</span><span class="p">)</span>

            <span class="c1"># found a valid dataSource</span>
            <span class="n">dataStore</span><span class="o">.</span><span class="n">dataFormat</span> <span class="o">=</span> <span class="n">dataSource</span><span class="o">.</span><span class="n">dataFormat</span>
            <span class="n">dataStore</span><span class="o">.</span><span class="n">_saveInternal</span><span class="p">()</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Regular case: We have a dataStore with a path and dataFormat</span>

            <span class="c1"># Check the dataFormat</span>
            <span class="n">validFormats</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">getDataFormats</span><span class="p">()</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dataStore</span><span class="o">.</span><span class="n">dataFormat</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="n">dataStore</span><span class="o">.</span><span class="n">dataFormat</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">validFormats</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;invalid dataFormat </span><span class="si">%r</span><span class="s1">; should be one of </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">dataStore</span><span class="o">.</span><span class="n">dataFormat</span><span class="p">,</span> <span class="n">validFormats</span><span class="p">))</span>

            <span class="n">_path</span> <span class="o">=</span> <span class="n">dataStore</span><span class="o">.</span><span class="n">aPath</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">_path</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Spectrum._getDataSource: dataStore path &quot;</span><span class="si">{</span><span class="n">_path</span><span class="si">}</span><span class="s1">&quot; does not exist&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">dataSource</span> <span class="o">:=</span> <span class="n">getSpectrumDataSource</span><span class="p">(</span><span class="n">_path</span><span class="p">,</span> <span class="n">dataStore</span><span class="o">.</span><span class="n">dataFormat</span><span class="p">))</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Spectrum._getDataSource: error for path &quot;</span><span class="si">{</span><span class="n">_path</span><span class="si">}</span><span class="s1">&quot; with dataFormat &quot;</span><span class="si">{</span><span class="n">dataStore</span><span class="o">.</span><span class="n">dataFormat</span><span class="si">}</span><span class="s1">&quot;&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">dataStore</span><span class="o">.</span><span class="n">useBuffer</span><span class="p">:</span>
            <span class="n">dataSource</span><span class="o">.</span><span class="n">setBuffering</span><span class="p">(</span><span class="n">isBuffered</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">bufferIsTemporary</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">checkParameters</span><span class="p">:</span>
            <span class="c1"># check some fundamental parameters</span>
            <span class="k">if</span> <span class="n">dataSource</span><span class="o">.</span><span class="n">dimensionCount</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensionCount</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Spectrum._getDataSource: incompatible dimensionCount (</span><span class="si">%s</span><span class="s1">) of &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span>
                                   <span class="p">(</span><span class="n">dataSource</span><span class="o">.</span><span class="n">dimensionCount</span><span class="p">,</span> <span class="n">dataStore</span><span class="o">.</span><span class="n">aPath</span><span class="p">()))</span>

            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">np</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pointCounts</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">dataSource</span><span class="o">.</span><span class="n">pointCounts</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">!=</span> <span class="n">np</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Spectrum._getDataSource: incompatible pointsCount[</span><span class="si">%s</span><span class="s1">] = </span><span class="si">%s</span><span class="s1"> of &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span>
                                       <span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">dataSource</span><span class="o">.</span><span class="n">pointCounts</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">dataStore</span><span class="o">.</span><span class="n">aPath</span><span class="p">()))</span>

            <span class="k">for</span> <span class="n">isC_spectrum</span><span class="p">,</span> <span class="n">isC_dataSource</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">isComplex</span><span class="p">,</span> <span class="n">dataSource</span><span class="o">.</span><span class="n">isComplex</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">isC_spectrum</span> <span class="o">!=</span> <span class="n">isC_dataSource</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Spectrum._getDataSource: incompatible isComplex definitions; </span><span class="si">%s</span><span class="s1"> has </span><span class="si">%r</span><span class="s1"> ; </span><span class="si">%s</span><span class="s1"> has </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span>
                                       <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">isComplex</span><span class="p">,</span> <span class="n">dataSource</span><span class="p">,</span> <span class="n">dataSource</span><span class="o">.</span><span class="n">isComplex</span><span class="p">))</span>

        <span class="n">dataSource</span><span class="o">.</span><span class="n">spectrum</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">dataSource</span>

    <span class="k">def</span> <span class="nf">_getPeakPicker</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check whether a peakPicker class has been saved with this spectrum.</span>
<span class="sd">        Returns new peakPicker instance or None if cannot be defined</span>
<span class="sd">        CCPNINTERNAL: also used in SpectrumTraits._restoreFromSpectrum</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">ccpn.core.lib.SpectrumLib</span> <span class="kn">import</span> <span class="n">fetchPeakPicker</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">peakPicker</span> <span class="o">:=</span> <span class="n">fetchPeakPicker</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">peakPicker</span> <span class="o">=</span> <span class="n">peakPicker</span>
        <span class="k">return</span> <span class="n">peakPicker</span>

    <span class="k">def</span> <span class="nf">_updateParameterValues</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This method check, and if needed updates specific parameter values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Quietly set some values</span>
        <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">debug2</span><span class="p">(</span><span class="s1">&#39;Updating </span><span class="si">%s</span><span class="s1"> parameters&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">inactivity</span><span class="p">():</span>
            <span class="c1"># getting the noiseLevel by calling estimateNoise() if not defined</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">noiseLevel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">noiseLevel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimateNoise</span><span class="p">()</span>

            <span class="c1"># Check  contourLevels, contourColours</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">positiveContourCount</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">negativeContourCount</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_setDefaultContourValues</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_setDefaultContourColours</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">sliceColour</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sliceColour</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">positiveContourColour</span>

    <span class="k">def</span> <span class="nf">_saveObject</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Update any setting before saving to API XML</span>
<span class="sd">        #CCPNINTERNAL: called in Project.save()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># The is needed as nef-initiated loading may have scuppered the</span>
        <span class="c1"># references to the internal data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_spectrumTraits</span><span class="o">.</span><span class="n">_storeToSpectrum</span><span class="p">()</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_restoreObject</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">project</span><span class="p">,</span> <span class="n">apiObj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Subclassed to allow for initialisations on restore, not on creation via newSpectrum</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">spectrum</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_restoreObject</span><span class="p">(</span><span class="n">project</span><span class="p">,</span> <span class="n">apiObj</span><span class="p">)</span>
        <span class="c1">#</span>
        <span class="c1"># # NOTE - version 3.0.4 -&gt; 3.1.0 update was executed by the wrapper</span>
        <span class="c1"># # move parameters from _ccpnInternal to the correct namespace, delete old parameters</span>

        <span class="c1"># This will set all Spectrum traits, including dataStore, dataSource and peakPicker</span>
        <span class="n">spectrum</span><span class="o">.</span><span class="n">_spectrumTraits</span><span class="o">.</span><span class="n">_restoreFromSpectrum</span><span class="p">()</span>

        <span class="c1"># Assure at least one peakList</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spectrum</span><span class="o">.</span><span class="n">peakLists</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">spectrum</span><span class="o">.</span><span class="n">newPeakList</span><span class="p">()</span>
            <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> had no peakList; created one&#39;</span> <span class="o">%</span> <span class="n">spectrum</span><span class="p">)</span>

        <span class="c1"># This will fix any spurious settings on the aliasing (also in update_3_0_4 code)</span>
        <span class="n">_aIndices</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">aliasingIndices</span>
        <span class="n">spectrum</span><span class="o">.</span><span class="n">aliasingIndices</span> <span class="o">=</span> <span class="n">_aIndices</span>

        <span class="c1"># Assure a setting of crucial attributes</span>
        <span class="n">spectrum</span><span class="o">.</span><span class="n">_updateParameterValues</span><span class="p">()</span>

        <span class="c1"># save the spectrum metadata</span>
        <span class="n">spectrum</span><span class="o">.</span><span class="n">_saveSpectrumMetaData</span><span class="p">()</span>

        <span class="c1"># set the initial axis ordering</span>
        <span class="n">specLib</span><span class="o">.</span><span class="n">_getDefaultOrdering</span><span class="p">(</span><span class="n">spectrum</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">spectrum</span>

<div class="viewcode-block" id="Spectrum.rename"><a class="viewcode-back" href="../../../ccpn/ccpn.core.html#ccpn.core.Spectrum.Spectrum.rename">[docs]</a>    <span class="nd">@renameObject</span><span class="p">()</span>
    <span class="nd">@logCommand</span><span class="p">(</span><span class="n">get</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">rename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Rename Spectrum, changing its name and Pid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_deleteSpectrumMetaData</span><span class="p">()</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rename</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_saveSpectrumMetaData</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_metaDataPath</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the path to the metadata file</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_tmpPath</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">project</span><span class="o">.</span><span class="n">statePath</span><span class="o">.</span><span class="n">fetchDir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pluralLinkName</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_tmpPath</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;.json&#39;</span>

    <span class="k">def</span> <span class="nf">_saveSpectrumMetaData</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Save the spectrum metadata in the project/state/spectra in json file for optional future reference</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metaDataPath</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s1">: Unable to save metadata; undefined path&#39;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_path</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
            <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s1">: Unable to save metadata to </span><span class="si">{</span><span class="n">_path</span><span class="o">.</span><span class="n">parent</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># Only save (and possibly overwrite) if we have valid data</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dataStore</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">dataSource</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_spectrumTraits</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">_path</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_restoreFromSpectrumMetaData</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Retore the spectrum metadata from the project/state/spectra json file</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_spectrumTraits</span><span class="o">.</span><span class="n">restore</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_metaDataPath</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dataStore</span><span class="o">.</span><span class="n">spectrum</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dataStore</span><span class="o">.</span><span class="n">_saveInternal</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataSource</span><span class="o">.</span><span class="n">spectrum</span> <span class="o">=</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_deleteSpectrumMetaData</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Delete the spectrum metadata in the project/state/spectra</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metaDataPath</span>
        <span class="k">if</span> <span class="n">_path</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
            <span class="n">_path</span><span class="o">.</span><span class="n">removeFile</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_finaliseAction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">action</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Subclassed to handle associated spectrumViews instances</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_finaliseAction</span><span class="p">(</span><span class="n">action</span><span class="p">):</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">action</span> <span class="o">==</span> <span class="s1">&#39;create&#39;</span><span class="p">:</span>
            <span class="c1"># No need; done by _newSpectrum</span>
            <span class="c1"># self._saveSpectrumMetaData()</span>
            <span class="k">pass</span>

        <span class="k">if</span> <span class="n">action</span> <span class="o">==</span> <span class="s1">&#39;delete&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_deleteSpectrumMetaData</span><span class="p">()</span>

        <span class="c1"># notify peak/integral/multiplet list</span>
        <span class="k">if</span> <span class="n">action</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;create&#39;</span><span class="p">,</span> <span class="s1">&#39;delete&#39;</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">peakList</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">peakLists</span><span class="p">:</span>
                <span class="n">peakList</span><span class="o">.</span><span class="n">_finaliseAction</span><span class="p">(</span><span class="n">action</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">multipletList</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">multipletLists</span><span class="p">:</span>
                <span class="n">multipletList</span><span class="o">.</span><span class="n">_finaliseAction</span><span class="p">(</span><span class="n">action</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">integralList</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">integralLists</span><span class="p">:</span>
                <span class="n">integralList</span><span class="o">.</span><span class="n">_finaliseAction</span><span class="p">(</span><span class="n">action</span><span class="p">)</span>

        <span class="c1"># propagate the rename to associated spectrumViews</span>
        <span class="k">if</span> <span class="n">action</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;change&#39;</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">specView</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrumViews</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">specView</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scaleChanged</span><span class="p">:</span>
                        <span class="c1"># force a rebuild of the contours/etc.</span>
                        <span class="n">specView</span><span class="o">.</span><span class="n">buildContoursOnly</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">specView</span><span class="o">.</span><span class="n">_finaliseAction</span><span class="p">(</span><span class="n">action</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scaleChanged</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_scaleChanged</span> <span class="o">=</span> <span class="kc">False</span>

                <span class="c1"># notify peaks/multiplets/integrals that the scale has changed</span>
                <span class="k">for</span> <span class="n">peakList</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">peakLists</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">peakList</span><span class="o">.</span><span class="n">peaks</span><span class="p">:</span>
                        <span class="n">peak</span><span class="o">.</span><span class="n">_finaliseAction</span><span class="p">(</span><span class="n">action</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">multipletList</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">multipletLists</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">multiplet</span> <span class="ow">in</span> <span class="n">multipletList</span><span class="o">.</span><span class="n">multiplets</span><span class="p">:</span>
                        <span class="n">multiplet</span><span class="o">.</span><span class="n">_finaliseAction</span><span class="p">(</span><span class="n">action</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">integralList</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">integralLists</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">integral</span> <span class="ow">in</span> <span class="n">integralList</span><span class="o">.</span><span class="n">integrals</span><span class="p">:</span>
                        <span class="n">integral</span><span class="o">.</span><span class="n">_finaliseAction</span><span class="p">(</span><span class="n">action</span><span class="p">)</span>

            <span class="c1"># from ccpn.ui.gui.lib.OpenGL.CcpnOpenGL import GLNotifier</span>
            <span class="c1">#</span>
            <span class="c1"># GLSignals = GLNotifier(parent=self)</span>
            <span class="c1"># GLSignals.emitPaintEvent()</span>

    <span class="nd">@cached</span><span class="o">.</span><span class="n">clear</span><span class="p">(</span><span class="n">_REFERENCESUBSTANCESCACHE</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_clearCache</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Clear the cache</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataSource</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dataSource</span><span class="o">.</span><span class="n">clearCache</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Close any open dataSource</span>

<span class="sd">        CCPNINTERNAL: also called by Project.close() to do cleanup</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clearCache</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataSource</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_spectrumTraits</span><span class="o">.</span><span class="n">dataSource</span><span class="o">.</span><span class="n">closeFile</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_spectrumTraits</span><span class="o">.</span><span class="n">dataSource</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="Spectrum.delete"><a class="viewcode-back" href="../../../ccpn/ccpn.core.html#ccpn.core.Spectrum.Spectrum.delete">[docs]</a>    <span class="nd">@logCommand</span><span class="p">(</span><span class="n">get</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">delete</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Delete Spectrum&quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="n">undoBlock</span><span class="p">():</span>

            <span class="c1"># self._deleteSpectrumMetaData()</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_close</span><span class="p">()</span>

            <span class="c1"># self.deleteAllNotifiers() TODO: no longer required?</span>

            <span class="c1"># handle spectrumView ordering - this should be moved to spectrumView or spectrumDisplay via notifier?</span>
            <span class="n">specDisplays</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">specViews</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrumViews</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">sp</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">spectrumDisplay</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">specDisplays</span><span class="p">:</span>
                    <span class="n">specDisplays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">spectrumDisplay</span><span class="p">)</span>
                    <span class="n">specViews</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">sp</span><span class="o">.</span><span class="n">_parent</span><span class="p">,</span> <span class="n">sp</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">spectrumViews</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">sp</span><span class="p">)))</span>

            <span class="n">listsToDelete</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">peakLists</span><span class="p">)</span>
            <span class="n">listsToDelete</span> <span class="o">+=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">integralLists</span><span class="p">)</span>
            <span class="n">listsToDelete</span> <span class="o">+=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">multipletLists</span><span class="p">)</span>

            <span class="c1"># delete the connected lists, should undo in the correct order</span>
            <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">listsToDelete</span><span class="p">:</span>
                <span class="n">obj</span><span class="o">.</span><span class="n">_delete</span><span class="p">()</span>

            <span class="k">with</span> <span class="n">undoStackBlocking</span><span class="p">()</span> <span class="k">as</span> <span class="n">addUndoItem</span><span class="p">:</span>
                <span class="c1"># notify spectrumViews of delete/create</span>
                <span class="n">addUndoItem</span><span class="p">(</span><span class="n">undo</span><span class="o">=</span><span class="n">partial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_notifySpectrumViews</span><span class="p">,</span> <span class="s1">&#39;create&#39;</span><span class="p">),</span>
                            <span class="n">redo</span><span class="o">=</span><span class="n">partial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_notifySpectrumViews</span><span class="p">,</span> <span class="s1">&#39;delete&#39;</span><span class="p">))</span>

            <span class="c1"># delete the _wrappedData</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_delete</span><span class="p">()</span></div>

            <span class="c1"># with undoStackBlocking() as addUndoItem:</span>
            <span class="c1">#     # notify spectrumViews of delete</span>
            <span class="c1">#     addUndoItem(redo=self._finaliseSpectrumViews, &#39;&#39;)</span>

            <span class="c1"># for sd in specViews:</span>
            <span class="c1">#     sd[0]._removeOrderedSpectrumViewIndex(sd[1])</span>

    <span class="k">def</span> <span class="nf">_deleteChild</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Delete child object</span>
<span class="sd">        child is Pid or V3 object</span>
<span class="sd">        If child exists and is a valid child then delete otherwise log a warning</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">child</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">project</span><span class="o">.</span><span class="n">getByPid</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">child</span>

        <span class="k">if</span> <span class="n">child</span> <span class="ow">and</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getChildrenByClass</span><span class="p">(</span><span class="n">child</span><span class="p">):</span>
            <span class="c1"># only delete objects that are valid children - calls private _delete</span>
            <span class="c1"># so now infinite loop with baseclass delete</span>
            <span class="n">child</span><span class="o">.</span><span class="n">_delete</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">child</span><span class="p">:</span>
            <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">child</span><span class="si">}</span><span class="s1"> not deleted - not child of </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">child</span><span class="si">}</span><span class="s1"> not deleted&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_deletePeakList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Delete child object and ensure that there always exists at least one peakList</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="n">undoBlock</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_deleteChild</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">peakLists</span><span class="p">:</span>
                <span class="c1"># if there are no peakLists then create another (there must always be one)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">newPeakList</span><span class="p">()</span>

    <span class="c1">#-----------------------------------------------------------------------------------------</span>
    <span class="c1"># CCPN properties and functions</span>
    <span class="c1">#-----------------------------------------------------------------------------------------</span>

    <span class="k">def</span> <span class="nf">_resetPeakLists</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Delete autocreated peaklists and reset</span>
<span class="sd">        CCPN Internal - not for general use</span>
<span class="sd">        required by nef importer</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">peakList</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">peakLists</span><span class="p">):</span>
            <span class="c1"># overrides spectrum contains at least one peakList</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_deleteChild</span><span class="p">(</span><span class="n">peakList</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s1">&#39;_serialDict&#39;</span><span class="p">][</span><span class="s1">&#39;peakLists&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_apiDataSource</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Nmr</span><span class="o">.</span><span class="n">DataSource</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; CCPN DataSource matching Spectrum&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_key</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;name, regularised as used for id&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">Pid</span><span class="o">.</span><span class="n">remapSeparators</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_localCcpnSortKey</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Local sorting key, in context of parent.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">experiment</span><span class="o">.</span><span class="n">serial</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">serial</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_getAllWrappedData</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">parent</span><span class="p">:</span> <span class="n">Project</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;get wrappedData (Nmr.DataSources) for all Spectrum children of parent Project&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">x</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">parent</span><span class="o">.</span><span class="n">_wrappedData</span><span class="o">.</span><span class="n">sortedExperiments</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">y</span><span class="o">.</span><span class="n">sortedDataSources</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">_notifySpectrumViews</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">action</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">sv</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrumViews</span><span class="p">:</span>
            <span class="n">sv</span><span class="o">.</span><span class="n">_finaliseAction</span><span class="p">(</span><span class="n">action</span><span class="p">)</span>

    <span class="c1">#-----------------------------------------------------------------------------------------</span>
    <span class="c1"># new&lt;Object&gt; and other methods</span>
    <span class="c1"># Call appropriate routines in their respective locations</span>
    <span class="c1">#-----------------------------------------------------------------------------------------</span>

<div class="viewcode-block" id="Spectrum.newPeakList"><a class="viewcode-back" href="../../../ccpn/ccpn.core.html#ccpn.core.Spectrum.Spectrum.newPeakList">[docs]</a>    <span class="nd">@logCommand</span><span class="p">(</span><span class="n">get</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">newPeakList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">title</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">comment</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">isSimulated</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">symbolStyle</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">symbolColour</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">textColour</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create new empty PeakList within Spectrum</span>

<span class="sd">        See the PeakList class for details.</span>

<span class="sd">        Optional keyword arguments can be passed in; see PeakList._newPeakList for details.</span>

<span class="sd">        :param title:</span>
<span class="sd">        :param comment:</span>
<span class="sd">        :param isSimulated:</span>
<span class="sd">        :param symbolStyle:</span>
<span class="sd">        :param symbolColour:</span>
<span class="sd">        :param textColour:</span>
<span class="sd">        :return: a new PeakList attached to the spectrum.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">ccpn.core.PeakList</span> <span class="kn">import</span> <span class="n">_newPeakList</span>

        <span class="k">return</span> <span class="n">_newPeakList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span> <span class="n">comment</span><span class="o">=</span><span class="n">comment</span><span class="p">,</span> <span class="n">isSimulated</span><span class="o">=</span><span class="n">isSimulated</span><span class="p">,</span>
                            <span class="n">symbolStyle</span><span class="o">=</span><span class="n">symbolStyle</span><span class="p">,</span> <span class="n">symbolColour</span><span class="o">=</span><span class="n">symbolColour</span><span class="p">,</span> <span class="n">textColour</span><span class="o">=</span><span class="n">textColour</span><span class="p">,</span>
                            <span class="o">**</span><span class="n">kwds</span><span class="p">)</span></div>

<div class="viewcode-block" id="Spectrum.newIntegralList"><a class="viewcode-back" href="../../../ccpn/ccpn.core.html#ccpn.core.Spectrum.Spectrum.newIntegralList">[docs]</a>    <span class="nd">@logCommand</span><span class="p">(</span><span class="n">get</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">newIntegralList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">title</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">symbolColour</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="n">textColour</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">comment</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create new IntegralList within Spectrum.</span>

<span class="sd">        See the IntegralList class for details.</span>

<span class="sd">        Optional keyword arguments can be passed in; see IntegralList._newIntegralList for details.</span>

<span class="sd">        :param self:</span>
<span class="sd">        :param title:</span>
<span class="sd">        :param symbolColour:</span>
<span class="sd">        :param textColour:</span>
<span class="sd">        :param comment:</span>
<span class="sd">        :return: a new IntegralList attached to the spectrum.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">ccpn.core.IntegralList</span> <span class="kn">import</span> <span class="n">_newIntegralList</span>

        <span class="k">return</span> <span class="n">_newIntegralList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span> <span class="n">comment</span><span class="o">=</span><span class="n">comment</span><span class="p">,</span>
                                <span class="n">symbolColour</span><span class="o">=</span><span class="n">symbolColour</span><span class="p">,</span> <span class="n">textColour</span><span class="o">=</span><span class="n">textColour</span><span class="p">,</span>
                                <span class="o">**</span><span class="n">kwds</span><span class="p">)</span></div>

<div class="viewcode-block" id="Spectrum.newMultipletList"><a class="viewcode-back" href="../../../ccpn/ccpn.core.html#ccpn.core.Spectrum.Spectrum.newMultipletList">[docs]</a>    <span class="nd">@logCommand</span><span class="p">(</span><span class="n">get</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">newMultipletList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">title</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                         <span class="n">symbolColour</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">textColour</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">lineColour</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                         <span class="n">multipletAveraging</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">comment</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">multiplets</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="s1">&#39;Multiplet&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create new MultipletList within Spectrum.</span>

<span class="sd">        See the MultipletList class for details.</span>

<span class="sd">        Optional keyword arguments can be passed in; see MultipletList._newMultipletList for details.</span>

<span class="sd">        :param title: title string</span>
<span class="sd">        :param symbolColour:</span>
<span class="sd">        :param textColour:</span>
<span class="sd">        :param lineColour:</span>
<span class="sd">        :param multipletAveraging:</span>
<span class="sd">        :param comment: optional comment string</span>
<span class="sd">        :param multiplets: optional list of multiplets as objects or pids</span>
<span class="sd">        :return: a new MultipletList attached to the Spectrum.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">ccpn.core.MultipletList</span> <span class="kn">import</span> <span class="n">_newMultipletList</span>

        <span class="k">return</span> <span class="n">_newMultipletList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span> <span class="n">comment</span><span class="o">=</span><span class="n">comment</span><span class="p">,</span>
                                 <span class="n">lineColour</span><span class="o">=</span><span class="n">lineColour</span><span class="p">,</span> <span class="n">symbolColour</span><span class="o">=</span><span class="n">symbolColour</span><span class="p">,</span> <span class="n">textColour</span><span class="o">=</span><span class="n">textColour</span><span class="p">,</span>
                                 <span class="n">multipletAveraging</span><span class="o">=</span><span class="n">multipletAveraging</span><span class="p">,</span>
                                 <span class="n">multiplets</span><span class="o">=</span><span class="n">multiplets</span><span class="p">,</span>
                                 <span class="o">**</span><span class="n">kwds</span><span class="p">)</span></div>

<div class="viewcode-block" id="Spectrum.newSpectrumHit"><a class="viewcode-back" href="../../../ccpn/ccpn.core.html#ccpn.core.Spectrum.Spectrum.newSpectrumHit">[docs]</a>    <span class="nd">@logCommand</span><span class="p">(</span><span class="n">get</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">newSpectrumHit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">substanceName</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">pointNumber</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                       <span class="n">pseudoDimensionNumber</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pseudoDimension</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">figureOfMerit</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">meritCode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">normalisedChange</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                       <span class="n">isConfirmed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">concentration</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">concentrationError</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                       <span class="n">concentrationUnit</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">comment</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create new SpectrumHit within Spectrum.</span>

<span class="sd">        See the SpectrumHit class for details.</span>

<span class="sd">        Optional keyword arguments can be passed in; see SpectrumHit._newSpectrumHit for details.</span>

<span class="sd">        :param substanceName:</span>
<span class="sd">        :param pointNumber:</span>
<span class="sd">        :param pseudoDimensionNumber:</span>
<span class="sd">        :param pseudoDimension:</span>
<span class="sd">        :param figureOfMerit:</span>
<span class="sd">        :param meritCode:</span>
<span class="sd">        :param normalisedChange:</span>
<span class="sd">        :param isConfirmed:</span>
<span class="sd">        :param concentration:</span>
<span class="sd">        :param concentrationError:</span>
<span class="sd">        :param concentrationUnit:</span>
<span class="sd">        :param comment: optional comment string</span>
<span class="sd">        :return: a new SpectrumHit instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">ccpn.core.SpectrumHit</span> <span class="kn">import</span> <span class="n">_newSpectrumHit</span>

        <span class="k">return</span> <span class="n">_newSpectrumHit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">substanceName</span><span class="o">=</span><span class="n">substanceName</span><span class="p">,</span> <span class="n">pointNumber</span><span class="o">=</span><span class="n">pointNumber</span><span class="p">,</span>
                               <span class="n">pseudoDimensionNumber</span><span class="o">=</span><span class="n">pseudoDimensionNumber</span><span class="p">,</span> <span class="n">pseudoDimension</span><span class="o">=</span><span class="n">pseudoDimension</span><span class="p">,</span>
                               <span class="n">figureOfMerit</span><span class="o">=</span><span class="n">figureOfMerit</span><span class="p">,</span> <span class="n">meritCode</span><span class="o">=</span><span class="n">meritCode</span><span class="p">,</span> <span class="n">normalisedChange</span><span class="o">=</span><span class="n">normalisedChange</span><span class="p">,</span>
                               <span class="n">isConfirmed</span><span class="o">=</span><span class="n">isConfirmed</span><span class="p">,</span> <span class="n">concentration</span><span class="o">=</span><span class="n">concentration</span><span class="p">,</span> <span class="n">concentrationError</span><span class="o">=</span><span class="n">concentrationError</span><span class="p">,</span>
                               <span class="n">concentrationUnit</span><span class="o">=</span><span class="n">concentrationUnit</span><span class="p">,</span> <span class="n">comment</span><span class="o">=</span><span class="n">comment</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span></div>

    <span class="c1">#-----------------------------------------------------------------------------------------</span>
    <span class="c1"># Output, printing, etc</span>
    <span class="c1">#-----------------------------------------------------------------------------------------</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;&lt;</span><span class="si">%s</span><span class="s1"> (</span><span class="si">%s</span><span class="s1">); </span><span class="si">%d</span><span class="s1">D (</span><span class="si">%s</span><span class="s1">)&gt;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataFormat</span><span class="p">,</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">dimensionCount</span><span class="p">,</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axisCodes</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_infoString</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">includeDimensions</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return info string about self, optionally including dimensional</span>
<span class="sd">        parameters</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">string</span> <span class="o">=</span> <span class="s1">&#39;================= </span><span class="si">%s</span><span class="s1"> =================</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span>
        <span class="n">string</span> <span class="o">+=</span> <span class="s1">&#39;path = </span><span class="si">%s</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">filePath</span>
        <span class="n">string</span> <span class="o">+=</span> <span class="s1">&#39;dataFormat = </span><span class="si">%s</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataFormat</span>
        <span class="n">string</span> <span class="o">+=</span> <span class="s1">&#39;dimensions = </span><span class="si">%s</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensionCount</span>
        <span class="n">string</span> <span class="o">+=</span> <span class="s1">&#39;sizes = (</span><span class="si">%s</span><span class="s1">)</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="s1">&#39; x &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointCounts</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">                scale </span>
<span class="s2">                noiseLevel </span>
<span class="s2">                experimentName</span>
<span class="s2">                &quot;&quot;&quot;</span><span class="o">.</span><span class="n">split</span><span class="p">():</span>
            <span class="n">value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
            <span class="n">string</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> = </span><span class="si">%s</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">includeDimensions</span><span class="p">:</span>
            <span class="n">string</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">                dimensions</span>
<span class="s2">                axisCodes</span>
<span class="s2">                pointCounts</span>
<span class="s2">                isComplex</span>
<span class="s2">                dimensionTypes</span>
<span class="s2">                isotopeCodes</span>
<span class="s2">                measurementTypes</span>
<span class="s2">                spectralWidths</span>
<span class="s2">                spectralWidthsHz</span>
<span class="s2">                spectrometerFrequencies</span>
<span class="s2">                referencePoints</span>
<span class="s2">                referenceValues</span>
<span class="s2">                axisUnits</span>
<span class="s2">                foldingModes</span>
<span class="s2">                windowFunctions</span>
<span class="s2">                lorentzianBroadenings</span>
<span class="s2">                gaussianBroadenings</span>
<span class="s2">                phases0</span>
<span class="s2">                phases1</span>
<span class="s2">                assignmentTolerances</span>
<span class="s2">                &quot;&quot;&quot;</span><span class="o">.</span><span class="n">split</span><span class="p">():</span>
                <span class="n">values</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
                <span class="n">string</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="si">%-25s</span><span class="s1">: </span><span class="si">%s</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">attr</span><span class="p">,</span>
                                           <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;</span><span class="si">%-20s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">values</span><span class="p">])</span>
                                           <span class="p">)</span>
        <span class="k">return</span> <span class="n">string</span>

<div class="viewcode-block" id="Spectrum.printParameters"><a class="viewcode-back" href="../../../ccpn/ccpn.core.html#ccpn.core.Spectrum.Spectrum.printParameters">[docs]</a>    <span class="k">def</span> <span class="nf">printParameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">includeDimensions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Print the info string</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_infoString</span><span class="p">(</span><span class="n">includeDimensions</span><span class="p">))</span></div></div>


<span class="c1">#=========================================================================================</span>
<span class="c1"># New and empty spectra</span>
<span class="c1">#=========================================================================================</span>

<span class="c1"># Hack; remove the api notifier on create</span>
<span class="c1"># _notifiers = [nf for nf in Project._apiNotifiers if nf[3] == &#39;__init__&#39; and &#39;cls&#39; in nf[1] and nf[1][&#39;cls&#39;] == Spectrum]</span>
<span class="c1"># if len(_notifiers) == 1:</span>
<span class="c1">#     Project._apiNotifiers.remove(_notifiers[0])</span>


<span class="nd">@newObject</span><span class="p">(</span><span class="n">Spectrum</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_newSpectrumFromDataSource</span><span class="p">(</span><span class="n">project</span><span class="p">,</span> <span class="n">dataStore</span><span class="p">,</span> <span class="n">dataSource</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Spectrum</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Create a new Spectrum instance with name using the data in dataStore and dataSource</span>
<span class="sd">    :returns Spectrum instance or None on error</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">ccpn.core.SpectrumReference</span> <span class="kn">import</span> <span class="n">_newSpectrumReference</span>

    <span class="k">if</span> <span class="n">dataStore</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;dataStore cannot be None&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">dataSource</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;dataSource cannot be None&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dataSource</span><span class="o">.</span><span class="n">dimensionCount</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;dataSource.dimensionCount = 0&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">dataSource</span><span class="o">.</span><span class="n">nameFromPath</span><span class="p">()</span>
    <span class="c1"># assure unique name</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">Spectrum</span><span class="o">.</span><span class="n">_uniqueName</span><span class="p">(</span><span class="n">project</span><span class="o">=</span><span class="n">project</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>

    <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Creating Spectrum </span><span class="si">%r</span><span class="s1"> (</span><span class="si">%d</span><span class="s1">D;</span><span class="si">%s</span><span class="s1">); </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span>
        <span class="n">name</span><span class="p">,</span> <span class="n">dataSource</span><span class="o">.</span><span class="n">dimensionCount</span><span class="p">,</span>
        <span class="s1">&#39;x&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">dataSource</span><span class="o">.</span><span class="n">pointCounts</span><span class="p">]),</span>
        <span class="n">dataStore</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="n">apiProject</span> <span class="o">=</span> <span class="n">project</span><span class="o">.</span><span class="n">_wrappedData</span>
    <span class="n">apiExperiment</span> <span class="o">=</span> <span class="n">apiProject</span><span class="o">.</span><span class="n">newExperiment</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">numDim</span><span class="o">=</span><span class="n">dataSource</span><span class="o">.</span><span class="n">dimensionCount</span><span class="p">)</span>

    <span class="n">apiDataSource</span> <span class="o">=</span> <span class="n">apiExperiment</span><span class="o">.</span><span class="n">newDataSource</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
                                                <span class="n">dataStore</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                                <span class="n">numDim</span><span class="o">=</span><span class="n">dataSource</span><span class="o">.</span><span class="n">dimensionCount</span><span class="p">,</span>
                                                <span class="n">dataType</span><span class="o">=</span><span class="s1">&#39;processed&#39;</span>
                                                <span class="p">)</span>
    <span class="c1"># Done with api generation; Create the Spectrum object</span>

    <span class="c1"># Agggh, cannot do</span>
    <span class="c1">#   spectrum = Spectrum(self, apiDataSource)</span>
    <span class="c1"># as the object was magically already created</span>
    <span class="c1"># This was done by Project._newApiObject, called from Nmr.DataSource.__init__ through an api notifier.</span>
    <span class="c1"># This notifier is set in the AbstractWrapper class and is part of the machinery generation; i.e.</span>
    <span class="c1"># _linkWrapperClasses (needs overhaul!!)</span>

    <span class="n">spectrum</span> <span class="o">=</span> <span class="n">project</span><span class="o">.</span><span class="n">_data2Obj</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">apiDataSource</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">spectrum</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;something went wrong creating a new Spectrum instance&quot;</span><span class="p">)</span>
    <span class="n">spectrum</span><span class="o">.</span><span class="n">_apiExperiment</span> <span class="o">=</span> <span class="n">apiExperiment</span>

    <span class="c1"># initialise the dimensional SpectrumReference objects</span>
    <span class="k">with</span> <span class="n">inactivity</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">dataSource</span><span class="o">.</span><span class="n">dimensions</span><span class="p">:</span>
            <span class="n">_newSpectrumReference</span><span class="p">(</span><span class="n">spectrum</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="n">dim</span><span class="p">,</span> <span class="n">dataSource</span><span class="o">=</span><span class="n">dataSource</span><span class="p">)</span>

    <span class="c1"># Set the references between spectrum and dataStore</span>
    <span class="n">dataStore</span><span class="o">.</span><span class="n">dataFormat</span> <span class="o">=</span> <span class="n">dataSource</span><span class="o">.</span><span class="n">dataFormat</span>
    <span class="n">dataStore</span><span class="o">.</span><span class="n">spectrum</span> <span class="o">=</span> <span class="n">spectrum</span>
    <span class="n">dataStore</span><span class="o">.</span><span class="n">_saveInternal</span><span class="p">()</span>
    <span class="n">spectrum</span><span class="o">.</span><span class="n">_spectrumTraits</span><span class="o">.</span><span class="n">dataStore</span> <span class="o">=</span> <span class="n">dataStore</span>

    <span class="c1"># update dataSource with proper expanded path</span>
    <span class="n">dataSource</span><span class="o">.</span><span class="n">setPath</span><span class="p">(</span><span class="n">dataStore</span><span class="o">.</span><span class="n">aPath</span><span class="p">())</span>
    <span class="c1"># Update all parameters from the dataSource to the Spectrum instance; retain the dataSource instance</span>
    <span class="n">dataSource</span><span class="o">.</span><span class="n">exportToSpectrum</span><span class="p">(</span><span class="n">spectrum</span><span class="p">,</span> <span class="n">includePath</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">spectrum</span><span class="o">.</span><span class="n">_spectrumTraits</span><span class="o">.</span><span class="n">dataSource</span> <span class="o">=</span> <span class="n">dataSource</span>
    <span class="c1"># get a peak picker</span>
    <span class="n">spectrum</span><span class="o">.</span><span class="n">_getPeakPicker</span><span class="p">()</span>

    <span class="c1"># Quietly update some essentials</span>
    <span class="k">with</span> <span class="n">inactivity</span><span class="p">():</span>
        <span class="c1"># Link to default (i.e. first) chemicalShiftList</span>
        <span class="n">spectrum</span><span class="o">.</span><span class="n">chemicalShiftList</span> <span class="o">=</span> <span class="n">project</span><span class="o">.</span><span class="n">chemicalShiftLists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Assure at least one peakList</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spectrum</span><span class="o">.</span><span class="n">peakLists</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">spectrum</span><span class="o">.</span><span class="n">newPeakList</span><span class="p">()</span>

        <span class="c1"># Hack to trigger initialisation of contours</span>
        <span class="n">spectrum</span><span class="o">.</span><span class="n">positiveContourCount</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">spectrum</span><span class="o">.</span><span class="n">negativeContourCount</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">spectrum</span><span class="o">.</span><span class="n">_updateParameterValues</span><span class="p">()</span>
        <span class="n">spectrum</span><span class="o">.</span><span class="n">_saveSpectrumMetaData</span><span class="p">()</span>
        <span class="n">spectrum</span><span class="o">.</span><span class="n">_setDefaultAxisOrdering</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">spectrum</span>


<span class="k">def</span> <span class="nf">_newEmptySpectrum</span><span class="p">(</span><span class="n">project</span><span class="p">:</span> <span class="n">Project</span><span class="p">,</span> <span class="n">isotopeCodes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">dimensionCount</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;emptySpectrum&#39;</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="o">**</span><span class="n">parameters</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Spectrum</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Creation of new Empty Spectrum;</span>
<span class="sd">    :return: Spectrum instance or None on error</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">isIterable</span><span class="p">(</span><span class="n">isotopeCodes</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">isotopeCodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;invalid isotopeCodes &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="n">isotopeCodes</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dataStore</span> <span class="o">=</span> <span class="n">DataStore</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dataStore</span> <span class="o">=</span> <span class="n">DataStore</span><span class="o">.</span><span class="n">newFromPath</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="n">path</span><span class="p">,</span> <span class="n">dataFormat</span><span class="o">=</span><span class="n">EmptySpectrumDataSource</span><span class="o">.</span><span class="n">dataFormat</span><span class="p">)</span>

    <span class="c1"># Initialise a dataSource instance</span>
    <span class="n">dataSource</span> <span class="o">=</span> <span class="n">EmptySpectrumDataSource</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">dataSource</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Error creating empty DataSource&#39;</span><span class="p">)</span>
    <span class="c1"># Fill in some of the parameters</span>
    <span class="k">if</span> <span class="n">dimensionCount</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dimensionCount</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">isotopeCodes</span><span class="p">)</span>
    <span class="n">dataSource</span><span class="o">.</span><span class="n">dimensionCount</span> <span class="o">=</span> <span class="n">dimensionCount</span>
    <span class="n">dataSource</span><span class="o">.</span><span class="n">isotopeCodes</span> <span class="o">=</span> <span class="n">isotopeCodes</span>
    <span class="n">dataSource</span><span class="o">.</span><span class="n">_setSpectralParametersFromIsotopeCodes</span><span class="p">()</span>
    <span class="n">dataSource</span><span class="o">.</span><span class="n">_assureProperDimensionality</span><span class="p">()</span>
    <span class="n">dataSource</span><span class="o">.</span><span class="n">noiseLevel</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="n">spectrum</span> <span class="o">=</span> <span class="n">_newSpectrumFromDataSource</span><span class="p">(</span><span class="n">project</span><span class="p">,</span> <span class="n">dataStore</span><span class="p">,</span> <span class="n">dataSource</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="c1"># Optionally update Spectrum with optional parameters and copy back to dataSource instance;</span>
    <span class="c1"># this allows for example to set the size</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">param</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">parameters</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">spectrum</span><span class="p">,</span> <span class="n">param</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="n">spectrum</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">spectrum</span><span class="si">}</span><span class="s1">: can not set parameter &quot;</span><span class="si">{</span><span class="n">param</span><span class="si">}</span><span class="s1">&quot; to </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">dataSource</span><span class="o">.</span><span class="n">importFromSpectrum</span><span class="p">(</span><span class="n">spectrum</span><span class="p">,</span> <span class="n">includePath</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">spectrum</span>

<span class="k">def</span> <span class="nf">_newHdf5Spectrum</span><span class="p">(</span><span class="n">project</span><span class="p">:</span> <span class="n">Project</span><span class="p">,</span> <span class="n">isotopeCodes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;hdf5Spectrum&#39;</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">parameters</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Spectrum</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Creation of new hdf5 Spectrum (without data) at path (autogenerated temporary path when None);</span>
<span class="sd">    :return: Spectrum instance or None on error</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">isIterable</span><span class="p">(</span><span class="n">isotopeCodes</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">isotopeCodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;invalid isotopeCodes &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="n">isotopeCodes</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s1">&#39;$INSIDE&#39;</span><span class="p">)</span> <span class="o">/</span> <span class="n">CCPN_SPECTRA_DIRECTORY</span> <span class="o">/</span> <span class="n">name</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">assureSuffix</span><span class="p">(</span><span class="n">Hdf5SpectrumDataSource</span><span class="o">.</span><span class="n">suffixes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="n">dataStore</span> <span class="o">=</span> <span class="n">DataStore</span><span class="o">.</span><span class="n">newFromPath</span><span class="p">(</span><span class="n">path</span><span class="p">,</span>
                                      <span class="n">dataFormat</span><span class="o">=</span><span class="n">Hdf5SpectrumDataSource</span><span class="o">.</span><span class="n">dataFormat</span><span class="p">,</span>
                                      <span class="n">autoVersioning</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Initialise a Hdf5 dataSource instance</span>
    <span class="n">dataSource</span> <span class="o">=</span> <span class="n">Hdf5SpectrumDataSource</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">dataSource</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Error creating Hdf5 DataSource&#39;</span><span class="p">)</span>

    <span class="c1"># Fill in some of the parameters</span>
    <span class="n">dataSource</span><span class="o">.</span><span class="n">dimensionCount</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">isotopeCodes</span><span class="p">)</span>
    <span class="n">dataSource</span><span class="o">.</span><span class="n">isotopeCodes</span> <span class="o">=</span> <span class="n">isotopeCodes</span>
    <span class="n">dataSource</span><span class="o">.</span><span class="n">_setSpectralParametersFromIsotopeCodes</span><span class="p">()</span>
    <span class="n">dataSource</span><span class="o">.</span><span class="n">_assureProperDimensionality</span><span class="p">()</span>
    <span class="c1"># Optionally update dataSource with  parameters; e.g. to set the pointCounts, spectral parameters, etc</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">param</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">parameters</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">dataSource</span><span class="p">,</span> <span class="n">param</span><span class="p">):</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">dataSource</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="c1"># Create the file</span>
    <span class="k">with</span> <span class="n">dataSource</span><span class="o">.</span><span class="n">openNewFile</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="n">dataStore</span><span class="o">.</span><span class="n">aPath</span><span class="p">())</span> <span class="k">as</span> <span class="n">hdf5File</span><span class="p">:</span>
        <span class="n">hdf5File</span><span class="o">.</span><span class="n">writeParameters</span><span class="p">()</span>

    <span class="c1"># create a Spectrum instance</span>
    <span class="n">spectrum</span> <span class="o">=</span> <span class="n">_newSpectrumFromDataSource</span><span class="p">(</span><span class="n">project</span><span class="p">,</span> <span class="n">dataStore</span><span class="p">,</span> <span class="n">dataSource</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">spectrum</span>

<span class="k">def</span> <span class="nf">_newSpectrum</span><span class="p">(</span><span class="n">project</span><span class="p">:</span> <span class="n">Project</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">),</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">Spectrum</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Creation of new Spectrum instance from path;</span>
<span class="sd">    :return: Spectrum instance or None on error</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">logger</span> <span class="o">=</span> <span class="n">getLogger</span><span class="p">()</span>

    <span class="n">dataStore</span> <span class="o">=</span> <span class="n">DataStore</span><span class="o">.</span><span class="n">newFromPath</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">dataStore</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
        <span class="n">dataStore</span><span class="o">.</span><span class="n">errorMessage</span><span class="p">()</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="n">_path</span> <span class="o">=</span> <span class="n">dataStore</span><span class="o">.</span><span class="n">aPath</span><span class="p">()</span>

    <span class="c1"># Try to determine data format from the path and intialise a dataSource instance with parsed parameters</span>
    <span class="n">dataSource</span> <span class="o">=</span> <span class="n">checkPathForSpectrumFormats</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="n">_path</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dataSource</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Invalid spectrum path &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="n">path</span><span class="p">)</span>  <span class="c1"># report the argument given</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="n">dataSource</span><span class="o">.</span><span class="n">estimateNoise</span><span class="p">()</span>

    <span class="n">spectrum</span> <span class="o">=</span> <span class="n">_newSpectrumFromDataSource</span><span class="p">(</span><span class="n">project</span><span class="p">,</span> <span class="n">dataStore</span><span class="p">,</span> <span class="n">dataSource</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">spectrum</span>


<span class="k">def</span> <span class="nf">_extractRegionToFile</span><span class="p">(</span><span class="n">spectrum</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">dataStore</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Spectrum</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Extract a region of spectrum, defined by dimensions, position to path defined by dataStore</span>
<span class="sd">    (optionally auto-generated from spectrum.path)</span>

<span class="sd">    :spectrum: the spectrum from which a regions is to be extracted</span>
<span class="sd">    :param dimensions:  [dim_a, dim_b, ...];  defining dimensions to be extracted (1-based)</span>
<span class="sd">    :param position, spectrum position-vector of length spectrum.dimensionCount (list, tuple; 1-based)</span>
<span class="sd">    :param dataStore: a DataStore instance, defining the path and dataFormat of the new spectrum</span>
<span class="sd">    :param name: optional name for the new spectrum</span>
<span class="sd">    :return: a Spectrum instance</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Extracting from </span><span class="si">%s</span><span class="s1">, dimensions=</span><span class="si">%r</span><span class="s1">, position=</span><span class="si">%r</span><span class="s1">, dataStore=</span><span class="si">%s</span><span class="s1">, dataFormat </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span>
                      <span class="p">(</span><span class="n">spectrum</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">dataStore</span><span class="p">,</span> <span class="n">dataStore</span><span class="o">.</span><span class="n">dataFormat</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">spectrum</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spectrum</span><span class="p">,</span> <span class="n">Spectrum</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;invalid spectrum argument </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">spectrum</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">dataSource</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;No proper (filePath, dataFormat) set for </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">spectrum</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">dimensions</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">dim</span> <span class="o">&gt;</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">dimensionCount</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid dimnsion </span><span class="si">%r</span><span class="s1"> in dimensions argument (</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">))</span>
    <span class="n">dimensions</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dimensions</span><span class="p">)</span>  <span class="c1"># assure a list</span>

    <span class="n">position</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">dataSource</span><span class="o">.</span><span class="n">checkForValidPosition</span><span class="p">(</span><span class="n">position</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">dataStore</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Undefined dataStore&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dataStore</span><span class="o">.</span><span class="n">dataFormat</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Undefined dataStore.dataFormat&#39;</span><span class="p">)</span>

    <span class="n">klass</span> <span class="o">=</span> <span class="n">getDataFormats</span><span class="p">()</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">dataStore</span><span class="o">.</span><span class="n">dataFormat</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">klass</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid dataStore.dataFormat </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">dataStore</span><span class="o">.</span><span class="n">dataFormat</span><span class="p">)</span>

    <span class="c1"># Create a dataSource object; import spectrum to initialise the dataSource values</span>
    <span class="n">dataSource</span> <span class="o">=</span> <span class="n">klass</span><span class="p">()</span><span class="o">.</span><span class="n">importFromSpectrum</span><span class="p">(</span><span class="n">spectrum</span><span class="o">=</span><span class="n">spectrum</span><span class="p">,</span> <span class="n">includePath</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">disgardedDimensions</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">spectrum</span><span class="o">.</span><span class="n">dimensions</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">dimensions</span><span class="p">))</span>
    <span class="c1"># The dimensional parameters of spectrum were copied on initialisation</span>
    <span class="c1"># remap the N-axes (as defined by the N items in the dimensions argument) onto the first N axes</span>
    <span class="c1"># of the dataSource;</span>
    <span class="n">dimensionsMap</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">dimensions</span> <span class="o">+</span> <span class="n">disgardedDimensions</span><span class="p">,</span> <span class="n">dataSource</span><span class="o">.</span><span class="n">dimensions</span><span class="p">))</span>
    <span class="n">dataSource</span><span class="o">.</span><span class="n">_mapDimensionalParameters</span><span class="p">(</span><span class="n">dimensionsMap</span><span class="o">=</span><span class="n">dimensionsMap</span><span class="p">)</span>
    <span class="c1"># Now reduce the dimensionality to the length of dimensions; i.e. the dimensionality of the</span>
    <span class="c1"># new spectrum</span>
    <span class="n">dataSource</span><span class="o">.</span><span class="n">setDimensionCount</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dimensions</span><span class="p">))</span>

    <span class="c1"># copy the data</span>
    <span class="c1"># indexMap = dict((k - 1, v - 1) for k, v in dimensionsMap.items())  # source -&gt; destination</span>
    <span class="n">inverseIndexMap</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">v</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="ow">in</span> <span class="n">dimensionsMap</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>  <span class="c1"># destination -&gt; source</span>

    <span class="n">readSliceDim</span> <span class="o">=</span> <span class="n">dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># first retained dimension from the original data</span>
    <span class="n">writeSliceDim</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># which was mapped to the first dimension of the new data</span>

    <span class="n">sliceTuples</span> <span class="o">=</span> <span class="p">[(</span><span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">position</span><span class="p">]</span>
    <span class="c1"># assure full range for all dimensions, other than readSliceDim</span>
    <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">dimensions</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="n">sliceTuples</span><span class="p">[</span><span class="n">dim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">pointCounts</span><span class="p">[</span><span class="n">dim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>

    <span class="k">with</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">dataSource</span><span class="o">.</span><span class="n">openExistingFile</span><span class="p">()</span> <span class="k">as</span> <span class="n">inputFile</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">dataSource</span><span class="o">.</span><span class="n">openNewFile</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="n">dataStore</span><span class="o">.</span><span class="n">aPath</span><span class="p">())</span> <span class="k">as</span> <span class="n">output</span><span class="p">:</span>
            <span class="c1"># loop over all requested slices</span>
            <span class="k">for</span> <span class="n">position</span><span class="p">,</span> <span class="n">aliased</span> <span class="ow">in</span> <span class="n">inputFile</span><span class="o">.</span><span class="n">_selectedPointsIterator</span><span class="p">(</span><span class="n">sliceTuples</span><span class="o">=</span><span class="n">sliceTuples</span><span class="p">,</span>
                                                                   <span class="n">excludeDimensions</span><span class="o">=</span><span class="p">[</span><span class="n">readSliceDim</span><span class="p">]):</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">inputFile</span><span class="o">.</span><span class="n">getSliceData</span><span class="p">(</span><span class="n">position</span><span class="o">=</span><span class="n">position</span><span class="p">,</span> <span class="n">sliceDim</span><span class="o">=</span><span class="n">readSliceDim</span><span class="p">)</span>

                <span class="c1"># map the input position to the output position and write the data</span>
                <span class="n">outPosition</span> <span class="o">=</span> <span class="p">[</span><span class="n">position</span><span class="p">[</span><span class="n">inverseIndexMap</span><span class="p">[</span><span class="n">p</span><span class="p">]]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">output</span><span class="o">.</span><span class="n">dimensionIndices</span><span class="p">]</span>
                <span class="c1"># print(&#39;&gt;&gt;&gt;&#39;, position, outPosition)</span>
                <span class="n">output</span><span class="o">.</span><span class="n">setSliceData</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="n">outPosition</span><span class="p">,</span> <span class="n">sliceDim</span><span class="o">=</span><span class="n">writeSliceDim</span><span class="p">)</span>

    <span class="c1"># create the new Spectrum instance from the dataSource</span>
    <span class="n">newSpectrum</span> <span class="o">=</span> <span class="n">_newSpectrumFromDataSource</span><span class="p">(</span><span class="n">project</span><span class="o">=</span><span class="n">spectrum</span><span class="o">.</span><span class="n">project</span><span class="p">,</span>
                                             <span class="n">dataStore</span><span class="o">=</span><span class="n">dataStore</span><span class="p">,</span>
                                             <span class="n">dataSource</span><span class="o">=</span><span class="n">dataSource</span><span class="p">,</span>
                                             <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>

    <span class="c1"># copy/set some more parameters (e.g. noiseLevel)</span>
    <span class="n">spectrum</span><span class="o">.</span><span class="n">_copyNonDimensionalParameters</span><span class="p">(</span><span class="n">newSpectrum</span><span class="p">)</span>
    <span class="n">newSpectrum</span><span class="o">.</span><span class="n">_updateParameterValues</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">newSpectrum</span>

<span class="c1">#</span>
<span class="c1"># # Additional Notifiers:</span>
<span class="c1"># Project._apiNotifiers.extend(</span>
<span class="c1">#         (</span>
<span class="c1">#             # GWV: not needed?</span>
<span class="c1">#             # (&#39;_finaliseApiRename&#39;, {}, Nmr.DataSource._metaclass.qualifiedName(), &#39;setName&#39;),</span>
<span class="c1">#             #</span>
<span class="c1">#             (&#39;_notifyRelatedApiObject&#39;, {&#39;pathToObject&#39;: &#39;dataSources&#39;, &#39;action&#39;: &#39;change&#39;},</span>
<span class="c1">#              Nmr.Experiment._metaclass.qualifiedName(), &#39;&#39;),</span>
<span class="c1">#</span>
<span class="c1">#             (&#39;_notifyRelatedApiObject&#39;, {&#39;pathToObject&#39;: &#39;dataSource&#39;, &#39;action&#39;: &#39;change&#39;},</span>
<span class="c1">#              Nmr.AbstractDataDim._metaclass.qualifiedName(), &#39;&#39;),</span>
<span class="c1">#</span>
<span class="c1">#             (&#39;_notifyRelatedApiObject&#39;, {&#39;pathToObject&#39;: &#39;dataDim.dataSource&#39;, &#39;action&#39;: &#39;change&#39;},</span>
<span class="c1">#              Nmr.DataDimRef._metaclass.qualifiedName(), &#39;&#39;),</span>
<span class="c1">#</span>
<span class="c1">#             (&#39;_notifyRelatedApiObject&#39;, {&#39;pathToObject&#39;: &#39;experiment.dataSources&#39;, &#39;action&#39;: &#39;change&#39;},</span>
<span class="c1">#              Nmr.ExpDim._metaclass.qualifiedName(), &#39;&#39;),</span>
<span class="c1">#</span>
<span class="c1">#             (&#39;_notifyRelatedApiObject&#39;, {&#39;pathToObject&#39;: &#39;expDim.experiment.dataSources&#39;, &#39;action&#39;: &#39;change&#39;},</span>
<span class="c1">#              Nmr.ExpDimRef._metaclass.qualifiedName(), &#39;&#39;),</span>
<span class="c1">#</span>
<span class="c1">#             (&#39;_notifyRelatedApiObject&#39;, {&#39;pathToObject&#39;: &#39;nmrDataSources&#39;, &#39;action&#39;: &#39;change&#39;},</span>
<span class="c1">#              DataLocation.AbstractDataStore._metaclass.qualifiedName(), &#39;&#39;),</span>
<span class="c1">#</span>
<span class="c1">#             )</span>
<span class="c1">#         )</span>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">Python  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">ccpn.core.Spectrum</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright .
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.4.0.
    </div>
  </body>
</html>