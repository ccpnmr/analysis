
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ccpn.core.lib.SpectrumLib &#8212; Python  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/classic.css" />
    
    <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">Python  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">ccpn.core.lib.SpectrumLib</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for ccpn.core.lib.SpectrumLib</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Spectrum-related definitions, functions and utilities</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c1">#=========================================================================================</span>
<span class="c1"># Licence, Reference and Credits</span>
<span class="c1">#=========================================================================================</span>
<span class="n">__copyright__</span> <span class="o">=</span> <span class="s2">&quot;Copyright (C) CCPN project (https://www.ccpn.ac.uk) 2014 - 2022&quot;</span>
<span class="n">__credits__</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Ed Brooksbank, Joanna Fox, Victoria A Higman, Luca Mureddu, Eliza Płoskoń&quot;</span><span class="p">,</span>
               <span class="s2">&quot;Timothy J Ragan, Brian O Smith, Gary S Thompson &amp; Geerten W Vuister&quot;</span><span class="p">)</span>
<span class="n">__licence__</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;CCPN licence. See https://ccpn.ac.uk/software/licensing/&quot;</span><span class="p">)</span>
<span class="n">__reference__</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Skinner, S.P., Fogh, R.H., Boucher, W., Ragan, T.J., Mureddu, L.G., &amp; Vuister, G.W.&quot;</span><span class="p">,</span>
                 <span class="s2">&quot;CcpNmr AnalysisAssign: a flexible platform for integrated NMR analysis&quot;</span><span class="p">,</span>
                 <span class="s2">&quot;J.Biomol.Nmr (2016), 66, 111-124, http://doi.org/10.1007/s10858-016-0060-y&quot;</span><span class="p">)</span>
<span class="c1">#=========================================================================================</span>
<span class="c1"># Last code modification</span>
<span class="c1">#=========================================================================================</span>
<span class="n">__modifiedBy__</span> <span class="o">=</span> <span class="s2">&quot;$modifiedBy: Ed Brooksbank $&quot;</span>
<span class="n">__dateModified__</span> <span class="o">=</span> <span class="s2">&quot;$dateModified: 2022-07-05 13:20:38 +0100 (Tue, July 05, 2022) $&quot;</span>
<span class="n">__version__</span> <span class="o">=</span> <span class="s2">&quot;$Revision: 3.1.0 $&quot;</span>
<span class="c1">#=========================================================================================</span>
<span class="c1"># Created</span>
<span class="c1">#=========================================================================================</span>
<span class="n">__author__</span> <span class="o">=</span> <span class="s2">&quot;$Author: CCPN $&quot;</span>
<span class="n">__date__</span> <span class="o">=</span> <span class="s2">&quot;$Date: 2017-04-07 10:28:41 +0000 (Fri, April 07, 2017) $&quot;</span>
<span class="c1">#=========================================================================================</span>
<span class="c1"># Start of code</span>
<span class="c1">#=========================================================================================</span>

<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">decorator</span>

<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">List</span>

<span class="kn">from</span> <span class="nn">ccpn.framework.Application</span> <span class="kn">import</span> <span class="n">getApplication</span>
<span class="kn">from</span> <span class="nn">ccpn.core.lib.ContextManagers</span> <span class="kn">import</span> <span class="n">notificationEchoBlocking</span><span class="p">,</span> <span class="n">undoBlockWithoutSideBar</span>
<span class="kn">from</span> <span class="nn">ccpn.core.lib.AxisCodeLib</span> <span class="kn">import</span> <span class="n">getAxisCodeMatchIndices</span>
<span class="kn">from</span> <span class="nn">ccpn.core.lib._DistanceRestraintsLib</span> <span class="kn">import</span> <span class="n">_getBoundResonances</span><span class="p">,</span> <span class="n">longRangeTransfers</span>
<span class="kn">from</span> <span class="nn">ccpn.util.Common</span> <span class="kn">import</span> <span class="n">percentage</span><span class="p">,</span> <span class="n">isIterable</span>
<span class="kn">from</span> <span class="nn">ccpn.util.Logging</span> <span class="kn">import</span> <span class="n">getLogger</span>
<span class="kn">from</span> <span class="nn">ccpn.util.decorators</span> <span class="kn">import</span> <span class="n">singleton</span>
<span class="kn">from</span> <span class="nn">ccpn.util.DataEnum</span> <span class="kn">import</span> <span class="n">DataEnum</span>


<span class="c1">#=========================================================================================</span>
<span class="c1"># Dimension definitions</span>
<span class="c1"># Defined here to prevent cyclic import problems in other modules that need access to these definitions</span>
<span class="c1">#=========================================================================================</span>
<span class="n">DIMENSION_TIME</span> <span class="o">=</span> <span class="s1">&#39;Time&#39;</span>
<span class="n">DIMENSION_FREQUENCY</span> <span class="o">=</span> <span class="s1">&#39;Frequency&#39;</span>
<span class="n">DIMENSION_SAMPLED</span> <span class="o">=</span> <span class="s1">&#39;Sampled&#39;</span>
<span class="n">DIMENSIONTYPES</span> <span class="o">=</span> <span class="p">[</span><span class="n">DIMENSION_TIME</span><span class="p">,</span> <span class="n">DIMENSION_FREQUENCY</span><span class="p">,</span> <span class="n">DIMENSION_SAMPLED</span><span class="p">]</span>
<span class="n">DIMENSIONFREQ</span> <span class="o">=</span> <span class="s1">&#39;Freq&#39;</span>  <span class="c1"># GWV: not sure why this is needed, used in the model??</span>

<span class="n">MAXDIM</span> <span class="o">=</span> <span class="mi">8</span>  <span class="c1"># Maximum dimensionality</span>

<span class="n">X_AXIS</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">Y_AXIS</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">Z_AXIS</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">A_AXIS</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">B_AXIS</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">C_AXIS</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">D_AXIS</span> <span class="o">=</span> <span class="mi">6</span>
<span class="n">E_AXIS</span> <span class="o">=</span> <span class="mi">7</span>
<span class="n">UNDEFINED_AXIS</span> <span class="o">=</span> <span class="mi">8</span>
<span class="n">axisNames</span> <span class="o">=</span> <span class="p">{</span><span class="n">X_AXIS</span>        <span class="p">:</span> <span class="s2">&quot;x-axis&quot;</span><span class="p">,</span> <span class="n">Y_AXIS</span><span class="p">:</span> <span class="s2">&quot;y-axis&quot;</span><span class="p">,</span> <span class="n">Z_AXIS</span><span class="p">:</span> <span class="s2">&quot;z-axis&quot;</span><span class="p">,</span> <span class="n">A_AXIS</span><span class="p">:</span> <span class="s2">&quot;a-axis&quot;</span><span class="p">,</span>
             <span class="n">B_AXIS</span>        <span class="p">:</span> <span class="s2">&quot;b-axis&quot;</span><span class="p">,</span> <span class="n">C_AXIS</span><span class="p">:</span> <span class="s2">&quot;c-axis&quot;</span><span class="p">,</span> <span class="n">D_AXIS</span><span class="p">:</span> <span class="s2">&quot;d-axis&quot;</span><span class="p">,</span> <span class="n">E_AXIS</span><span class="p">:</span> <span class="s2">&quot;e-axis&quot;</span><span class="p">,</span>
             <span class="n">UNDEFINED_AXIS</span><span class="p">:</span> <span class="s2">&quot;undefined-axis&quot;</span>
             <span class="p">}</span>

<span class="n">INTENSITY_DIM</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">X_DIM</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">Y_DIM</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">Z_DIM</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">A_DIM</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">B_DIM</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">C_DIM</span> <span class="o">=</span> <span class="mi">6</span>
<span class="n">D_DIM</span> <span class="o">=</span> <span class="mi">7</span>
<span class="n">E_DIM</span> <span class="o">=</span> <span class="mi">8</span>
<span class="n">UNDEFINED_DIM</span> <span class="o">=</span> <span class="mi">9</span>
<span class="n">dimensionNames</span> <span class="o">=</span> <span class="p">{</span><span class="n">INTENSITY_DIM</span><span class="p">:</span> <span class="s2">&quot;intensity&quot;</span><span class="p">,</span>
                  <span class="n">X_DIM</span>        <span class="p">:</span> <span class="s2">&quot;x-dimension&quot;</span><span class="p">,</span> <span class="n">Y_DIM</span><span class="p">:</span> <span class="s2">&quot;y-dimension&quot;</span><span class="p">,</span> <span class="n">Z_DIM</span><span class="p">:</span> <span class="s2">&quot;z-dimension&quot;</span><span class="p">,</span> <span class="n">A_DIM</span><span class="p">:</span> <span class="s2">&quot;a-dimension&quot;</span><span class="p">,</span>
                  <span class="n">B_DIM</span>        <span class="p">:</span> <span class="s2">&quot;b-dimension&quot;</span><span class="p">,</span> <span class="n">C_DIM</span><span class="p">:</span> <span class="s2">&quot;c-dimension&quot;</span><span class="p">,</span> <span class="n">D_DIM</span><span class="p">:</span> <span class="s2">&quot;d-dimension&quot;</span><span class="p">,</span> <span class="n">E_DIM</span><span class="p">:</span> <span class="s2">&quot;e-dimension&quot;</span><span class="p">,</span>
                  <span class="n">UNDEFINED_DIM</span><span class="p">:</span> <span class="s2">&quot;undefined-dimension&quot;</span>
                 <span class="p">}</span>

<span class="n">X_DIM_INDEX</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">Y_DIM_INDEX</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">Z_DIM_INDEX</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">A_DIM_INDEX</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">B_DIM_INDEX</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">C_DIM_INDEX</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">D_DIM_INDEX</span> <span class="o">=</span> <span class="mi">6</span>
<span class="n">E_DIM_INDEX</span> <span class="o">=</span> <span class="mi">7</span>
<span class="n">UNDEFINED_DIM_INDEX</span> <span class="o">=</span> <span class="mi">8</span>


<span class="n">MagnetisationTransferTuple</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;MagnetisationTransferTuple&#39;</span><span class="p">,</span> <span class="s1">&#39;dimension1 dimension2 transferType isIndirect&#39;</span><span class="p">)</span>
<span class="n">NoiseEstimateTuple</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;NoiseEstimateTuple&#39;</span><span class="p">,</span> <span class="s1">&#39;mean std min max noiseLevel&#39;</span><span class="p">)</span>

<span class="n">FOLDING_MODE_CIRCULAR</span> <span class="o">=</span> <span class="s1">&#39;circular&#39;</span>
<span class="n">FOLDING_MODE_MIRROR</span> <span class="o">=</span> <span class="s1">&#39;mirror&#39;</span>
<span class="n">FOLDING_MODES</span> <span class="o">=</span> <span class="p">(</span><span class="n">FOLDING_MODE_CIRCULAR</span><span class="p">,</span> <span class="n">FOLDING_MODE_MIRROR</span><span class="p">)</span>

<div class="viewcode-block" id="CoherenceOrder"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.SpectrumLib.CoherenceOrder">[docs]</a><span class="k">class</span> <span class="nc">CoherenceOrder</span><span class="p">(</span><span class="n">DataEnum</span><span class="p">):</span>
    <span class="c1"># name, value, description, dataValue = number of isotope-codes per order</span>
    <span class="n">ZQ</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;Zero Quantum&#39;</span><span class="p">,</span> <span class="mi">2</span>
    <span class="n">SQ</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;Single Quantum&#39;</span><span class="p">,</span> <span class="mi">1</span>
    <span class="n">DQ</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;Double Quantum&#39;</span><span class="p">,</span> <span class="mi">2</span>
    <span class="n">TQ</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;Triple Quantum&#39;</span><span class="p">,</span> <span class="mi">3</span></div>


<span class="n">WINDOW_FUNCTION_EM</span> <span class="o">=</span> <span class="s1">&#39;EM&#39;</span>
<span class="n">WINDOW_FUNCTION_GM</span> <span class="o">=</span> <span class="s1">&#39;GM&#39;</span>
<span class="n">WINDOW_FUNCTION_SINE</span> <span class="o">=</span> <span class="s1">&#39;Sine&#39;</span>
<span class="n">WINDOW_FUNCTION_QSINE</span> <span class="o">=</span> <span class="s1">&#39;squaredSine&#39;</span>
<span class="n">WINDOW_FUNCTIONS</span> <span class="o">=</span> <span class="p">(</span><span class="n">WINDOW_FUNCTION_EM</span><span class="p">,</span> <span class="n">WINDOW_FUNCTION_GM</span><span class="p">,</span> <span class="n">WINDOW_FUNCTION_SINE</span><span class="p">,</span> <span class="n">WINDOW_FUNCTION_QSINE</span><span class="p">)</span>

<span class="c1"># These MUST match the model - (&#39;Shift&#39;,&#39;ShiftAnisotropy&#39;,&#39;JCoupling&#39;,&#39;Rdc&#39;,&#39;TROESY&#39;,&#39;DipolarCoupling&#39;,&#39;MQShift&#39;,&#39;T1&#39;,&#39;T2&#39;,&#39;T1rho&#39;,&#39;T1zz&#39;,&#39;Time&#39;,&#39;None&#39;)</span>
<span class="n">MEASUREMENT_TYPE_TIME</span> <span class="o">=</span> <span class="s1">&#39;Time&#39;</span>
<span class="n">MEASUREMENT_TYPE_SHIFT</span> <span class="o">=</span> <span class="s1">&#39;Shift&#39;</span>
<span class="n">MEASUREMENT_TYPES</span> <span class="o">=</span> <span class="p">(</span><span class="n">MEASUREMENT_TYPE_TIME</span><span class="p">,</span> <span class="n">MEASUREMENT_TYPE_SHIFT</span><span class="p">,</span> <span class="s1">&#39;ShiftAnisotropy&#39;</span><span class="p">,</span> <span class="s1">&#39;JCoupling&#39;</span><span class="p">,</span> <span class="s1">&#39;Rdc&#39;</span><span class="p">,</span> <span class="s1">&#39;TROESY&#39;</span><span class="p">,</span> <span class="s1">&#39;DipolarCoupling&#39;</span><span class="p">,</span>
                     <span class="s1">&#39;MQShift&#39;</span><span class="p">,</span> <span class="s1">&#39;T1&#39;</span><span class="p">,</span> <span class="s1">&#39;T2&#39;</span><span class="p">,</span> <span class="s1">&#39;T1rho&#39;</span><span class="p">,</span> <span class="s1">&#39;T1zz&#39;</span><span class="p">)</span>

<span class="c1"># Isotope-dependent assignment tolerances (in ppm)</span>
<span class="n">defaultAssignmentTolerance</span> <span class="o">=</span> <span class="mf">0.4</span>
<span class="n">isotope2Tolerance</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;1H&#39;</span> <span class="p">:</span> <span class="mf">0.03</span><span class="p">,</span>
    <span class="s1">&#39;13C&#39;</span><span class="p">:</span> <span class="mf">0.4</span><span class="p">,</span>
    <span class="s1">&#39;15N&#39;</span><span class="p">:</span> <span class="mf">0.4</span><span class="p">,</span>
    <span class="s1">&#39;19F&#39;</span><span class="p">:</span> <span class="mf">0.03</span><span class="p">,</span>
    <span class="p">}</span>

<span class="n">SPECTRUM_POSITIONS</span> <span class="o">=</span> <span class="s1">&#39;positions&#39;</span>
<span class="n">SPECTRUM_INTENSITIES</span> <span class="o">=</span> <span class="s1">&#39;intensities&#39;</span>

<span class="n">MAXALIASINGRANGE</span> <span class="o">=</span> <span class="mi">3</span>


<div class="viewcode-block" id="getAssignmentTolerances"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.SpectrumLib.getAssignmentTolerances">[docs]</a><span class="k">def</span> <span class="nf">getAssignmentTolerances</span><span class="p">(</span><span class="n">isotopeCode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;:return assignmentTolerance for isotopeCode or defaultAssignment tolerance if not defined</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">isotope2Tolerance</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">isotopeCode</span><span class="p">,</span> <span class="n">defaultAssignmentTolerance</span><span class="p">)</span></div>


<span class="c1">#=========================================================================================</span>
<span class="c1"># Decorators for Spectrum attributes</span>
<span class="c1">#=========================================================================================</span>

<span class="nd">@singleton</span>
<span class="k">class</span> <span class="nc">_includeInCopyList</span><span class="p">(</span><span class="nb">list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Singleton class to store the attributes to be included when making a copy of object.</span>
<span class="sd">    Attributes can be modified and can be either non-dimensional or dimension dependent,</span>
<span class="sd">    Dynamically filled by two decorators</span>
<span class="sd">    Stored as list of (attributeName, isMultiDimensional) tuples</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">getNoneDimensional</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return a list of one-dimensional attribute names&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">attr</span> <span class="k">for</span> <span class="n">attr</span><span class="p">,</span> <span class="n">isNd</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">isNd</span> <span class="o">==</span> <span class="kc">False</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">getMultiDimensional</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return a list of one-dimensional attribute names&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">attr</span> <span class="k">for</span> <span class="n">attr</span><span class="p">,</span> <span class="n">isNd</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">isNd</span> <span class="o">==</span> <span class="kc">True</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">appendItem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attribute</span><span class="p">,</span> <span class="n">isMultidimensional</span><span class="p">):</span>
        <span class="n">_t</span> <span class="o">=</span> <span class="p">(</span><span class="n">attribute</span><span class="p">,</span> <span class="n">isMultidimensional</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">_t</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_t</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_includeInCopy</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Decorator to define that an non-dimensional attribute is to be included when making a copy of object</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">storage</span> <span class="o">=</span> <span class="n">_includeInCopyList</span><span class="p">()</span>
    <span class="n">storage</span><span class="o">.</span><span class="n">appendItem</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">isMultidimensional</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">func</span>


<span class="k">def</span> <span class="nf">_includeInDimensionalCopy</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Decorator to define that a dimensional attribute is to be included when making a copy of object</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">storage</span> <span class="o">=</span> <span class="n">_includeInCopyList</span><span class="p">()</span>
    <span class="n">storage</span><span class="o">.</span><span class="n">appendItem</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">isMultidimensional</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">func</span>


<div class="viewcode-block" id="checkSpectrumPropertyValue"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.SpectrumLib.checkSpectrumPropertyValue">[docs]</a><span class="k">def</span> <span class="nf">checkSpectrumPropertyValue</span><span class="p">(</span><span class="n">iterable</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">unique</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">allowNone</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">types</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="p">(),</span>
                               <span class="n">enumerated</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="p">(),</span> <span class="n">mapping</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Decorator to check values of the Spectrum class property setters</span>

<span class="sd">    :param iterable: True, False: indicates that value should be an iterable</span>
<span class="sd">    :param unique: True, False: indicates if iterable items should be unique</span>
<span class="sd">    :param allowNone: True, False indicates if None value is allowed</span>
<span class="sd">    :param types: a tuple of allowed types for value; value is cast into first type</span>
<span class="sd">    :param enumerated: a tuple/list indicating that value should be one of the items of the tuple</span>
<span class="sd">    :param mapping: an optional (originalValue, mappedValue) mapping dict; applied to</span>
<span class="sd">                    the value or values-items</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">allowNone</span><span class="p">:</span>
        <span class="n">types</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">types</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">)])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">enumerated</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">enumerated</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">enumerated</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">mapping</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mapping</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">checkType</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">attributeName</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check and optional casts value</span>
<span class="sd">        :param obj: the object checked</span>
<span class="sd">        :param attributeName: the attribute of object</span>
<span class="sd">        :param value:</span>
<span class="sd">        :return: value cast into types[0]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">checkedValue</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">allowNone</span> <span class="ow">and</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Value for &quot;</span><span class="si">%s</span><span class="s1">&quot; of </span><span class="si">%s</span><span class="s1"> cannot be None)&#39;</span> <span class="o">%</span>
                             <span class="p">(</span><span class="n">attributeName</span><span class="p">,</span> <span class="n">obj</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">types</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">types</span><span class="p">):</span>
                <span class="n">typeNames</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="vm">__name__</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">types</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Value for &quot;</span><span class="si">%s</span><span class="s1">&quot; of </span><span class="si">%s</span><span class="s1"> needs to be of type </span><span class="si">%s</span><span class="s1">; got </span><span class="si">%r</span><span class="s1"> (type </span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span>
                                 <span class="p">(</span><span class="n">attributeName</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">typeNames</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
            <span class="c1"># cast into types[0]</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">checkedValue</span> <span class="o">=</span> <span class="n">types</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">checkedValue</span>

    <span class="k">def</span> <span class="nf">checkIterable</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">attributeName</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check for iterable properties</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">set</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Value for &quot;</span><span class="si">%s</span><span class="s1">&quot; of </span><span class="si">%s</span><span class="s1"> needs to be one of (list, tuple, set); got </span><span class="si">%r</span><span class="s1"> (type </span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span>
                             <span class="p">(</span><span class="n">attributeName</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">!=</span> <span class="n">obj</span><span class="o">.</span><span class="n">dimensionCount</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Value for &quot;</span><span class="si">%s</span><span class="s1">&quot; of </span><span class="si">%s</span><span class="s1"> needs to be an iterable of length </span><span class="si">%d</span><span class="s1">; got </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span>
                             <span class="p">(</span><span class="n">attributeName</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">dimensionCount</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">unique</span><span class="p">:</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="p">[</span><span class="n">val</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">value</span> <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">vals</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The items of &quot;</span><span class="si">%s</span><span class="s1">&quot; of </span><span class="si">%s</span><span class="s1"> need to be unique; got </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span>
                                 <span class="p">(</span><span class="n">attributeName</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">checkEnumerate</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">attributeName</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if values needs to be in enumerate</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">enumerated</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">enumerated</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Value for &quot;</span><span class="si">%s</span><span class="s1">&quot; of </span><span class="si">%s</span><span class="s1"> needs to be of </span><span class="si">%r</span><span class="s1">; got </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span>
                             <span class="p">(</span><span class="n">attributeName</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">enumerated</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">value</span>

    <span class="nd">@decorator</span><span class="o">.</span><span class="n">decorator</span>
    <span class="k">def</span> <span class="nf">theDecorator</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

        <span class="c1"># if func.__name__ == &#39;measurementTypes&#39;:</span>
        <span class="c1">#     print(&#39;&gt;&gt;&gt;&#39;, isIterable, types, enumerated)</span>

        <span class="k">if</span> <span class="n">iterable</span><span class="p">:</span>
            <span class="n">checkIterable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

            <span class="c1"># check the individual elements</span>
            <span class="n">checkedValue</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mapping</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

                <span class="n">_itemName</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">[</span><span class="si">%d</span><span class="s1">]&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">checkType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_itemName</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">checkEnumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_itemName</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
                <span class="n">checkedValue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mapping</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="n">checkedValue</span> <span class="o">=</span> <span class="n">checkType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="n">checkedValue</span> <span class="o">=</span> <span class="n">checkEnumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">checkedValue</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">checkedValue</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">theDecorator</span></div>


<span class="c1">#=========================================================================================</span>


<span class="c1"># def _oldEstimateNoiseLevel1D(x, y, factor=3):</span>
<span class="c1">#   &quot;&quot;&quot;</span>
<span class="c1">#   :param x,y:  spectrum.positions, spectrum.intensities</span>
<span class="c1">#   :param factor: optional. Increase factor to increase the STD and therefore the noise level threshold</span>
<span class="c1">#   :return: float of estimated noise threshold</span>
<span class="c1">#   &quot;&quot;&quot;</span>
<span class="c1">#</span>
<span class="c1">#   data = np.array([x, y])</span>
<span class="c1">#   dataStd = np.std(data)</span>
<span class="c1">#   data = np.array(data, np.float32)</span>
<span class="c1">#   data = data.clip(-dataStd, dataStd)</span>
<span class="c1">#   value = factor * np.std(data)</span>
<span class="c1">#   return value</span>


<span class="k">def</span> <span class="nf">_oldEstimateNoiseLevel1D</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Estimates the noise threshold based on the max intensity of the first portion of the spectrum where</span>
<span class="sd">    only noise is present. To increase the threshold value: increase the factor.</span>
<span class="sd">    return:  float of estimated noise threshold</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># print(&#39;_oldEstimateNoiseLevel1D&#39;,max(y[:int(len(y)/20)]) * factor, &#39;STD, &#39;)</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">y</span><span class="p">[:</span><span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">/</span> <span class="mi">20</span><span class="p">)])</span> <span class="o">*</span> <span class="n">factor</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>


<span class="k">def</span> <span class="nf">_calibrateX1D</span><span class="p">(</span><span class="n">spectrum</span><span class="p">,</span> <span class="n">currentPosition</span><span class="p">,</span> <span class="n">newPosition</span><span class="p">):</span>
    <span class="n">shift</span> <span class="o">=</span> <span class="n">newPosition</span> <span class="o">-</span> <span class="n">currentPosition</span>
    <span class="n">spectrum</span><span class="o">.</span><span class="n">referenceValues</span> <span class="o">=</span> <span class="p">[</span><span class="n">spectrum</span><span class="o">.</span><span class="n">referenceValues</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">shift</span><span class="p">]</span>
    <span class="n">spectrum</span><span class="o">.</span><span class="n">positions</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">positions</span> <span class="o">+</span> <span class="n">shift</span>


<span class="k">def</span> <span class="nf">_calibrateY1D</span><span class="p">(</span><span class="n">spectrum</span><span class="p">,</span> <span class="n">currentPosition</span><span class="p">,</span> <span class="n">newPosition</span><span class="p">):</span>
    <span class="n">shift</span> <span class="o">=</span> <span class="n">newPosition</span> <span class="o">-</span> <span class="n">currentPosition</span>
    <span class="n">spectrum</span><span class="o">.</span><span class="n">intensities</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">intensities</span> <span class="o">+</span> <span class="n">shift</span>


<span class="k">def</span> <span class="nf">_calibrateXND</span><span class="p">(</span><span class="n">spectrum</span><span class="p">,</span> <span class="n">strip</span><span class="p">,</span> <span class="n">currentPosition</span><span class="p">,</span> <span class="n">newPosition</span><span class="p">):</span>
    <span class="c1"># map the X change to the correct spectrum axis</span>
    <span class="n">spectrumReferencing</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">spectrum</span><span class="o">.</span><span class="n">referenceValues</span><span class="p">)</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">getAxisCodeMatchIndices</span><span class="p">(</span><span class="n">strip</span><span class="o">.</span><span class="n">axisCodes</span><span class="p">,</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">axisCodes</span><span class="p">)</span>

    <span class="c1"># as modifying the spectrum, spectrum needs to be the second argument of getAxisCodeMatchIndices</span>
    <span class="n">spectrumReferencing</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">spectrumReferencing</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+</span> <span class="p">(</span><span class="n">newPosition</span> <span class="o">-</span> <span class="n">currentPosition</span><span class="p">))</span>
    <span class="n">spectrum</span><span class="o">.</span><span class="n">referenceValues</span> <span class="o">=</span> <span class="n">spectrumReferencing</span>


<span class="k">def</span> <span class="nf">_calibrateNDAxis</span><span class="p">(</span><span class="n">spectrum</span><span class="p">,</span> <span class="n">axisIndex</span><span class="p">,</span> <span class="n">currentPosition</span><span class="p">,</span> <span class="n">newPosition</span><span class="p">):</span>
    <span class="c1"># map the X change to the correct spectrum axis</span>
    <span class="n">spectrumReferencing</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">spectrum</span><span class="o">.</span><span class="n">referenceValues</span><span class="p">)</span>

    <span class="c1"># as modifying the spectrum, spectrum needs to be the second argument of getAxisCodeMatchIndices</span>
    <span class="n">spectrumReferencing</span><span class="p">[</span><span class="n">axisIndex</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">spectrumReferencing</span><span class="p">[</span><span class="n">axisIndex</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">newPosition</span> <span class="o">-</span> <span class="n">currentPosition</span><span class="p">))</span>
    <span class="n">spectrum</span><span class="o">.</span><span class="n">referenceValues</span> <span class="o">=</span> <span class="n">spectrumReferencing</span>


<span class="k">def</span> <span class="nf">_calibrateYND</span><span class="p">(</span><span class="n">spectrum</span><span class="p">,</span> <span class="n">strip</span><span class="p">,</span> <span class="n">currentPosition</span><span class="p">,</span> <span class="n">newPosition</span><span class="p">):</span>
    <span class="c1"># map the Y change to the correct spectrum axis</span>
    <span class="n">spectrumReferencing</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">spectrum</span><span class="o">.</span><span class="n">referenceValues</span><span class="p">)</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">getAxisCodeMatchIndices</span><span class="p">(</span><span class="n">strip</span><span class="o">.</span><span class="n">axisCodes</span><span class="p">,</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">axisCodes</span><span class="p">)</span>

    <span class="c1"># as modifying the spectrum, spectrum needs to be the second argument of getAxisCodeMatchIndices</span>
    <span class="n">spectrumReferencing</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">spectrumReferencing</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+</span> <span class="p">(</span><span class="n">newPosition</span> <span class="o">-</span> <span class="n">currentPosition</span><span class="p">))</span>
    <span class="n">spectrum</span><span class="o">.</span><span class="n">referenceValues</span> <span class="o">=</span> <span class="n">spectrumReferencing</span>


<span class="k">def</span> <span class="nf">_set1DRawDataFromCcpnInternal</span><span class="p">(</span><span class="n">spectrum</span><span class="p">):</span>
    <span class="n">_positions</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">_getInternalParameter</span><span class="p">(</span><span class="n">SPECTRUM_POSITIONS</span><span class="p">)</span>
    <span class="n">_intensities</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">_getInternalParameter</span><span class="p">(</span><span class="n">SPECTRUM_INTENSITIES</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">_positions</span> <span class="ow">or</span> <span class="n">_intensities</span><span class="p">):</span>
        <span class="k">return</span>
    <span class="n">spectrum</span><span class="o">.</span><span class="n">positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">_positions</span><span class="p">)</span>
    <span class="n">spectrum</span><span class="o">.</span><span class="n">intensities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">_intensities</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_negLogLikelihood</span><span class="p">(</span><span class="n">deltas</span><span class="p">,</span> <span class="n">queryPeakPositions</span><span class="p">,</span> <span class="n">kde</span><span class="p">):</span>
    <span class="n">shifted</span> <span class="o">=</span> <span class="n">queryPeakPositions</span> <span class="o">-</span> <span class="n">deltas</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">kde</span><span class="o">.</span><span class="n">logpdf</span><span class="p">(</span><span class="n">shifted</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>


<div class="viewcode-block" id="align2HSQCs"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.SpectrumLib.align2HSQCs">[docs]</a><span class="k">def</span> <span class="nf">align2HSQCs</span><span class="p">(</span><span class="n">refSpectrum</span><span class="p">,</span> <span class="n">querySpectrum</span><span class="p">,</span> <span class="n">refPeakListIdx</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">queryPeakListIdx</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="c1"># Get hold of the peakLists in the two spectra</span>
    <span class="n">queryPeakList</span> <span class="o">=</span> <span class="n">querySpectrum</span><span class="o">.</span><span class="n">peakLists</span><span class="p">[</span><span class="n">queryPeakListIdx</span><span class="p">]</span>
    <span class="n">refPeakList</span> <span class="o">=</span> <span class="n">refSpectrum</span><span class="o">.</span><span class="n">peakLists</span><span class="p">[</span><span class="n">refPeakListIdx</span><span class="p">]</span>

    <span class="c1"># Create numpy arrays containing the peak positions of</span>
    <span class="c1"># each peakList</span>

    <span class="n">refPeakPositions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">peak</span><span class="o">.</span><span class="n">position</span> <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">refPeakList</span><span class="o">.</span><span class="n">peaks</span><span class="p">])</span>
    <span class="n">queryPeakPositions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">peak</span><span class="o">.</span><span class="n">position</span> <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">queryPeakList</span><span class="o">.</span><span class="n">peaks</span><span class="p">])</span>

    <span class="c1"># Align the two numpy arrays by centre of mass</span>
    <span class="n">refMean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">refPeakPositions</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">queryMean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">queryPeakPositions</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">roughShift</span> <span class="o">=</span> <span class="n">queryMean</span> <span class="o">-</span> <span class="n">refMean</span>
    <span class="n">shiftedQueryPeakPositions</span> <span class="o">=</span> <span class="n">queryPeakPositions</span> <span class="o">-</span> <span class="n">roughShift</span>

    <span class="c1"># Define a log-likelihood target for fitting the query</span>
    <span class="c1"># peak positions</span>
    <span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">leastsq</span>
    <span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">gaussian_kde</span>

    <span class="c1"># Create the Gaussian KDE</span>
    <span class="n">kde</span> <span class="o">=</span> <span class="n">gaussian_kde</span><span class="p">(</span><span class="n">refPeakPositions</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">bw_method</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>

    <span class="c1"># Get hold of the values to overlay the two spectra</span>
    <span class="n">shifts</span><span class="p">,</span> <span class="n">status</span> <span class="o">=</span> <span class="n">leastsq</span><span class="p">(</span><span class="n">_negLogLikelihood</span><span class="p">,</span> <span class="n">roughShift</span><span class="p">,</span>
                             <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">queryPeakPositions</span><span class="p">,</span> <span class="n">kde</span><span class="p">))</span>

    <span class="c1"># Get hold of the reference values of the querySpectrum</span>
    <span class="n">queryRefValues</span> <span class="o">=</span> <span class="n">queryPeakList</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">referenceValues</span>

    <span class="c1"># Calculate the corrected reference values</span>
    <span class="n">correctedValues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">queryRefValues</span><span class="p">)</span> <span class="o">-</span> <span class="n">shifts</span>

    <span class="k">return</span> <span class="n">shifts</span><span class="p">,</span> <span class="n">correctedValues</span></div>


<span class="k">def</span> <span class="nf">_estimate1DSpectrumSNR</span><span class="p">(</span><span class="n">spectrum</span><span class="p">,</span> <span class="n">engine</span><span class="o">=</span><span class="s1">&#39;max&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    :param spectrum:</span>
<span class="sd">    :type spectrum:</span>
<span class="sd">    :param engine: max: calculate using the max intensity of all spectrum</span>
<span class="sd">    :type engine:</span>
<span class="sd">    :return:</span>
<span class="sd">    :rtype:</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">engines</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;max&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">,</span> <span class="s1">&#39;mean&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span> <span class="s1">&#39;std&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">}</span>

    <span class="k">if</span> <span class="n">engine</span> <span class="ow">in</span> <span class="n">engines</span><span class="p">:</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">engines</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Engine not recognised. Using Default&#39;</span><span class="p">)</span>
    <span class="n">_snr</span> <span class="o">=</span> <span class="n">estimateSNR</span><span class="p">(</span><span class="n">noiseLevels</span><span class="o">=</span><span class="p">[</span><span class="n">spectrum</span><span class="o">.</span><span class="n">noiseLevel</span><span class="p">,</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">negativeNoiseLevel</span><span class="p">],</span>
                       <span class="n">signalPoints</span><span class="o">=</span><span class="p">[</span><span class="n">func</span><span class="p">(</span><span class="n">spectrum</span><span class="o">.</span><span class="n">intensities</span><span class="p">)])</span>

    <span class="k">return</span> <span class="n">_snr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>


<span class="c1"># refSpectrum = project.spectra[]</span>
<span class="c1"># querySpectrum = project.spectra[]</span>
<span class="c1"># a = align2HSQCs(refSpectrum, querySpectrum, refPeakListIdx=-1, queryPeakListIdx=-1)</span>
<span class="c1">#</span>
<span class="c1"># for peak in querySpectrum.peakLists[-1].peaks:</span>
<span class="c1">#     p1,p2  = peak.position[0], peak.position[1]</span>
<span class="c1">#     p1x = p1-(a[0][0])</span>
<span class="c1">#     p2x = p2-(a[0][1])</span>
<span class="c1">#     peak.position = (p1x,p2x)</span>


<span class="c1">#------------------------------------------------------------------------------------------------------</span>
<span class="c1"># Spectrum projection</span>
<span class="c1"># GWV: Adapted from DataSource.py</span>
<span class="c1">#------------------------------------------------------------------------------------------------------</span>

<span class="n">PROJECTION_METHODS</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;max&#39;</span><span class="p">,</span> <span class="s1">&#39;max above threshold&#39;</span><span class="p">,</span> <span class="s1">&#39;min&#39;</span><span class="p">,</span> <span class="s1">&#39;min below threshold&#39;</span><span class="p">,</span>
                      <span class="s1">&#39;sum&#39;</span><span class="p">,</span> <span class="s1">&#39;sum above threshold&#39;</span><span class="p">,</span> <span class="s1">&#39;sum below threshold&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_getProjection</span><span class="p">(</span><span class="n">spectrum</span><span class="p">,</span> <span class="n">axisCodes</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;max&#39;</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get projected plane defined by axisCodes using method and optional threshold</span>
<span class="sd">    return projected data array</span>

<span class="sd">    NB Called by Spectrum.getProjection</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">PROJECTION_METHODS</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;For spectrum projection, method must be one of </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">PROJECTION_METHODS</span><span class="p">,))</span>

    <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;threshold&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;For spectrum projection method &quot;</span><span class="si">%s</span><span class="s1">&quot;, threshold parameter must be defined&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">method</span><span class="p">,))</span>

    <span class="n">projectedData</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">position</span><span class="p">,</span> <span class="n">planeData</span> <span class="ow">in</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">allPlanes</span><span class="p">(</span><span class="n">axisCodes</span><span class="p">,</span> <span class="n">exactMatch</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;sum above threshold&#39;</span> <span class="ow">or</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;max above threshold&#39;</span><span class="p">:</span>
            <span class="n">lowIndices</span> <span class="o">=</span> <span class="n">planeData</span> <span class="o">&lt;</span> <span class="n">threshold</span>
            <span class="n">planeData</span><span class="p">[</span><span class="n">lowIndices</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;sum below threshold&#39;</span> <span class="ow">or</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;min below threshold&#39;</span><span class="p">:</span>
            <span class="n">lowIndices</span> <span class="o">=</span> <span class="n">planeData</span> <span class="o">&gt;</span> <span class="o">-</span><span class="n">threshold</span>
            <span class="n">planeData</span><span class="p">[</span><span class="n">lowIndices</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">projectedData</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># first plane</span>
            <span class="n">projectedData</span> <span class="o">=</span> <span class="n">planeData</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;max&#39;</span> <span class="ow">or</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;max above threshold&#39;</span><span class="p">:</span>
            <span class="n">projectedData</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">projectedData</span><span class="p">,</span> <span class="n">planeData</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;min&#39;</span> <span class="ow">or</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;min below threshold&#39;</span><span class="p">:</span>
            <span class="n">projectedData</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">projectedData</span><span class="p">,</span> <span class="n">planeData</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">projectedData</span> <span class="o">+=</span> <span class="n">planeData</span>

    <span class="k">return</span> <span class="n">projectedData</span>


<span class="c1">#------------------------------------------------------------------------------------------------------</span>
<span class="c1">#  Baseline Correction for 1D spectra</span>
<span class="c1"># 14/2/2017</span>
<span class="c1">#</span>
<span class="c1"># Baseline Correction for 1D spectra.</span>
<span class="c1"># Multiple algorithms comparison:</span>
<span class="c1">#</span>
<span class="c1"># -Asl</span>
<span class="c1"># -Whittaker Smooth</span>
<span class="c1"># -AirPls</span>
<span class="c1"># -ArPls</span>
<span class="c1"># -Lowess</span>
<span class="c1"># -Polynomial Fit</span>
<span class="c1">#</span>
<span class="c1"># NB: Yet To be tested the newest algorithm found in literature based on machine learning:</span>
<span class="c1"># “Estimating complicated baselines in analytical signals using the iterative training of</span>
<span class="c1"># Bayesian regularized artificial neural networks. Abolfazl Valadkhani et al.</span>
<span class="c1"># Analytica Chimica Acta. September 2016 DOI: 10.1016/j.aca.2016.08.046</span>
<span class="c1">#</span>
<span class="c1">#------------------------------------------------------------------------------------------------------</span>

<span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="kn">import</span> <span class="n">csc_matrix</span><span class="p">,</span> <span class="n">eye</span><span class="p">,</span> <span class="n">diags</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">sparse</span>
<span class="kn">from</span> <span class="nn">scipy.sparse.linalg</span> <span class="kn">import</span> <span class="n">spsolve</span>


<div class="viewcode-block" id="als"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.SpectrumLib.als">[docs]</a><span class="k">def</span> <span class="nf">als</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">lam</span><span class="o">=</span><span class="mi">10</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span> <span class="n">nIter</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Implements an Asymmetric Least Squares (Asl) Smoothing</span>
<span class="sd">    baseline correction algorithm</span>
<span class="sd">    H C Eilers, Paul &amp; F M Boelens, Hans. (2005). Baseline Correction with Asymmetric Least Squares Smoothing. Unpubl. Manuscr. .</span>

<span class="sd">    y = signal</span>
<span class="sd">    lam = smoothness, 10**2 ≤ λ ≤ 10**9.</span>
<span class="sd">    p = asymmetry, 0.001 ≤ p ≤ 0.1 is a good choice for a signal with positive peaks.</span>
<span class="sd">    niter = Number of iteration, default 10.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nIter</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nIter</span><span class="p">)</span>
    <span class="n">L</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csc_matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">L</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nIter</span><span class="p">):</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">spdiags</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">W</span> <span class="o">+</span> <span class="n">lam</span> <span class="o">*</span> <span class="n">D</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">spsolve</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="n">w</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">p</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span> <span class="o">&gt;</span> <span class="n">z</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">z</span></div>


<div class="viewcode-block" id="WhittakerSmooth"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.SpectrumLib.WhittakerSmooth">[docs]</a><span class="k">def</span> <span class="nf">WhittakerSmooth</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">lambda_</span><span class="p">,</span> <span class="n">differences</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Whittaker Smooth algorithm</span>
<span class="sd">    no licence, source from web</span>
<span class="sd">    Penalized least squares algorithm for background fitting</span>

<span class="sd">    input</span>
<span class="sd">        x: input data (i.e. chromatogram of spectrum)</span>
<span class="sd">        w: binary masks (value of the mask is zero if a point belongs to peaks and one otherwise)</span>
<span class="sd">        lambda_: parameter that can be adjusted by user. The larger lambda is,  the smoother the resulting background</span>
<span class="sd">        differences: integer indicating the order of the difference of penalties</span>

<span class="sd">    output</span>
<span class="sd">        the fitted background vector</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">size</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
    <span class="n">E</span> <span class="o">=</span> <span class="n">eye</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;csc&#39;</span><span class="p">)</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">E</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">E</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># numpy.diff() does not work with sparse matrix. This is a workaround.</span>
    <span class="n">W</span> <span class="o">=</span> <span class="n">diags</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">m</span><span class="p">))</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">csc_matrix</span><span class="p">(</span><span class="n">W</span> <span class="o">+</span> <span class="p">(</span><span class="n">lambda_</span> <span class="o">*</span> <span class="n">D</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">D</span><span class="p">))</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">csc_matrix</span><span class="p">(</span><span class="n">W</span> <span class="o">*</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    <span class="n">background</span> <span class="o">=</span> <span class="n">spsolve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">background</span><span class="p">)</span></div>


<div class="viewcode-block" id="airPLS"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.SpectrumLib.airPLS">[docs]</a><span class="k">def</span> <span class="nf">airPLS</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">lambda_</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">porder</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">itermax</span><span class="o">=</span><span class="mi">15</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    airPLS algorithm</span>
<span class="sd">    no licence, source from web</span>
<span class="sd">    Adaptive iteratively reweighted penalized least squares for baseline fitting</span>

<span class="sd">    input</span>
<span class="sd">        x: input data (i.e. chromatogram of spectrum)</span>
<span class="sd">        lambda_: parameter that can be adjusted by user. The larger lambda is,  the smoother the resulting background, z</span>
<span class="sd">        porder: adaptive iteratively reweighted penalized least squares for baseline fitting</span>

<span class="sd">    output</span>
<span class="sd">        the fitted background vector</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">itermax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">itermax</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">itermax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">WhittakerSmooth</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">lambda_</span><span class="p">,</span> <span class="n">porder</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">z</span>
        <span class="n">dssn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">d</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dssn</span> <span class="o">&lt;</span> <span class="mf">0.001</span> <span class="o">*</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">==</span> <span class="n">itermax</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">itermax</span><span class="p">):</span>
                <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;max iteration reached!&#39;</span><span class="p">)</span>
            <span class="k">break</span>
        <span class="n">w</span><span class="p">[</span><span class="n">d</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># d&gt;0 means that this point is part of a peak, so its weight is set to 0 in order to ignore it</span>
        <span class="n">w</span><span class="p">[</span><span class="n">d</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">d</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">dssn</span><span class="p">)</span>
        <span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">d</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">/</span> <span class="n">dssn</span><span class="p">)</span>
        <span class="n">w</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">z</span></div>


<div class="viewcode-block" id="polynomialFit"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.SpectrumLib.polynomialFit">[docs]</a><span class="k">def</span> <span class="nf">polynomialFit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">order</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    polynomial Fit algorithm</span>
<span class="sd">    :param x: x values</span>
<span class="sd">    :param y: y values</span>
<span class="sd">    :param order: polynomial order</span>
<span class="sd">    :return: fitted baseline</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">deg</span><span class="o">=</span><span class="n">order</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fit</span></div>


<div class="viewcode-block" id="arPLS"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.SpectrumLib.arPLS">[docs]</a><span class="k">def</span> <span class="nf">arPLS</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">lambda_</span><span class="o">=</span><span class="mf">5.e5</span><span class="p">,</span> <span class="n">ratio</span><span class="o">=</span><span class="mf">1.e-6</span><span class="p">,</span> <span class="n">itermax</span><span class="o">=</span><span class="mi">50</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    arPLS algorithm</span>
<span class="sd">    Baseline correction using asymmetrically reweighted penalized least squares</span>
<span class="sd">    smoothing.</span>
<span class="sd">    http://pubs.rsc.org/en/Content/ArticleLanding/2015/AN/C4AN01061B#!divAbstract</span>

<span class="sd">    :param y: The 1D spectrum</span>
<span class="sd">    :param lambda_: (Optional) Adjusts the balance between fitness and smoothness.</span>
<span class="sd">                    A smaller lamda_ favors fitness.</span>
<span class="sd">                    Default is 1.e5.</span>
<span class="sd">    :param ratio: (Optional) Iteration will stop when the weights stop changing.</span>
<span class="sd">                    (weights_(i) - weights_(i+1)) / (weights_(i)) &lt; ratio.</span>
<span class="sd">                    Default is 1.e-6.</span>
<span class="sd">    :returns: The smoothed baseline of y.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">itermax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">itermax</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

    <span class="n">N</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">E</span> <span class="o">=</span> <span class="n">eye</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;csc&#39;</span><span class="p">)</span>
    <span class="c1"># numpy.diff() does not work with sparse matrix. This is a workaround.</span>
    <span class="c1"># It creates the second order difference matrix.</span>
    <span class="c1"># [1 -2 1 ......]</span>
    <span class="c1"># [0 1 -2 1 ....]</span>
    <span class="c1"># [.............]</span>
    <span class="c1"># [.... 0 1 -2 1]</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">E</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">E</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">E</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>

    <span class="n">H</span> <span class="o">=</span> <span class="n">lambda_</span> <span class="o">*</span> <span class="n">D</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">D</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

    <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">itermax</span> <span class="o">+</span> <span class="mi">10</span><span class="p">):</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">diags</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="n">W</span> <span class="o">+</span> <span class="n">H</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">W</span> <span class="o">*</span> <span class="n">Y</span><span class="o">.</span><span class="n">T</span>

        <span class="n">z</span> <span class="o">=</span> <span class="n">spsolve</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">z</span>
        <span class="n">dn</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">d</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">]</span>

        <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dn</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
            <span class="c1"># add a tiny bit of noise to Y</span>
            <span class="n">y2</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">!=</span> <span class="mf">0.</span><span class="p">:</span>
                <span class="n">y2</span> <span class="o">+=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1000.</span>
            <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">y2</span> <span class="o">+=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1000.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">y2</span> <span class="o">+=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1000.</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">y2</span>
            <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">y2</span><span class="p">)</span>
            <span class="n">W</span> <span class="o">=</span> <span class="n">diags</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span>
            <span class="n">Q</span> <span class="o">=</span> <span class="n">W</span> <span class="o">+</span> <span class="n">H</span>
            <span class="n">B</span> <span class="o">=</span> <span class="n">W</span> <span class="o">*</span> <span class="n">Y</span><span class="o">.</span><span class="n">T</span>

            <span class="n">z</span> <span class="o">=</span> <span class="n">spsolve</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">z</span>
            <span class="n">dn</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">d</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">]</span>

            <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dn</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">wt</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mf">2.</span> <span class="o">*</span> <span class="p">(</span><span class="n">d</span> <span class="o">-</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">s</span> <span class="o">-</span> <span class="n">m</span><span class="p">))</span> <span class="o">/</span> <span class="n">s</span><span class="p">))</span>

        <span class="c1"># check exit condition</span>
        <span class="n">condition</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">w</span> <span class="o">-</span> <span class="n">wt</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">condition</span> <span class="o">&lt;</span> <span class="n">ratio</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">itermax</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">wt</span>

    <span class="k">return</span> <span class="n">z</span></div>


<div class="viewcode-block" id="arPLS_Implementation"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.SpectrumLib.arPLS_Implementation">[docs]</a><span class="k">def</span> <span class="nf">arPLS_Implementation</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">lambdaValue</span><span class="o">=</span><span class="mf">5.e4</span><span class="p">,</span> <span class="n">maxValue</span><span class="o">=</span><span class="mf">1e6</span><span class="p">,</span> <span class="n">minValue</span><span class="o">=-</span><span class="mf">1e6</span><span class="p">,</span> <span class="n">itermax</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">interpolate</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implementation of the  arPLS algorithm</span>
<span class="sd">    :param maxValue = maxValue of the baseline noise</span>
<span class="sd">    :param minValue = minValue of the baseline noise</span>
<span class="sd">    :param interpolate: Where are the peaks: interpolate the points from neighbours otherwise set them to 0.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">lenghtY</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="n">sparseMatrix</span> <span class="o">=</span> <span class="n">eye</span><span class="p">(</span><span class="n">lenghtY</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;csc&#39;</span><span class="p">)</span>
    <span class="n">differenceMatrix</span> <span class="o">=</span> <span class="n">sparseMatrix</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">sparseMatrix</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">sparseMatrix</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">lambdaValue</span> <span class="o">*</span> <span class="n">differenceMatrix</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">differenceMatrix</span>

    <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">lenghtY</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">itermax</span><span class="p">):</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">diags</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">lenghtY</span><span class="p">,</span> <span class="n">lenghtY</span><span class="p">))</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="n">W</span> <span class="o">+</span> <span class="n">H</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">W</span> <span class="o">*</span> <span class="n">Y</span><span class="o">.</span><span class="n">T</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">spsolve</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
        <span class="n">mymask</span> <span class="o">=</span> <span class="p">(</span><span class="n">z</span> <span class="o">&gt;</span> <span class="n">maxValue</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">z</span> <span class="o">&lt;</span> <span class="n">minValue</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_where</span><span class="p">(</span><span class="n">mymask</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">interpolate</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mymask</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">mymask</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">mymask</span><span class="p">)[</span><span class="mi">0</span><span class="p">]])</span>
            <span class="n">b</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mymask</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">c</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">b</span></div>


<span class="c1"># GWV disabled 5/8/2021</span>
<span class="c1"># def lowess(x, y):</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     LOWESS (Locally Weighted Scatterplot Smoothing).</span>
<span class="c1">#     A lowess function that outs smoothed estimates of endog</span>
<span class="c1">#     at the given exog values from points (exog, endog)</span>
<span class="c1">#     To use this, you need to install statsmodels in your miniconda:</span>
<span class="c1">#      - conda install statsmodels or pip install --upgrade --no-deps statsmodels</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#</span>
<span class="c1">#     from scipy.interpolate import interp1d</span>
<span class="c1">#     #FIXME: invalid import</span>
<span class="c1">#     import statsmodels.api as sm</span>
<span class="c1">#</span>
<span class="c1">#     # introduce some floats in our x-values</span>
<span class="c1">#</span>
<span class="c1">#     # lowess will return our &quot;smoothed&quot; data with a y value for at every x-value</span>
<span class="c1">#     lowess = sm.nonparametric.lowess(y, x, frac=.3)</span>
<span class="c1">#</span>
<span class="c1">#     # unpack the lowess smoothed points to their values</span>
<span class="c1">#     lowess_x = list(zip(*lowess))[0]</span>
<span class="c1">#     lowess_y = list(zip(*lowess))[1]</span>
<span class="c1">#</span>
<span class="c1">#     # run scipy&#39;s interpolation. There is also extrapolation I believe</span>
<span class="c1">#     f = interp1d(lowess_x, lowess_y, bounds_error=False)</span>
<span class="c1">#</span>
<span class="c1">#     # this this generate y values for our xvalues by our interpolator</span>
<span class="c1">#     # it will MISS values outsite of the x window (less than 3, greater than 33)</span>
<span class="c1">#     # There might be a better approach, but you can run a for loop</span>
<span class="c1">#     # and if the value is out of the range, use f(min(lowess_x)) or f(max(lowess_x))</span>
<span class="c1">#     ynew = f(x)</span>
<span class="c1">#     return ynew</span>


<div class="viewcode-block" id="nmrGlueBaselineCorrector"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.SpectrumLib.nmrGlueBaselineCorrector">[docs]</a><span class="k">def</span> <span class="nf">nmrGlueBaselineCorrector</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">wd</span><span class="o">=</span><span class="mi">20</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :param data: 1D ndarray</span>
<span class="sd">        One dimensional NMR data with real value (intensities)</span>
<span class="sd">        wd : float  Median window size in pts.</span>
<span class="sd">    :return: same as data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">nmrglue</span> <span class="k">as</span> <span class="nn">ng</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">ng</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">proc_bl</span><span class="o">.</span><span class="n">baseline_corrector</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">wd</span><span class="o">=</span><span class="n">wd</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">data</span></div>


<span class="k">def</span> <span class="nf">_getDefaultApiSpectrumColours</span><span class="p">(</span><span class="n">spectrum</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Get the default colours from the core spectrum class</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># from ccpn.util.Colour import spectrumHexColours</span>
    <span class="kn">from</span> <span class="nn">ccpn.ui.gui.guiSettings</span> <span class="kn">import</span> <span class="n">getColours</span><span class="p">,</span> <span class="n">SPECTRUM_HEXCOLOURS</span><span class="p">,</span> <span class="n">SPECTRUM_HEXDEFAULTCOLOURS</span>
    <span class="kn">from</span> <span class="nn">ccpn.util.Colour</span> <span class="kn">import</span> <span class="n">hexToRgb</span><span class="p">,</span> <span class="n">findNearestHex</span><span class="p">,</span> <span class="n">invertRGBHue</span><span class="p">,</span> <span class="n">rgbToHex</span>

    <span class="n">dimensionCount</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">dimensionCount</span>
    <span class="n">serial</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">_serial</span>
    <span class="n">expSerial</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">experiment</span><span class="o">.</span><span class="n">serial</span>

    <span class="n">spectrumHexColours</span> <span class="o">=</span> <span class="n">getColours</span><span class="p">()</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">SPECTRUM_HEXCOLOURS</span><span class="p">)</span>
    <span class="n">spectrumHexDefaultColours</span> <span class="o">=</span> <span class="n">getColours</span><span class="p">()</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">SPECTRUM_HEXDEFAULTCOLOURS</span><span class="p">)</span>

    <span class="c1"># use different colour lists for 1d and Nd</span>
    <span class="k">if</span> <span class="n">dimensionCount</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">colorCount</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">spectrumHexColours</span><span class="p">)</span>
        <span class="n">step</span> <span class="o">=</span> <span class="p">((</span><span class="n">colorCount</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">kk</span> <span class="o">=</span> <span class="n">colorCount</span> <span class="o">//</span> <span class="mi">7</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">expSerial</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">step</span> <span class="o">*</span> <span class="p">(</span><span class="n">serial</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">posCol</span> <span class="o">=</span> <span class="n">spectrumHexColours</span><span class="p">[(</span><span class="n">kk</span> <span class="o">*</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">10</span><span class="p">)</span> <span class="o">%</span> <span class="n">colorCount</span><span class="p">]</span>
        <span class="n">negCol</span> <span class="o">=</span> <span class="n">spectrumHexColours</span><span class="p">[((</span><span class="n">kk</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">10</span><span class="p">)</span> <span class="o">%</span> <span class="n">colorCount</span><span class="p">]</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># try and get the colourPalette number from the preferences, otherwise use 0</span>
            <span class="kn">from</span> <span class="nn">ccpn.framework.Application</span> <span class="kn">import</span> <span class="n">getApplication</span>

            <span class="n">colourPalette</span> <span class="o">=</span> <span class="n">getApplication</span><span class="p">()</span><span class="o">.</span><span class="n">preferences</span><span class="o">.</span><span class="n">general</span><span class="o">.</span><span class="n">colourPalette</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">colourPalette</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">colourPalette</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># colours for Vicky :)</span>
            <span class="n">colorCount</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">spectrumHexDefaultColours</span><span class="p">)</span>
            <span class="n">step</span> <span class="o">=</span> <span class="p">((</span><span class="n">colorCount</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">expSerial</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">step</span> <span class="o">*</span> <span class="p">(</span><span class="n">serial</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">posCol</span> <span class="o">=</span> <span class="n">spectrumHexDefaultColours</span><span class="p">[(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">index</span><span class="p">)</span> <span class="o">%</span> <span class="n">colorCount</span><span class="p">]</span>
            <span class="n">negCol</span> <span class="o">=</span> <span class="n">spectrumHexDefaultColours</span><span class="p">[(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">colorCount</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># automatic colours</span>
            <span class="n">colorCount</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">spectrumHexColours</span><span class="p">)</span>
            <span class="n">step</span> <span class="o">=</span> <span class="p">((</span><span class="n">colorCount</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">kk</span> <span class="o">=</span> <span class="mi">11</span>  <span class="c1">#colorCount // 11</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">expSerial</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">step</span> <span class="o">*</span> <span class="p">(</span><span class="n">serial</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">posCol</span> <span class="o">=</span> <span class="n">spectrumHexColours</span><span class="p">[(</span><span class="n">kk</span> <span class="o">*</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">10</span><span class="p">)</span> <span class="o">%</span> <span class="n">colorCount</span><span class="p">]</span>

            <span class="c1"># invert the colour by reversing the ycbcr palette</span>
            <span class="n">rgbIn</span> <span class="o">=</span> <span class="n">hexToRgb</span><span class="p">(</span><span class="n">posCol</span><span class="p">)</span>
            <span class="n">negRGB</span> <span class="o">=</span> <span class="n">invertRGBHue</span><span class="p">(</span><span class="o">*</span><span class="n">rgbIn</span><span class="p">)</span>
            <span class="n">oppCol</span> <span class="o">=</span> <span class="n">rgbToHex</span><span class="p">(</span><span class="o">*</span><span class="n">negRGB</span><span class="p">)</span>
            <span class="c1"># get the nearest one in the current colour list, so colourName exists</span>
            <span class="n">negCol</span> <span class="o">=</span> <span class="n">findNearestHex</span><span class="p">(</span><span class="n">oppCol</span><span class="p">,</span> <span class="n">spectrumHexColours</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">posCol</span><span class="p">,</span> <span class="n">negCol</span><span class="p">)</span>


<div class="viewcode-block" id="getDefaultSpectrumColours"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.SpectrumLib.getDefaultSpectrumColours">[docs]</a><span class="k">def</span> <span class="nf">getDefaultSpectrumColours</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="s1">&#39;Spectrum&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Get default positivecontourcolour, negativecontourcolour for Spectrum</span>
<span class="sd">    (calculated by hashing spectrum properties to avoid always getting the same colours</span>
<span class="sd">    Currently matches getDefaultColours in dataSource that is set through the api</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_getDefaultApiSpectrumColours</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


<div class="viewcode-block" id="get1DdataInRange"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.SpectrumLib.get1DdataInRange">[docs]</a><span class="k">def</span> <span class="nf">get1DdataInRange</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">xRange</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :param x:</span>
<span class="sd">    :param y:</span>
<span class="sd">    :param xRange:</span>
<span class="sd">    :return: x,y within the xRange (minXrange,maxXrange)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">xRange</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
    <span class="n">point1</span><span class="p">,</span> <span class="n">point2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">xRange</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">xRange</span><span class="p">)</span>
    <span class="n">x_filtered</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">point1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="n">point2</span><span class="p">))</span>
    <span class="n">y_filtered</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">x_filtered</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">x_filtered</span><span class="p">,</span> <span class="n">y_filtered</span></div>


<span class="k">def</span> <span class="nf">_recurseData</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="n">dataList</span><span class="p">,</span> <span class="n">startCondition</span><span class="p">,</span> <span class="n">endCondition</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Iterate over the dataArray, subdividing each iteration</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">dataList</span><span class="p">:</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">data</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="c1"># calculate the noise values</span>
        <span class="n">flatData</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

        <span class="n">SD</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">flatData</span><span class="p">)</span>
        <span class="nb">max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">flatData</span><span class="p">)</span>
        <span class="nb">min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">flatData</span><span class="p">)</span>
        <span class="n">mn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">flatData</span><span class="p">)</span>
        <span class="n">noiseLevel</span> <span class="o">=</span> <span class="n">mn</span> <span class="o">+</span> <span class="mf">3.5</span> <span class="o">*</span> <span class="n">SD</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">startCondition</span><span class="p">:</span>
            <span class="n">startCondition</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">SD</span><span class="p">,</span> <span class="nb">max</span><span class="p">,</span> <span class="nb">min</span><span class="p">,</span> <span class="n">mn</span><span class="p">,</span> <span class="n">noiseLevel</span><span class="p">]</span>
            <span class="n">endCondition</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">startCondition</span><span class="p">[:]</span>

        <span class="k">if</span> <span class="n">SD</span> <span class="o">&lt;</span> <span class="n">endCondition</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
            <span class="n">endCondition</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">SD</span><span class="p">,</span> <span class="nb">max</span><span class="p">,</span> <span class="nb">min</span><span class="p">,</span> <span class="n">mn</span><span class="p">,</span> <span class="n">noiseLevel</span><span class="p">]</span>

        <span class="c1"># stop iterating when all dimensions are &lt;= 64 elements</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">dim</span> <span class="o">&gt;</span> <span class="mi">64</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>

            <span class="n">newData</span> <span class="o">=</span> <span class="p">[</span><span class="n">data</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)):</span>
                <span class="n">newData</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array_split</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">jj</span><span class="p">)</span> <span class="k">for</span> <span class="n">dd</span> <span class="ow">in</span> <span class="n">newData</span><span class="p">]</span>
                <span class="n">newData</span> <span class="o">=</span> <span class="p">[</span><span class="n">val</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">newData</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">sublist</span><span class="p">]</span>

            <span class="n">_recurseData</span><span class="p">(</span><span class="n">ii</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">newData</span><span class="p">,</span> <span class="n">startCondition</span><span class="p">,</span> <span class="n">endCondition</span><span class="p">)</span>


<span class="c1"># keep for a minute - example of how to call _recurseData</span>
<span class="c1"># # iterate over the array to calculate noise at each level</span>
<span class="c1"># dataList = [dataArray]</span>
<span class="c1"># startCondition = []</span>
<span class="c1"># endCondition = []</span>
<span class="c1"># _recurseData(0, dataList, startCondition, endCondition)</span>


<span class="c1">#------------------------------------------------------------------------------------------------------</span>


<span class="n">DEFAULTMULTIPLIER</span> <span class="o">=</span> <span class="mf">1.414214</span>
<span class="n">DEFAULTLEVELS</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">DEFAULTCONTOURBASE</span> <span class="o">=</span> <span class="mf">10000.0</span>


<div class="viewcode-block" id="setContourLevelsFromNoise"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.SpectrumLib.setContourLevelsFromNoise">[docs]</a><span class="k">def</span> <span class="nf">setContourLevelsFromNoise</span><span class="p">(</span><span class="n">spectrum</span><span class="p">,</span> <span class="n">setNoiseLevel</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                              <span class="n">setPositiveContours</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">setNegativeContours</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                              <span class="n">useDefaultMultiplier</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">useDefaultLevels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">useDefaultContourBase</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                              <span class="n">useSameMultiplier</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                              <span class="n">defaultMultiplier</span><span class="o">=</span><span class="n">DEFAULTMULTIPLIER</span><span class="p">,</span> <span class="n">defaultLevels</span><span class="o">=</span><span class="n">DEFAULTLEVELS</span><span class="p">,</span> <span class="n">defaultContourBase</span><span class="o">=</span><span class="n">DEFAULTCONTOURBASE</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate the noise level, base contour level and positive/negative multipliers for the given spectrum</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># parameter error checking</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">setNoiseLevel</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;setNoiseLevel is not boolean.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">setPositiveContours</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;setPositiveContours is not boolean.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">setNegativeContours</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;setNegativeContours is not boolean.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">useDefaultMultiplier</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;useDefaultMultiplier is not boolean.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">useDefaultLevels</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;useDefaultLevels is not boolean.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">useDefaultContourBase</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;useDefaultContourBase is not boolean.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">useSameMultiplier</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;useSameMultiplier is not boolean.&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">defaultMultiplier</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">and</span> <span class="n">defaultMultiplier</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;defaultMultiplier is not a positive float.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">defaultLevels</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">defaultLevels</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;defaultLevels is not a positive int.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">defaultContourBase</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">and</span> <span class="n">defaultContourBase</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;defaultContourBase is not a positive float.&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">dimensionCount</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="c1"># exit if nothing set</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">setNoiseLevel</span> <span class="ow">or</span> <span class="n">setPositiveContours</span> <span class="ow">or</span> <span class="n">setNegativeContours</span><span class="p">):</span>
        <span class="k">return</span>

    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">x</span> <span class="o">!=</span> <span class="s1">&#39;Frequency&#39;</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">dimensionTypes</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;setContourLevelsFromNoise not implemented for processed frequency spectra, dimension types were: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spectrum</span><span class="o">.</span><span class="n">dimensionTypes</span><span class="p">,</span> <span class="p">))</span>

    <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;estimating noise level for spectrum </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">spectrum</span><span class="o">.</span><span class="n">pid</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">setNoiseLevel</span><span class="p">:</span>
        <span class="c1"># get noise level using random sampling method - may be slow for large spectra</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="n">getNoiseEstimate</span><span class="p">(</span><span class="n">spectrum</span><span class="p">)</span>
        <span class="n">base</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">noiseLevel</span> <span class="o">=</span> <span class="n">noise</span><span class="o">.</span><span class="n">noiseLevel</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">base</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">noiseLevel</span>
        <span class="c1"># need to generate a min/max</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="n">getContourEstimate</span><span class="p">(</span><span class="n">spectrum</span><span class="p">)</span>

    <span class="c1"># noise =&gt; noise.mean, noise.std, noise.min, noise.max, noise.noiseLevel</span>

    <span class="k">if</span> <span class="n">useDefaultLevels</span><span class="p">:</span>
        <span class="n">posLevels</span> <span class="o">=</span> <span class="n">defaultLevels</span>
        <span class="n">negLevels</span> <span class="o">=</span> <span class="n">defaultLevels</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># get from the spectrum</span>
        <span class="n">posLevels</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">positiveContourCount</span>
        <span class="n">negLevels</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">negativeContourCount</span>

    <span class="k">if</span> <span class="n">useDefaultMultiplier</span><span class="p">:</span>
        <span class="c1"># use default as root2</span>
        <span class="n">posMult</span> <span class="o">=</span> <span class="n">negMult</span> <span class="o">=</span> <span class="n">defaultMultiplier</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># calculate multiplier to give contours across range of spectrum; trap base = 0</span>
        <span class="n">mx</span> <span class="o">=</span> <span class="n">noise</span><span class="o">.</span><span class="n">max</span>
        <span class="n">mn</span> <span class="o">=</span> <span class="n">noise</span><span class="o">.</span><span class="n">min</span>

        <span class="n">posMult</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">mx</span> <span class="o">/</span> <span class="n">base</span><span class="p">),</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">posLevels</span><span class="p">)</span> <span class="k">if</span> <span class="n">base</span> <span class="k">else</span> <span class="mf">0.0</span>
        <span class="k">if</span> <span class="n">useSameMultiplier</span><span class="p">:</span>
            <span class="n">negMult</span> <span class="o">=</span> <span class="n">posMult</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">negMult</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">mn</span> <span class="o">/</span> <span class="n">base</span><span class="p">),</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">negLevels</span><span class="p">)</span> <span class="k">if</span> <span class="n">base</span> <span class="k">else</span> <span class="mf">0.0</span>

    <span class="k">if</span> <span class="n">setPositiveContours</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">spectrum</span><span class="o">.</span><span class="n">positiveContourBase</span> <span class="o">=</span> <span class="n">base</span>
            <span class="n">spectrum</span><span class="o">.</span><span class="n">positiveContourFactor</span> <span class="o">=</span> <span class="n">posMult</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">es</span><span class="p">:</span>

            <span class="c1"># set to defaults if an error occurs</span>
            <span class="n">spectrum</span><span class="o">.</span><span class="n">positiveContourBase</span> <span class="o">=</span> <span class="n">defaultContourBase</span>
            <span class="n">spectrum</span><span class="o">.</span><span class="n">positiveContourFactor</span> <span class="o">=</span> <span class="n">defaultMultiplier</span>
            <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Error setting contour levels - </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">es</span><span class="p">))</span>

        <span class="n">spectrum</span><span class="o">.</span><span class="n">positiveContourCount</span> <span class="o">=</span> <span class="n">posLevels</span>

    <span class="k">if</span> <span class="n">setNegativeContours</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">spectrum</span><span class="o">.</span><span class="n">negativeContourBase</span> <span class="o">=</span> <span class="o">-</span><span class="n">base</span>
            <span class="n">spectrum</span><span class="o">.</span><span class="n">negativeContourFactor</span> <span class="o">=</span> <span class="n">negMult</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">es</span><span class="p">:</span>

            <span class="c1"># set to defaults if an error occurs</span>
            <span class="n">spectrum</span><span class="o">.</span><span class="n">negativeContourBase</span> <span class="o">=</span> <span class="o">-</span><span class="n">defaultContourBase</span>
            <span class="n">spectrum</span><span class="o">.</span><span class="n">negativeContourFactor</span> <span class="o">=</span> <span class="n">defaultMultiplier</span>
            <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Error setting contour levels - </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">es</span><span class="p">))</span>

        <span class="n">spectrum</span><span class="o">.</span><span class="n">negativeContourCount</span> <span class="o">=</span> <span class="n">negLevels</span>

    <span class="k">return</span></div>


<div class="viewcode-block" id="getContourLevelsFromNoise"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.SpectrumLib.getContourLevelsFromNoise">[docs]</a><span class="k">def</span> <span class="nf">getContourLevelsFromNoise</span><span class="p">(</span><span class="n">spectrum</span><span class="p">,</span>
                              <span class="n">setPositiveContours</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">setNegativeContours</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                              <span class="n">useDefaultMultiplier</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">useDefaultLevels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">useDefaultContourBase</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                              <span class="n">useSameMultiplier</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                              <span class="n">defaultMultiplier</span><span class="o">=</span><span class="n">DEFAULTMULTIPLIER</span><span class="p">,</span> <span class="n">defaultLevels</span><span class="o">=</span><span class="n">DEFAULTLEVELS</span><span class="p">,</span> <span class="n">defaultContourBase</span><span class="o">=</span><span class="n">DEFAULTCONTOURBASE</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate the noise level, base contour level and positive/negative multipliers for the given spectrum</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># parameter error checking</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">setPositiveContours</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;setPositiveContours is not boolean.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">setNegativeContours</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;setNegativeContours is not boolean.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">useDefaultMultiplier</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;useDefaultMultiplier is not boolean.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">useDefaultLevels</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;useDefaultLevels is not boolean.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">useDefaultContourBase</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;useDefaultContourBase is not boolean.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">useSameMultiplier</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;useSameMultiplier is not boolean.&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">defaultMultiplier</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">and</span> <span class="n">defaultMultiplier</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;defaultMultiplier is not a positive float.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">defaultLevels</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">defaultLevels</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;defaultLevels is not a positive int.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">defaultContourBase</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">and</span> <span class="n">defaultContourBase</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;defaultContourBase is not a positive float.&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">dimensionCount</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="mi">6</span>

    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">x</span> <span class="o">!=</span> <span class="s1">&#39;Frequency&#39;</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">dimensionTypes</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;getContourLevelsFromNoise not implemented for processed frequency spectra, dimension types were: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spectrum</span><span class="o">.</span><span class="n">dimensionTypes</span><span class="p">,</span> <span class="p">))</span>

    <span class="c1"># need to generate a min/max</span>
    <span class="n">noise</span> <span class="o">=</span> <span class="n">getContourEstimate</span><span class="p">(</span><span class="n">spectrum</span><span class="p">)</span>

    <span class="c1"># noise =&gt; noise.mean, noise.std, noise.min, noise.max, noise.noiseLevel</span>

    <span class="k">if</span> <span class="n">useDefaultLevels</span><span class="p">:</span>
        <span class="n">posLevels</span> <span class="o">=</span> <span class="n">defaultLevels</span>
        <span class="n">negLevels</span> <span class="o">=</span> <span class="n">defaultLevels</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># get from the spectrum</span>
        <span class="n">posLevels</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">positiveContourCount</span>
        <span class="n">negLevels</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">negativeContourCount</span>

    <span class="k">if</span> <span class="n">useDefaultContourBase</span><span class="p">:</span>
        <span class="n">posBase</span> <span class="o">=</span> <span class="n">defaultContourBase</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># calculate the base levels</span>
        <span class="n">posBase</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">noiseLevel</span>
    <span class="n">negBase</span> <span class="o">=</span> <span class="o">-</span><span class="n">posBase</span> <span class="k">if</span> <span class="n">posBase</span> <span class="k">else</span> <span class="mf">0.0</span>

    <span class="k">if</span> <span class="n">useDefaultMultiplier</span><span class="p">:</span>
        <span class="c1"># use default as root2</span>
        <span class="n">posMult</span> <span class="o">=</span> <span class="n">negMult</span> <span class="o">=</span> <span class="n">defaultMultiplier</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># calculate multiplier to give contours across range of spectrum; trap base = 0</span>
        <span class="n">mx</span> <span class="o">=</span> <span class="n">noise</span><span class="o">.</span><span class="n">max</span>
        <span class="n">mn</span> <span class="o">=</span> <span class="n">noise</span><span class="o">.</span><span class="n">min</span>

        <span class="n">posMult</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">mx</span> <span class="o">/</span> <span class="n">posBase</span><span class="p">),</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">posLevels</span><span class="p">)</span> <span class="k">if</span> <span class="n">posBase</span> <span class="k">else</span> <span class="mf">0.0</span>
        <span class="k">if</span> <span class="n">useSameMultiplier</span><span class="p">:</span>
            <span class="n">negMult</span> <span class="o">=</span> <span class="n">posMult</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">negMult</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">mn</span> <span class="o">/</span> <span class="n">negBase</span><span class="p">),</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">negLevels</span><span class="p">)</span> <span class="k">if</span> <span class="n">negBase</span> <span class="k">else</span> <span class="mf">0.0</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">setPositiveContours</span><span class="p">:</span>
        <span class="n">posBase</span> <span class="o">=</span> <span class="n">posMult</span> <span class="o">=</span> <span class="n">posLevels</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">setNegativeContours</span><span class="p">:</span>
        <span class="n">negBase</span> <span class="o">=</span> <span class="n">negMult</span> <span class="o">=</span> <span class="n">negLevels</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">return</span> <span class="n">posBase</span><span class="p">,</span> <span class="n">negBase</span><span class="p">,</span> <span class="n">posMult</span><span class="p">,</span> <span class="n">negMult</span><span class="p">,</span> <span class="n">posLevels</span><span class="p">,</span> <span class="n">negLevels</span></div>


<div class="viewcode-block" id="getClippedRegion"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.SpectrumLib.getClippedRegion">[docs]</a><span class="k">def</span> <span class="nf">getClippedRegion</span><span class="p">(</span><span class="n">spectrum</span><span class="p">,</span> <span class="n">strip</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the clipped region, bounded by the (ppmPoint(1), ppmPoint(n)) in visible order</span>

<span class="sd">    If sorting is True, returns a tuple(tuple(minPpm, maxPpm), ...) for each region</span>
<span class="sd">    else returns tuple(tuple(ppmLeft, ppmRight), ...)</span>

<span class="sd">    :param spectrum:</span>
<span class="sd">    :param strip:</span>
<span class="sd">    :return:</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># calculate the visible region</span>
    <span class="n">selectedRegion</span> <span class="o">=</span> <span class="p">[</span><span class="n">strip</span><span class="o">.</span><span class="n">getAxisRegion</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">strip</span><span class="o">.</span><span class="n">getAxisRegion</span><span class="p">(</span><span class="mi">1</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">strip</span><span class="o">.</span><span class="n">orderedAxes</span><span class="p">[</span><span class="mi">2</span><span class="p">:]:</span>
        <span class="n">selectedRegion</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">n</span><span class="o">.</span><span class="n">region</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">n</span><span class="o">.</span><span class="n">region</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

    <span class="c1"># use the ppmArrays to get the first/last point of the data</span>
    <span class="k">if</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">dimensionCount</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">ppmArrays</span> <span class="o">=</span> <span class="p">[</span><span class="n">spectrum</span><span class="o">.</span><span class="n">getPpmArray</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ppmArrays</span> <span class="o">=</span> <span class="p">[</span><span class="n">spectrum</span><span class="o">.</span><span class="n">getPpmArray</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="n">dim</span><span class="p">)</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">getByAxisCodes</span><span class="p">(</span><span class="s1">&#39;dimensions&#39;</span><span class="p">,</span> <span class="n">strip</span><span class="o">.</span><span class="n">axisCodes</span><span class="p">)]</span>

    <span class="c1"># clip to the ppmArrays, not taking aliased regions into account</span>
    <span class="k">if</span> <span class="n">sort</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">region</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">limits</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">limits</span><span class="p">))))</span> <span class="k">for</span> <span class="n">region</span><span class="p">,</span> <span class="n">limits</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">selectedRegion</span><span class="p">,</span> <span class="n">ppmArrays</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">region</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">limits</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">limits</span><span class="p">)))</span> <span class="k">for</span> <span class="n">region</span><span class="p">,</span> <span class="n">limits</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">selectedRegion</span><span class="p">,</span> <span class="n">ppmArrays</span><span class="p">))</span></div>


<div class="viewcode-block" id="getNoiseEstimateFromRegion"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.SpectrumLib.getNoiseEstimateFromRegion">[docs]</a><span class="k">def</span> <span class="nf">getNoiseEstimateFromRegion</span><span class="p">(</span><span class="n">spectrum</span><span class="p">,</span> <span class="n">strip</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the noise estimate from the visible region of the strip</span>

<span class="sd">    :param spectrum:</span>
<span class="sd">    :param strip:</span>
<span class="sd">    :return:</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># calculate the region over which to estimate the noise</span>
    <span class="n">sortedSelectedRegion</span> <span class="o">=</span> <span class="n">getClippedRegion</span><span class="p">(</span><span class="n">spectrum</span><span class="p">,</span> <span class="n">strip</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">dimensionCount</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">getByAxisCodes</span><span class="p">(</span><span class="s1">&#39;dimensions&#39;</span><span class="p">,</span> <span class="n">strip</span><span class="o">.</span><span class="n">axisCodes</span><span class="p">)</span>

    <span class="n">regionDict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">ac</span><span class="p">,</span> <span class="n">region</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">strip</span><span class="o">.</span><span class="n">axisCodes</span><span class="p">,</span> <span class="n">sortedSelectedRegion</span><span class="p">):</span>
        <span class="n">regionDict</span><span class="p">[</span><span class="n">ac</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">region</span><span class="p">)</span>

    <span class="c1"># get the data</span>
    <span class="n">dataArray</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">getRegion</span><span class="p">(</span><span class="o">**</span><span class="n">regionDict</span><span class="p">)</span>

    <span class="c1"># calculate the noise values</span>
    <span class="n">flatData</span> <span class="o">=</span> <span class="n">dataArray</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

    <span class="n">std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">flatData</span><span class="p">)</span>
    <span class="nb">max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">flatData</span><span class="p">)</span>
    <span class="nb">min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">flatData</span><span class="p">)</span>
    <span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">flatData</span><span class="p">)</span>

    <span class="n">value</span> <span class="o">=</span> <span class="n">NoiseEstimateTuple</span><span class="p">(</span><span class="n">mean</span><span class="o">=</span><span class="n">mean</span><span class="p">,</span>
                               <span class="n">std</span><span class="o">=</span><span class="n">std</span> <span class="o">*</span> <span class="mf">1.1</span> <span class="k">if</span> <span class="n">std</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="mf">1.0</span><span class="p">,</span>
                               <span class="nb">min</span><span class="o">=</span><span class="nb">min</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="nb">max</span><span class="p">,</span>
                               <span class="n">noiseLevel</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

    <span class="c1"># noise function is defined here, but needs cleaning up</span>
    <span class="k">return</span> <span class="n">_noiseFunc</span><span class="p">(</span><span class="n">value</span><span class="p">)</span></div>


<div class="viewcode-block" id="getSpectrumNoise"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.SpectrumLib.getSpectrumNoise">[docs]</a><span class="k">def</span> <span class="nf">getSpectrumNoise</span><span class="p">(</span><span class="n">spectrum</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the noise level for a spectrum. If the noise level is not already set it will</span>
<span class="sd">    be set at an estimated value.</span>

<span class="sd">    .. describe:: Input</span>

<span class="sd">    spectrum</span>

<span class="sd">    .. describe:: Output</span>

<span class="sd">    Float</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">noise</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">noiseLevel</span>
    <span class="k">if</span> <span class="n">noise</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="n">getNoiseEstimate</span><span class="p">(</span><span class="n">spectrum</span><span class="p">)</span>
        <span class="n">spectrum</span><span class="o">.</span><span class="n">noiseLevel</span> <span class="o">=</span> <span class="n">noise</span><span class="o">.</span><span class="n">noiseLevel</span>
    <span class="k">return</span> <span class="n">noise</span></div>


<div class="viewcode-block" id="getNoiseEstimate"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.SpectrumLib.getNoiseEstimate">[docs]</a><span class="k">def</span> <span class="nf">getNoiseEstimate</span><span class="p">(</span><span class="n">spectrum</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get an estimate of the noiseLevel from the spectrum</span>

<span class="sd">    noiseLevel is calculated as abs(mean) + 3.5 * SD</span>

<span class="sd">    Calculated from a random subset of points</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># NOTE:ED more detail needed</span>

    <span class="n">fractPerAxis</span> <span class="o">=</span> <span class="mf">0.04</span>
    <span class="n">subsetFract</span> <span class="o">=</span> <span class="mf">0.25</span>
    <span class="n">fract</span> <span class="o">=</span> <span class="mf">0.1</span>
    <span class="n">maxSamples</span> <span class="o">=</span> <span class="mi">10000</span>

    <span class="n">npts</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">pointCounts</span>

    <span class="c1"># take % of points in each axis</span>
    <span class="n">_fract</span> <span class="o">=</span> <span class="p">(</span><span class="n">fractPerAxis</span> <span class="o">**</span> <span class="nb">len</span><span class="p">(</span><span class="n">npts</span><span class="p">))</span>
    <span class="n">nsamples</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">npts</span><span class="p">)</span> <span class="o">*</span> <span class="n">_fract</span><span class="p">),</span> <span class="n">maxSamples</span><span class="p">)</span>
    <span class="n">nsubsets</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">nsamples</span> <span class="o">*</span> <span class="n">subsetFract</span><span class="p">))</span>

    <span class="k">with</span> <span class="n">notificationEchoBlocking</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">_getNoiseEstimate</span><span class="p">(</span><span class="n">spectrum</span><span class="p">,</span> <span class="n">nsamples</span><span class="p">,</span> <span class="n">nsubsets</span><span class="p">,</span> <span class="n">fract</span><span class="p">)</span></div>


<div class="viewcode-block" id="getContourEstimate"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.SpectrumLib.getContourEstimate">[docs]</a><span class="k">def</span> <span class="nf">getContourEstimate</span><span class="p">(</span><span class="n">spectrum</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get an estimate of the contour settings from the spectrum</span>
<span class="sd">    Calculated from a random subset of points</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">fractPerAxis</span> <span class="o">=</span> <span class="mf">0.04</span>
    <span class="n">subsetFract</span> <span class="o">=</span> <span class="mf">0.01</span>
    <span class="n">fract</span> <span class="o">=</span> <span class="mf">0.1</span>
    <span class="n">maxSamples</span> <span class="o">=</span> <span class="mi">10000</span>

    <span class="n">npts</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">pointCounts</span>

    <span class="c1"># take % of points in each axis</span>
    <span class="n">_fract</span> <span class="o">=</span> <span class="p">(</span><span class="n">fractPerAxis</span> <span class="o">**</span> <span class="nb">len</span><span class="p">(</span><span class="n">npts</span><span class="p">))</span>
    <span class="n">nsamples</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">npts</span><span class="p">)</span> <span class="o">*</span> <span class="n">_fract</span><span class="p">),</span> <span class="n">maxSamples</span><span class="p">)</span>
    <span class="n">nsubsets</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">nsamples</span> <span class="o">*</span> <span class="n">subsetFract</span><span class="p">))</span>

    <span class="k">with</span> <span class="n">notificationEchoBlocking</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">_getContourEstimate</span><span class="p">(</span><span class="n">spectrum</span><span class="p">,</span> <span class="n">nsamples</span><span class="p">,</span> <span class="n">nsubsets</span><span class="p">,</span> <span class="n">fract</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_noiseFunc</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
    <span class="c1"># take the &#39;value&#39; NoiseEstimateTuple and add the noiseLevel</span>
    <span class="k">return</span> <span class="n">NoiseEstimateTuple</span><span class="p">(</span><span class="n">mean</span><span class="o">=</span><span class="n">value</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span>
                              <span class="n">std</span><span class="o">=</span><span class="n">value</span><span class="o">.</span><span class="n">std</span><span class="p">,</span>
                              <span class="nb">min</span><span class="o">=</span><span class="n">value</span><span class="o">.</span><span class="n">min</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="n">value</span><span class="o">.</span><span class="n">max</span><span class="p">,</span>
                              <span class="n">noiseLevel</span><span class="o">=</span><span class="nb">abs</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">mean</span><span class="p">)</span> <span class="o">+</span> <span class="mf">3.5</span> <span class="o">*</span> <span class="n">value</span><span class="o">.</span><span class="n">std</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_getNoiseEstimate</span><span class="p">(</span><span class="n">spectrum</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">nsubsets</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">fraction</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Estimate the noise level for a spectrum.</span>

<span class="sd">    &#39;nsamples&#39; random samples are taken from the spectrum</span>
<span class="sd">    &#39;nsubsets&#39; is the number of random permutations of data taken from the</span>
<span class="sd">    and finding subsets with the lowest standard deviation</span>

<span class="sd">    A tuple (mean, SD, min, max noiseLevel) is returned from the subset with the lowest standard deviation.</span>
<span class="sd">    mean is the mean of the minimum random subset, SD is the standard deviation, min/max are the minimum/maximum values,</span>
<span class="sd">    and noiseLevel is the estimated noiseLevel caluated as abs(mean) + 3.5 * SD</span>

<span class="sd">    :param spectrum: input spectrum</span>
<span class="sd">    :param nsamples: number reandom samples</span>
<span class="sd">    :param nsubsets: number of subsets</span>
<span class="sd">    :param fraction: subset fraction</span>
<span class="sd">    :return: tuple(mean, SD, min, max, noiseLevel)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">npts</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">pointCounts</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nsamples</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;nsamples must be an int&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;</span> <span class="n">nsamples</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">npts</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;nsamples must be in range [1, </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">npts</span><span class="p">)</span><span class="si">}</span><span class="s1">]&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nsubsets</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;nsubsets must be an int&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;</span> <span class="n">nsubsets</span> <span class="o">&lt;=</span> <span class="n">nsamples</span><span class="p">):</span>
        <span class="c1"># not strictly necessary but stops huge values</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;nsubsets must be in range [1, </span><span class="si">{</span><span class="n">nsamples</span><span class="si">}</span><span class="s1">]&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fraction</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;fraction must be a float&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;</span> <span class="n">fraction</span> <span class="o">&lt;=</span> <span class="mf">1.0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;fraction must be i the range (0, 1]&#39;</span><span class="p">)</span>

    <span class="c1"># create a list of random points in the spectrum, get only points that are not nan/inf</span>
    <span class="c1"># getPointValue is the slow bit</span>
    <span class="n">allPts</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">min</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">())</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">npts</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsamples</span><span class="p">)]</span>
    <span class="n">_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">spectrum</span><span class="o">.</span><span class="n">getPointValue</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">allPts</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">_list</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">_list</span><span class="p">)]</span>
    <span class="n">fails</span> <span class="o">=</span> <span class="n">nsamples</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">fails</span><span class="p">:</span>
        <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Attempt to access </span><span class="si">{</span><span class="n">fails</span><span class="si">}</span><span class="s1"> non-existent data points in spectrum </span><span class="si">{</span><span class="n">spectrum</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="c1"># check whether there are too many bad numbers in the data</span>
    <span class="n">good</span> <span class="o">=</span> <span class="n">nsamples</span> <span class="o">-</span> <span class="n">fails</span>
    <span class="k">if</span> <span class="n">good</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Spectrum </span><span class="si">{</span><span class="n">spectrum</span><span class="si">}</span><span class="s1"> contains all bad points&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">NoiseEstimateTuple</span><span class="p">(</span><span class="n">mean</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">std</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">noiseLevel</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">good</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>  <span class="c1"># arbitrary number of bad points</span>
        <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Spectrum </span><span class="si">{</span><span class="n">spectrum</span><span class="si">}</span><span class="s1"> contains minimal data&#39;</span><span class="p">)</span>
        <span class="n">maxValue</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">data</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">maxValue</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">NoiseEstimateTuple</span><span class="p">(</span><span class="n">mean</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">std</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">noiseLevel</span><span class="o">=</span><span class="mf">0.1</span> <span class="o">*</span> <span class="n">maxValue</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">NoiseEstimateTuple</span><span class="p">(</span><span class="n">mean</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">std</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">noiseLevel</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>

    <span class="n">m</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">nsamples</span> <span class="o">*</span> <span class="n">fraction</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">meanStd</span><span class="p">():</span>
        <span class="c1"># take m random values from data, and return mean/SD</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">NoiseEstimateTuple</span><span class="p">(</span><span class="n">mean</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">std</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="nb">min</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="nb">max</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">noiseLevel</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

    <span class="c1"># generate &#39;nsubsets&#39; noiseEstimates and take the one with the minimum standard deviation</span>
    <span class="n">value</span> <span class="o">=</span> <span class="nb">min</span><span class="p">((</span><span class="n">meanStd</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsubsets</span><span class="p">)),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">mSD</span><span class="p">:</span> <span class="n">mSD</span><span class="o">.</span><span class="n">std</span><span class="p">)</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">NoiseEstimateTuple</span><span class="p">(</span><span class="n">mean</span><span class="o">=</span><span class="n">value</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span>
                               <span class="n">std</span><span class="o">=</span><span class="n">value</span><span class="o">.</span><span class="n">std</span> <span class="o">*</span> <span class="mf">1.1</span> <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">std</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="mf">1.0</span><span class="p">,</span>
                               <span class="nb">min</span><span class="o">=</span><span class="n">value</span><span class="o">.</span><span class="n">min</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="n">value</span><span class="o">.</span><span class="n">max</span><span class="p">,</span>
                               <span class="n">noiseLevel</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

    <span class="n">value</span> <span class="o">=</span> <span class="n">_noiseFunc</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">value</span>


<span class="k">def</span> <span class="nf">_getDefaultOrdering</span><span class="p">(</span><span class="n">spectrum</span><span class="p">):</span>
    <span class="c1"># axisOption = spectrum.project.application.preferences.general.axisOrderingOptions</span>

    <span class="n">preferredAxisOrder</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">_preferredAxisOrdering</span>
    <span class="k">if</span> <span class="n">preferredAxisOrder</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

        <span class="n">specAxisOrder</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">axisCodes</span>
        <span class="n">axisOrder</span> <span class="o">=</span> <span class="p">[</span><span class="n">specAxisOrder</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">preferredAxisOrder</span><span class="p">]</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># sets the Nd default to HCN (or possibly 2d to HC)</span>
        <span class="n">specAxisOrder</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">axisCodes</span>
        <span class="n">pOrder</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">searchAxisCodePermutations</span><span class="p">((</span><span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;N&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">pOrder</span><span class="p">:</span>
            <span class="n">spectrum</span><span class="o">.</span><span class="n">_preferredAxisOrdering</span> <span class="o">=</span> <span class="n">pOrder</span>
            <span class="n">axisOrder</span> <span class="o">=</span> <span class="p">[</span><span class="n">specAxisOrder</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">pOrder</span><span class="p">]</span>
            <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;setting default axisOrdering: &#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">axisOrder</span><span class="p">))</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="c1"># just set to the normal ordering</span>
            <span class="n">spectrum</span><span class="o">.</span><span class="n">_preferredAxisOrdering</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ii</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">spectrum</span><span class="o">.</span><span class="n">dimensionCount</span><span class="p">))</span>
            <span class="n">axisOrder</span> <span class="o">=</span> <span class="n">specAxisOrder</span>

            <span class="c1"># try permutations of repeated codes</span>
            <span class="n">duplicates</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="s1">&#39;H&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;N&#39;</span><span class="p">,</span> <span class="s1">&#39;N&#39;</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">dCode</span> <span class="ow">in</span> <span class="n">duplicates</span><span class="p">:</span>
                <span class="n">pOrder</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">searchAxisCodePermutations</span><span class="p">(</span><span class="n">dCode</span><span class="p">)</span>

                <span class="c1"># if permutation found and matches first axis</span>
                <span class="k">if</span> <span class="n">pOrder</span> <span class="ow">and</span> <span class="n">pOrder</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">spectrum</span><span class="o">.</span><span class="n">_preferredAxisOrdering</span> <span class="o">=</span> <span class="n">pOrder</span>
                    <span class="n">axisOrder</span> <span class="o">=</span> <span class="p">[</span><span class="n">specAxisOrder</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">pOrder</span><span class="p">]</span>
                    <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;setting duplicate axisOrdering: &#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">axisOrder</span><span class="p">))</span>
                    <span class="k">break</span>

    <span class="k">return</span> <span class="n">axisOrder</span>


<span class="k">def</span> <span class="nf">_getContourEstimate</span><span class="p">(</span><span class="n">spectrum</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">nsubsets</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">fraction</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Estimate the contour levels for a spectrum.</span>

<span class="sd">    &#39;nsamples&#39; random samples are taken from the spectrum</span>
<span class="sd">    &#39;nsubsets&#39; is the number of random permutations of data taken from the</span>
<span class="sd">    and finding subsets with the lowest standard deviation</span>

<span class="sd">    A tuple (mean, SD, min, max noiseLevel) is returned from the subset with the lowest standard deviation.</span>
<span class="sd">    mean is the mean of the minimum random subset, SD is the standard deviation, min/max are the minimum/maximum values,</span>
<span class="sd">    and noiseLevel is the estimated noiseLevel caluated as abs(mean) + 3.5 * SD</span>

<span class="sd">    :param spectrum: input spectrum</span>
<span class="sd">    :param nsamples: number reandom samples</span>
<span class="sd">    :param nsubsets: number of subsets</span>
<span class="sd">    :param fraction: subset fraction</span>
<span class="sd">    :return: tuple(mean, SD, min, max, noiseLevel)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">npts</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">pointCounts</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nsamples</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;nsamples must be an int&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;</span> <span class="n">nsamples</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">npts</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;nsamples must be in range [1, </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">npts</span><span class="p">)</span><span class="si">}</span><span class="s1">]&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nsubsets</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;nsubsets must be an int&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;</span> <span class="n">nsubsets</span> <span class="o">&lt;=</span> <span class="n">nsamples</span><span class="p">):</span>
        <span class="c1"># not strictly necessary but stops huge values</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;nsubsets must be in range [1, </span><span class="si">{</span><span class="n">nsamples</span><span class="si">}</span><span class="s1">]&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fraction</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;fraction must be a float&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;</span> <span class="n">fraction</span> <span class="o">&lt;=</span> <span class="mf">1.0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;fraction must be i the range (0, 1]&#39;</span><span class="p">)</span>

    <span class="c1"># create a list of random points in the spectrum, get only points that are not nan/inf</span>
    <span class="c1"># getPointValue is the slow bit</span>
    <span class="n">allPts</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">min</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()))</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">npts</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsamples</span><span class="p">)]</span>
    <span class="n">_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">spectrum</span><span class="o">.</span><span class="n">getPointValue</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">allPts</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">_list</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">_list</span><span class="p">)]</span>
    <span class="n">fails</span> <span class="o">=</span> <span class="n">nsamples</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">fails</span><span class="p">:</span>
        <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Attempt to access </span><span class="si">{</span><span class="n">fails</span><span class="si">}</span><span class="s1"> non-existent data points in spectrum </span><span class="si">{</span><span class="n">spectrum</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="c1"># check whether there are too many bad numbers in the data</span>
    <span class="n">good</span> <span class="o">=</span> <span class="n">nsamples</span> <span class="o">-</span> <span class="n">fails</span>
    <span class="k">if</span> <span class="n">good</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Spectrum </span><span class="si">{</span><span class="n">spectrum</span><span class="si">}</span><span class="s1"> contains all bad points&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">NoiseEstimateTuple</span><span class="p">(</span><span class="n">mean</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">std</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">noiseLevel</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">good</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>  <span class="c1"># arbitrary number of bad points</span>
        <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Spectrum </span><span class="si">{</span><span class="n">spectrum</span><span class="si">}</span><span class="s1"> contains minimal data&#39;</span><span class="p">)</span>
        <span class="n">maxValue</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">data</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">maxValue</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">NoiseEstimateTuple</span><span class="p">(</span><span class="n">mean</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">std</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">noiseLevel</span><span class="o">=</span><span class="mf">0.1</span> <span class="o">*</span> <span class="n">maxValue</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">NoiseEstimateTuple</span><span class="p">(</span><span class="n">mean</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">std</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">noiseLevel</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>

    <span class="n">value</span> <span class="o">=</span> <span class="n">NoiseEstimateTuple</span><span class="p">(</span><span class="n">mean</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                               <span class="n">std</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                               <span class="nb">min</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="nb">max</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">data</span><span class="p">),</span>
                               <span class="n">noiseLevel</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">value</span>


<span class="k">def</span> <span class="nf">_signalToNoiseFunc</span><span class="p">(</span><span class="n">noise</span><span class="p">,</span> <span class="n">signal</span><span class="p">):</span>
    <span class="n">snr</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">noise</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">snr</span>


<div class="viewcode-block" id="estimateSignalRegion"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.SpectrumLib.estimateSignalRegion">[docs]</a><span class="k">def</span> <span class="nf">estimateSignalRegion</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">nlMax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nlMin</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">return</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">nlMax</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">nlMin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nlMax</span><span class="p">,</span> <span class="n">nlMin</span> <span class="o">=</span> <span class="n">estimateNoiseLevel1D</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="n">eS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">y</span> <span class="o">&gt;=</span> <span class="n">nlMax</span><span class="p">)</span>
    <span class="n">eSN</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">y</span> <span class="o">&lt;=</span> <span class="n">nlMin</span><span class="p">)</span>
    <span class="n">eN</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">nlMax</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">y</span> <span class="o">&gt;</span> <span class="n">nlMin</span><span class="p">))</span>
    <span class="n">estimatedSignalRegionPos</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">eS</span><span class="p">]</span>
    <span class="n">estimatedSignalRegionNeg</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">eSN</span><span class="p">]</span>
    <span class="n">estimatedSignalRegion</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">estimatedSignalRegionPos</span><span class="p">,</span> <span class="n">estimatedSignalRegionNeg</span><span class="p">))</span>
    <span class="n">estimatedNoiseRegion</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">eN</span><span class="p">]</span>
    <span class="n">lenghtESR</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">estimatedSignalRegion</span><span class="p">)</span>
    <span class="n">lenghtENR</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">estimatedNoiseRegion</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">lenghtESR</span> <span class="o">&gt;</span> <span class="n">lenghtENR</span><span class="p">:</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">lenghtENR</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">lenghtESR</span>
    <span class="k">if</span> <span class="n">l</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="n">estimatedNoiseRegion</span><span class="p">[:</span><span class="n">l</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">signalAndNoise</span> <span class="o">=</span> <span class="n">estimatedSignalRegion</span><span class="p">[:</span><span class="n">l</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">signal</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">signalAndNoise</span> <span class="o">-</span> <span class="n">noise</span><span class="p">)</span>
        <span class="n">signal</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>  <span class="c1"># descending</span>
        <span class="n">noise</span><span class="p">[::</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="s1">&#39;compressed&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">noise</span><span class="p">,</span> <span class="s1">&#39;compressed&#39;</span><span class="p">):</span>
            <span class="n">signal</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">compressed</span><span class="p">()</span>  <span class="c1"># remove the mask</span>
            <span class="n">noise</span> <span class="o">=</span> <span class="n">noise</span><span class="o">.</span><span class="n">compressed</span><span class="p">()</span>  <span class="c1"># remove the mask</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">signal</span><span class="p">[:</span><span class="nb">int</span><span class="p">(</span><span class="n">l</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)]</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">noise</span><span class="p">[:</span><span class="nb">int</span><span class="p">(</span><span class="n">l</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">s</span></div>


<div class="viewcode-block" id="estimateSNR"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.SpectrumLib.estimateSNR">[docs]</a><span class="k">def</span> <span class="nf">estimateSNR</span><span class="p">(</span><span class="n">noiseLevels</span><span class="p">,</span> <span class="n">signalPoints</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mf">2.5</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    SNratio = factor*(height/|NoiseMax-NoiseMin|)</span>
<span class="sd">    :param noiseLevels: (max, min) floats</span>
<span class="sd">    :param signalPoints: iterable of floats estimated to be signal or peak heights</span>
<span class="sd">    :param factor: default 2.5</span>
<span class="sd">    :return: array of snr for each point compared to the delta noise level</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">maxNL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">noiseLevels</span><span class="p">)</span>
    <span class="n">minNL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">noiseLevels</span><span class="p">)</span>
    <span class="n">dd</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">maxNL</span> <span class="o">-</span> <span class="n">minNL</span><span class="p">)</span>
    <span class="n">pp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">signalPoints</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">dd</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">dd</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">snRatios</span> <span class="o">=</span> <span class="p">(</span><span class="n">factor</span> <span class="o">*</span> <span class="n">pp</span><span class="p">)</span> <span class="o">/</span> <span class="n">dd</span>
        <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">snRatios</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">signalPoints</span><span class="p">)</span></div>


<div class="viewcode-block" id="estimateNoiseLevel1D"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.SpectrumLib.estimateNoiseLevel1D">[docs]</a><span class="k">def</span> <span class="nf">estimateNoiseLevel1D</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">f</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">stdFactor</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    :param y: the y region of the spectrum.</span>
<span class="sd">    :param f: percentage of the spectrum to use. If given a portion known to be just noise, set it to 100.</span>
<span class="sd">    :param stdFactor: 0 to don&#39;t adjust the initial guess.</span>
<span class="sd">    :return: tuple (float, float) of estimated noise threshold  as max and min</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">eMax</span><span class="p">,</span> <span class="n">eMin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">stdFactor</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">stdFactor</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;stdFactor of value zero is not allowed.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">eMax</span><span class="p">,</span> <span class="n">eMin</span>
    <span class="n">percent</span> <span class="o">=</span> <span class="n">percentage</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)))</span>
    <span class="n">fy</span> <span class="o">=</span> <span class="n">y</span><span class="p">[:</span><span class="nb">int</span><span class="p">(</span><span class="n">percent</span><span class="p">)]</span>
    <span class="n">stdValue</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">fy</span><span class="p">)</span> <span class="o">*</span> <span class="n">stdFactor</span>
    <span class="n">eMax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">fy</span><span class="p">)</span> <span class="o">+</span> <span class="n">stdValue</span>
    <span class="n">eMin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">fy</span><span class="p">)</span> <span class="o">-</span> <span class="n">stdValue</span>
    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">eMax</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">eMin</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_filterROI1Darray</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">roi</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Return region included in the ROI ppm position&quot;&quot;&quot;</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">_getMaskedRegionInsideLimits</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">roi</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_getMaskedRegionInsideLimits</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">limits</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return an array of Booleans for the condition.</span>
<span class="sd">    True if the point in the array is within the limits, False otherwise.</span>
<span class="sd">    Limits and Array can be positives and/or negatives</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">numpy.ma</span> <span class="k">as</span> <span class="nn">ma</span>

    <span class="n">mask</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">masked_inside</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">limits</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mask</span><span class="o">.</span><span class="n">mask</span>


<span class="k">def</span> <span class="nf">_filtered1DArray</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">ignoredRegions</span><span class="p">):</span>
    <span class="c1"># returns an array without ignoredRegions. Used for automatic 1d peak picking</span>
    <span class="n">ppmValues</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">masks</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">ignoredRegions</span> <span class="o">=</span> <span class="p">[</span><span class="nb">sorted</span><span class="p">(</span><span class="n">pair</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">ignoredRegions</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="n">ignoredRegions</span><span class="p">:</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">ppmValues</span> <span class="o">&gt;</span> <span class="n">region</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">|</span> <span class="p">(</span><span class="n">ppmValues</span> <span class="o">&lt;</span> <span class="n">region</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">masks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
    <span class="n">fullmask</span> <span class="o">=</span> <span class="p">[</span><span class="nb">all</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="k">for</span> <span class="n">mask</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">masks</span><span class="p">)]</span>
    <span class="n">newArray</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">((</span><span class="n">fullmask</span><span class="p">,</span> <span class="n">fullmask</span><span class="p">))))</span>
    <span class="k">return</span> <span class="n">newArray</span>


<span class="k">def</span> <span class="nf">_initExpBoundResonances</span><span class="p">(</span><span class="n">experiment</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    # CCPNInternal  - API Level routine -</span>
<span class="sd">    Refresh the covalently bound status for any resonances connected</span>
<span class="sd">    via peaks in a given experiment.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">resonances</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">spectrum</span> <span class="ow">in</span> <span class="n">experiment</span><span class="o">.</span><span class="n">dataSources</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">peakList</span> <span class="ow">in</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">peakLists</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">peakList</span><span class="o">.</span><span class="n">peaks</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">peakDim</span> <span class="ow">in</span> <span class="n">peak</span><span class="o">.</span><span class="n">peakDims</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">contrib</span> <span class="ow">in</span> <span class="n">peakDim</span><span class="o">.</span><span class="n">peakDimContribs</span><span class="p">:</span>
                        <span class="n">resonances</span><span class="p">[</span><span class="n">contrib</span><span class="o">.</span><span class="n">resonance</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">resonance</span> <span class="ow">in</span> <span class="n">resonances</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">_getBoundResonances</span><span class="p">(</span><span class="n">resonance</span><span class="p">,</span> <span class="n">recalculate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_setApiExpTransfers</span><span class="p">(</span><span class="n">experiment</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    # CCPNInternal  - API Level routine -</span>
<span class="sd">    Set up the ExpTransfers for an experiment using available refExperiment</span>
<span class="sd">    information. Boolean option to remove any existing transfers.</span>
<span class="sd">    List of Nmr.ExpTransfers</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">experiment</span><span class="o">.</span><span class="n">refExperiment</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">expTransfer</span> <span class="ow">in</span> <span class="n">experiment</span><span class="o">.</span><span class="n">expTransfers</span><span class="p">:</span>
            <span class="n">expTransfer</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>

        <span class="n">_initExpBoundResonances</span><span class="p">(</span><span class="n">experiment</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="k">if</span> <span class="n">experiment</span><span class="o">.</span><span class="n">expTransfers</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">overwrite</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">experiment</span><span class="o">.</span><span class="n">expTransfers</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">expTransfer</span> <span class="ow">in</span> <span class="n">experiment</span><span class="o">.</span><span class="n">expTransfers</span><span class="p">:</span>
                <span class="n">expTransfer</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>

    <span class="n">visibleSites</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">expDim</span> <span class="ow">in</span> <span class="n">experiment</span><span class="o">.</span><span class="n">expDims</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">expDimRef</span> <span class="ow">in</span> <span class="n">expDim</span><span class="o">.</span><span class="n">expDimRefs</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">expDimRef</span><span class="o">.</span><span class="n">refExpDimRef</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">measurement</span> <span class="o">=</span> <span class="n">expDimRef</span><span class="o">.</span><span class="n">refExpDimRef</span><span class="o">.</span><span class="n">expMeasurement</span>
            <span class="k">if</span> <span class="n">measurement</span><span class="o">.</span><span class="n">measurementType</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;Shift&#39;</span><span class="p">,</span> <span class="s1">&#39;shift&#39;</span><span class="p">,</span> <span class="s1">&#39;MQShift&#39;</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">atomSite</span> <span class="ow">in</span> <span class="n">measurement</span><span class="o">.</span><span class="n">atomSites</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">atomSite</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visibleSites</span><span class="p">:</span>
                        <span class="n">visibleSites</span><span class="p">[</span><span class="n">atomSite</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

                    <span class="n">visibleSites</span><span class="p">[</span><span class="n">atomSite</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">expDimRef</span><span class="p">)</span>

    <span class="n">transferDict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">atomSite</span> <span class="ow">in</span> <span class="n">visibleSites</span><span class="p">:</span>
        <span class="n">expDimRefs</span> <span class="o">=</span> <span class="n">visibleSites</span><span class="p">[</span><span class="n">atomSite</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">expTransfer</span> <span class="ow">in</span> <span class="n">atomSite</span><span class="o">.</span><span class="n">expTransfers</span><span class="p">:</span>
            <span class="n">atomSiteA</span><span class="p">,</span> <span class="n">atomSiteB</span> <span class="o">=</span> <span class="n">expTransfer</span><span class="o">.</span><span class="n">atomSites</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">atomSiteA</span> <span class="ow">in</span> <span class="n">visibleSites</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">atomSiteB</span> <span class="ow">in</span> <span class="n">visibleSites</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">transferDict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">expTransfer</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">transferDict</span><span class="p">[</span><span class="n">expTransfer</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">transferDict</span><span class="p">[</span><span class="n">expTransfer</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">expDimRefs</span><span class="p">)</span>

    <span class="c1"># Indirect transfers, e.g. Ch_hC.NOESY or H_hC.NOESY</span>
    <span class="n">indirectTransfers</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">expGraph</span> <span class="ow">in</span> <span class="n">experiment</span><span class="o">.</span><span class="n">refExperiment</span><span class="o">.</span><span class="n">nmrExpPrototype</span><span class="o">.</span><span class="n">expGraphs</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">expTransfer</span> <span class="ow">in</span> <span class="n">expGraph</span><span class="o">.</span><span class="n">expTransfers</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">expTransfer</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">transferDict</span><span class="p">)</span> <span class="ow">and</span> \
                    <span class="p">(</span><span class="n">expTransfer</span><span class="o">.</span><span class="n">transferType</span> <span class="ow">in</span> <span class="n">longRangeTransfers</span><span class="p">):</span>
                <span class="n">atomSiteA</span><span class="p">,</span> <span class="n">atomSiteB</span> <span class="o">=</span> <span class="n">expTransfer</span><span class="o">.</span><span class="n">atomSites</span>

                <span class="k">if</span> <span class="n">atomSiteA</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visibleSites</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">expTransferA</span> <span class="ow">in</span> <span class="n">atomSiteA</span><span class="o">.</span><span class="n">expTransfers</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">expTransferA</span><span class="o">.</span><span class="n">transferType</span> <span class="o">!=</span> <span class="s1">&#39;onebond&#39;</span><span class="p">:</span>
                            <span class="k">continue</span>

                        <span class="n">atomSites</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">expTransferA</span><span class="o">.</span><span class="n">atomSites</span><span class="p">)</span>
                        <span class="n">atomSites</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">atomSiteA</span><span class="p">)</span>
                        <span class="n">atomSiteC</span> <span class="o">=</span> <span class="n">atomSites</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                        <span class="k">if</span> <span class="n">atomSiteC</span> <span class="ow">in</span> <span class="n">visibleSites</span><span class="p">:</span>
                            <span class="n">atomSiteA</span> <span class="o">=</span> <span class="n">atomSiteC</span>
                            <span class="k">break</span>

                <span class="k">if</span> <span class="n">atomSiteB</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visibleSites</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">expTransferB</span> <span class="ow">in</span> <span class="n">atomSiteB</span><span class="o">.</span><span class="n">expTransfers</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">expTransferB</span><span class="o">.</span><span class="n">transferType</span> <span class="o">!=</span> <span class="s1">&#39;onebond&#39;</span><span class="p">:</span>
                            <span class="k">continue</span>

                        <span class="n">atomSites</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">expTransferB</span><span class="o">.</span><span class="n">atomSites</span><span class="p">)</span>
                        <span class="n">atomSites</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">atomSiteB</span><span class="p">)</span>
                        <span class="n">atomSiteD</span> <span class="o">=</span> <span class="n">atomSites</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                        <span class="k">if</span> <span class="n">atomSiteD</span> <span class="ow">in</span> <span class="n">visibleSites</span><span class="p">:</span>
                            <span class="n">atomSiteB</span> <span class="o">=</span> <span class="n">atomSiteD</span>
                            <span class="k">break</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">atomSiteA</span> <span class="ow">in</span> <span class="n">visibleSites</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">atomSiteB</span> <span class="ow">in</span> <span class="n">visibleSites</span><span class="p">):</span>
                    <span class="n">expDimRefsA</span> <span class="o">=</span> <span class="n">visibleSites</span><span class="p">[</span><span class="n">atomSiteA</span><span class="p">]</span>
                    <span class="n">expDimRefsB</span> <span class="o">=</span> <span class="n">visibleSites</span><span class="p">[</span><span class="n">atomSiteB</span><span class="p">]</span>
                    <span class="n">transferDict</span><span class="p">[</span><span class="n">expTransfer</span><span class="p">]</span> <span class="o">=</span> <span class="n">expDimRefsA</span> <span class="o">+</span> <span class="n">expDimRefsB</span>
                    <span class="n">indirectTransfers</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">expTransfer</span><span class="p">)</span>

    <span class="n">expTransfers</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">refTransfer</span> <span class="ow">in</span> <span class="n">transferDict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">expDimRefs</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">transferDict</span><span class="p">[</span><span class="n">refTransfer</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">expDimRefs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">transferType</span> <span class="o">=</span> <span class="n">refTransfer</span><span class="o">.</span><span class="n">transferType</span>
            <span class="n">expTransfer</span> <span class="o">=</span> <span class="n">experiment</span><span class="o">.</span><span class="n">findFirstExpTransfer</span><span class="p">(</span><span class="n">expDimRefs</span><span class="o">=</span><span class="n">expDimRefs</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">expTransfer</span><span class="p">:</span>
                <span class="c1"># normally this would not need setting</span>
                <span class="c1"># but we renamed NOESY to through-space so this catches that situation</span>
                <span class="n">expTransfer</span><span class="o">.</span><span class="n">transferType</span> <span class="o">=</span> <span class="n">transferType</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">expTransfer</span> <span class="o">=</span> <span class="n">experiment</span><span class="o">.</span><span class="n">newExpTransfer</span><span class="p">(</span><span class="n">transferType</span><span class="o">=</span><span class="n">transferType</span><span class="p">,</span>
                                                        <span class="n">expDimRefs</span><span class="o">=</span><span class="n">expDimRefs</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">refTransfer</span> <span class="ow">in</span> <span class="n">indirectTransfers</span><span class="p">:</span>
                <span class="n">isDirect</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">isDirect</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="n">expTransfer</span><span class="o">.</span><span class="n">isDirect</span> <span class="o">=</span> <span class="n">isDirect</span>
            <span class="n">expTransfers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">expTransfer</span><span class="p">)</span>

    <span class="n">_initExpBoundResonances</span><span class="p">(</span><span class="n">experiment</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">expTransfers</span>


<span class="k">def</span> <span class="nf">_getAcqRefExpDimRef</span><span class="p">(</span><span class="n">refExperiment</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    # CCPNInternal  - API Level routine -</span>
<span class="sd">    RefExpDimRef that corresponds to acquisition dimension</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># get acquisition measurement</span>
    <span class="n">expGraph</span> <span class="o">=</span> <span class="n">refExperiment</span><span class="o">.</span><span class="n">nmrExpPrototype</span><span class="o">.</span><span class="n">findFirstExpGraph</span><span class="p">()</span>
    <span class="c1"># even if there are several the acquisition dimension should be common.</span>
    <span class="n">ll</span> <span class="o">=</span> <span class="p">[(</span><span class="n">expStep</span><span class="o">.</span><span class="n">stepNumber</span><span class="p">,</span> <span class="n">expStep</span><span class="p">)</span> <span class="k">for</span> <span class="n">expStep</span> <span class="ow">in</span> <span class="n">expGraph</span><span class="o">.</span><span class="n">expSteps</span><span class="p">]</span>
    <span class="n">expSteps</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">ll</span><span class="p">)]</span>
    <span class="k">if</span> <span class="n">refExperiment</span><span class="o">.</span><span class="n">isReversed</span><span class="p">:</span>
        <span class="n">acqMeasurement</span> <span class="o">=</span> <span class="n">expSteps</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">expMeasurement</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">acqMeasurement</span> <span class="o">=</span> <span class="n">expSteps</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">expMeasurement</span>

    <span class="c1"># get RefExpDimRef that fits measurement</span>
    <span class="n">ll</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">refExpDim</span> <span class="ow">in</span> <span class="n">refExperiment</span><span class="o">.</span><span class="n">sortedRefExpDims</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">refExpDimRef</span> <span class="ow">in</span> <span class="n">refExpDim</span><span class="o">.</span><span class="n">sortedRefExpDimRefs</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">refExpDimRef</span><span class="o">.</span><span class="n">expMeasurement</span> <span class="ow">is</span> <span class="n">acqMeasurement</span><span class="p">:</span>
                <span class="n">ll</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">refExpDimRef</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ll</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ll</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> has no unambiguous RefExpDimRef for acqMeasurement (</span><span class="si">%s</span><span class="s2">)&quot;</span>
                           <span class="o">%</span> <span class="p">(</span><span class="n">refExperiment</span><span class="p">,</span> <span class="n">acqMeasurement</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_getAcqExpDim</span><span class="p">(</span><span class="n">experiment</span><span class="p">,</span> <span class="n">ignorePreset</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    # CCPNInternal  - API Level routine -</span>
<span class="sd">    ExpDim that corresponds to acquisition dimension. NB uses heuristics</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">ll</span> <span class="o">=</span> <span class="n">experiment</span><span class="o">.</span><span class="n">findAllExpDims</span><span class="p">(</span><span class="n">isAcquisition</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ll</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">ignorePreset</span><span class="p">:</span>
        <span class="c1"># acquisition dimension set - return it</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">ll</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># no reliable acquisition dimension set</span>
        <span class="n">result</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">dataSources</span> <span class="o">=</span> <span class="n">experiment</span><span class="o">.</span><span class="n">sortedDataSources</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">dataSources</span><span class="p">:</span>
            <span class="n">dataSource</span> <span class="o">=</span> <span class="n">dataSources</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">ds</span> <span class="ow">in</span> <span class="n">dataSources</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="c1"># more than one data source. Pick one of the largest.</span>
                <span class="k">if</span> <span class="n">ds</span><span class="o">.</span><span class="n">numDim</span> <span class="o">&gt;</span> <span class="n">dataSource</span><span class="o">.</span><span class="n">numDim</span><span class="p">:</span>
                    <span class="n">dataSource</span> <span class="o">=</span> <span class="n">ds</span>

            <span class="c1"># Take dimension with most points</span>
            <span class="n">useDim</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">currentVal</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">for</span> <span class="n">dd</span> <span class="ow">in</span> <span class="n">dataSource</span><span class="o">.</span><span class="n">sortedDataDims</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s1">&#39;numPointsOrig&#39;</span><span class="p">):</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="n">dd</span><span class="o">.</span><span class="n">numPointsOrig</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="n">dd</span><span class="o">.</span><span class="n">numPoints</span>
                <span class="k">if</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="n">currentVal</span><span class="p">:</span>
                    <span class="n">currentVal</span> <span class="o">=</span> <span class="n">val</span>
                    <span class="n">useDim</span> <span class="o">=</span> <span class="n">dd</span>

            <span class="k">if</span> <span class="n">useDim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">useDim</span><span class="o">.</span><span class="n">expDim</span>

        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># no joy so far - just take first ExpDim</span>
            <span class="n">ll</span> <span class="o">=</span> <span class="n">experiment</span><span class="o">.</span><span class="n">sortedExpDims</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">ll</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">ll</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">_getRefExpDim4ExpDim</span><span class="p">(</span><span class="n">expDim</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    get the link between refExpDim and expDim through their children refExpDimRef and expDimRef.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">refExpDim</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">expDimRef</span> <span class="ow">in</span> <span class="n">expDim</span><span class="o">.</span><span class="n">expDimRefs</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">expDimRef</span><span class="o">.</span><span class="n">refExpDimRef</span><span class="p">:</span>
            <span class="n">refExpDim</span> <span class="o">=</span> <span class="n">expDimRef</span><span class="o">.</span><span class="n">refExpDimRef</span><span class="o">.</span><span class="n">refExpDim</span>
            <span class="k">break</span>
    <span class="k">return</span> <span class="n">refExpDim</span>


<span class="k">def</span> <span class="nf">_tempLinkRefExpDim2ExpDim</span><span class="p">(</span><span class="n">expDim</span><span class="p">,</span> <span class="n">refExpDim</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Temporary link expDim and refExpDim through their sorted children refExpDimRefs and expDimRefs.</span>
<span class="sd">    The match refExpDimRef-expDimRef will be redone by isotope code.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">expDim</span><span class="o">.</span><span class="n">sortedExpDimRefs</span><span class="p">())</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">refExpDim</span><span class="o">.</span><span class="n">sortedRefExpDimRefs</span><span class="p">()):</span>
        <span class="k">for</span> <span class="n">expDimRef</span><span class="p">,</span> <span class="n">refExpDimRef</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">expDim</span><span class="o">.</span><span class="n">sortedExpDimRefs</span><span class="p">(),</span> <span class="n">refExpDim</span><span class="o">.</span><span class="n">sortedRefExpDimRefs</span><span class="p">()):</span>
            <span class="n">expDimRef</span><span class="o">.</span><span class="n">setRefExpDimRef</span><span class="p">(</span><span class="n">refExpDimRef</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_clearLinkToRefExp</span><span class="p">(</span><span class="n">experiment</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">expDim</span> <span class="ow">in</span> <span class="n">experiment</span><span class="o">.</span><span class="n">expDims</span><span class="p">:</span>
        <span class="n">refExpDim</span> <span class="o">=</span> <span class="n">_getRefExpDim4ExpDim</span><span class="p">(</span><span class="n">expDim</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">refExpDim</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">expDimRef</span> <span class="ow">in</span> <span class="n">expDim</span><span class="o">.</span><span class="n">expDimRefs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">expDimRef</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">expDimRef</span><span class="o">.</span><span class="n">refExpDimRef</span><span class="p">:</span>
                        <span class="n">expDimRef</span><span class="o">.</span><span class="n">setRefExpDimRef</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_setApiRefExperiment</span><span class="p">(</span><span class="n">experiment</span><span class="p">,</span> <span class="n">refExperiment</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    # CCPNInternal  - API Level routine -</span>
<span class="sd">    Sets the reference experiment for an existing experiment</span>
<span class="sd">    and tries to map the ExpDims to RefExpDims appropriately.</span>

<span class="sd">    This routine is very convoluted. Should be simplified/reimplemented.</span>
<span class="sd">    We are only trying to make this link: expDimRef.refExpDimRef = refExpDimRef</span>

<span class="sd">        experiment------ expDim(s)-------expDimRef(s)</span>
<span class="sd">                                             *</span>
<span class="sd">        refExperiment---refExpDim(s)----refExpDimRef(s)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_clearLinkToRefExp</span><span class="p">(</span><span class="n">experiment</span><span class="p">)</span>

    <span class="n">experiment</span><span class="o">.</span><span class="n">setRefExperiment</span><span class="p">(</span><span class="n">refExperiment</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">refExperiment</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="n">refExpDims</span> <span class="o">=</span> <span class="n">refExperiment</span><span class="o">.</span><span class="n">sortedRefExpDims</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">refExpDims</span><span class="p">:</span>
        <span class="c1"># Something is wrong with the reference data</span>
        <span class="k">return</span>

    <span class="n">expDims</span> <span class="o">=</span> <span class="n">experiment</span><span class="o">.</span><span class="n">sortedExpDims</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">expDims</span><span class="p">:</span>
        <span class="c1"># Something is wrong with the experiment</span>
        <span class="k">return</span>

    <span class="n">acqRefExpDim</span> <span class="o">=</span> <span class="n">_getAcqRefExpDimRef</span><span class="p">(</span><span class="n">refExperiment</span><span class="p">)</span><span class="o">.</span><span class="n">refExpDim</span>
    <span class="n">acqExpDim</span> <span class="o">=</span> <span class="n">_getAcqExpDim</span><span class="p">(</span><span class="n">experiment</span><span class="p">,</span> <span class="n">ignorePreset</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">refExpDims</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">acqRefExpDim</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">refExpDims</span><span class="p">))</span> <span class="o">!=</span>
            <span class="p">(</span><span class="n">expDims</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">acqExpDim</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">expDims</span><span class="p">))):</span>
        <span class="c1"># acqRefExpDim and acqExpDim are at opposite ends of their</span>
        <span class="c1"># respective lists. reverse refExpDims so that acquisition</span>
        <span class="c1"># dimensions will more likely get mapped to each other.</span>
        <span class="n">refExpDims</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>

    <span class="c1"># Rasmus 12/7/12. Must be set to None, as otherwise it is never reset below.</span>
    <span class="c1"># We do not want the heuristic _getAcqExpDim to override everything else.</span>
    <span class="n">acqExpDim</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">for</span> <span class="n">expDim</span> <span class="ow">in</span> <span class="n">expDims</span><span class="p">:</span>
        <span class="n">expData</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">expDimRef</span> <span class="ow">in</span> <span class="n">expDim</span><span class="o">.</span><span class="n">expDimRefs</span><span class="p">:</span>
            <span class="n">isotopes</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">expDimRef</span><span class="o">.</span><span class="n">isotopeCodes</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">isotopes</span><span class="p">:</span>
                <span class="n">mType</span> <span class="o">=</span> <span class="n">expDimRef</span><span class="o">.</span><span class="n">measurementType</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
                <span class="n">expData</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">mType</span><span class="p">,</span> <span class="n">isotopes</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">expData</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="k">for</span> <span class="n">refExpDim</span> <span class="ow">in</span> <span class="n">refExpDims</span><span class="p">:</span>
            <span class="n">refData</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">refExpDimRef</span> <span class="ow">in</span> <span class="n">refExpDim</span><span class="o">.</span><span class="n">refExpDimRefs</span><span class="p">:</span>
                <span class="n">expMeasurement</span> <span class="o">=</span> <span class="n">refExpDimRef</span><span class="o">.</span><span class="n">expMeasurement</span>
                <span class="n">isotopes</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">isotopeCode</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">expMeasurement</span><span class="o">.</span><span class="n">atomSites</span><span class="p">])</span>
                <span class="n">mType</span> <span class="o">=</span> <span class="n">expMeasurement</span><span class="o">.</span><span class="n">measurementType</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
                <span class="n">refData</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">mType</span><span class="p">,</span> <span class="n">isotopes</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">expData</span> <span class="o">==</span> <span class="n">refData</span><span class="p">:</span>
                <span class="c1"># expDim.refExpDim = refExpDim # this link is not anymore in the v3 API.  set refExpDimRefs and expDimRefs directly</span>
                <span class="n">_tempLinkRefExpDim2ExpDim</span><span class="p">(</span><span class="n">expDim</span><span class="p">,</span> <span class="n">refExpDim</span><span class="p">)</span>
                <span class="n">refExpDims</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">refExpDim</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">refExpDim</span> <span class="ow">is</span> <span class="n">acqRefExpDim</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">acqExpDim</span><span class="p">:</span>
                        <span class="n">expDim</span><span class="o">.</span><span class="n">isAcquisition</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="n">acqExpDim</span> <span class="o">=</span> <span class="n">expDim</span>

                <span class="k">break</span>
    <span class="k">for</span> <span class="n">expDim</span> <span class="ow">in</span> <span class="n">expDims</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">expDim</span><span class="o">.</span><span class="n">expDimRefs</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_getRefExpDim4ExpDim</span><span class="p">(</span><span class="n">expDim</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">refExpDims</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">refExpDim</span> <span class="o">=</span> <span class="n">refExpDims</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">_tempLinkRefExpDim2ExpDim</span><span class="p">(</span><span class="n">expDim</span><span class="p">,</span> <span class="n">refExpDim</span><span class="p">)</span>

        <span class="c1"># set reference data comparison list</span>
        <span class="n">_refExpDim</span> <span class="o">=</span> <span class="n">_getRefExpDim4ExpDim</span><span class="p">(</span><span class="n">expDim</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">_refExpDim</span><span class="p">:</span>
            <span class="n">refExpDimRefs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">_refExpDim</span><span class="o">.</span><span class="n">refExpDimRefs</span><span class="p">)</span>
            <span class="n">refData</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">refExpDimRef</span> <span class="ow">in</span> <span class="n">refExpDimRefs</span><span class="p">:</span>
                <span class="n">expMeasurement</span> <span class="o">=</span> <span class="n">refExpDimRef</span><span class="o">.</span><span class="n">expMeasurement</span>
                <span class="n">atomSites</span> <span class="o">=</span> <span class="n">expMeasurement</span><span class="o">.</span><span class="n">atomSites</span>
                <span class="n">refData</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">isotopeCode</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">atomSites</span><span class="p">),</span>
                                <span class="n">expMeasurement</span><span class="o">.</span><span class="n">measurementType</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span>
                                <span class="nb">frozenset</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">atomSites</span><span class="p">),</span>
                                <span class="n">refExpDimRef</span><span class="p">))</span>

            <span class="c1"># set experiment data comparison list</span>
            <span class="n">inData</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">expDimRef</span> <span class="ow">in</span> <span class="n">expDim</span><span class="o">.</span><span class="n">expDimRefs</span><span class="p">:</span>
                <span class="n">inData</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">expDimRef</span><span class="o">.</span><span class="n">isotopeCodes</span><span class="p">),</span>
                               <span class="n">expDimRef</span><span class="o">.</span><span class="n">measurementType</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span>
                               <span class="nb">frozenset</span><span class="p">(((</span><span class="n">expDimRef</span><span class="o">.</span><span class="n">displayName</span><span class="p">),)),</span>
                               <span class="n">expDimRef</span><span class="p">))</span>

            <span class="c1"># match expDimRef to refExpDimRef. comparing isotopeCodes,</span>
            <span class="c1"># if equal measurementTypes, if equal name/displayname</span>
            <span class="k">for</span> <span class="n">end</span> <span class="ow">in</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">inData</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">refData</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">inData</span><span class="p">[</span><span class="n">ii</span><span class="p">][:</span><span class="n">end</span><span class="p">]</span> <span class="o">==</span> <span class="n">refData</span><span class="p">[</span><span class="n">jj</span><span class="p">][:</span><span class="n">end</span><span class="p">]:</span>
                            <span class="n">expDimRef</span> <span class="o">=</span> <span class="n">inData</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                            <span class="n">expDimRef</span><span class="o">.</span><span class="n">refExpDimRef</span> <span class="o">=</span> <span class="n">refData</span><span class="p">[</span><span class="n">jj</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                            <span class="n">expDimRef</span><span class="o">.</span><span class="n">measurementType</span> <span class="o">=</span> <span class="n">refData</span><span class="p">[</span><span class="n">jj</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">expMeasurement</span><span class="o">.</span><span class="n">measurementType</span>
                            <span class="k">del</span> <span class="n">inData</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
                            <span class="k">del</span> <span class="n">refData</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span>
                            <span class="k">break</span>

<span class="c1">#===========================================================================================================</span>
<span class="c1"># Peak-related stuff</span>
<span class="c1">#===========================================================================================================</span>

<span class="k">def</span> <span class="nf">_createPeak</span><span class="p">(</span><span class="n">spectrum</span><span class="p">,</span> <span class="n">peakList</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">ppmPositions</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="s1">&#39;Peak&#39;</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Create peak at position specified by the ppmPositions dict.</span>

<span class="sd">    Return the peak created at this ppm position or None.</span>

<span class="sd">    Ppm positions are passed in as a dict of (axisCode, ppmValue) key, value pairs</span>
<span class="sd">    with the ppmValue supplied mapping to the closest matching axis.</span>

<span class="sd">    Illegal or non-matching axisCodes will return None.</span>

<span class="sd">    Example ppmPosition dict:</span>

<span class="sd">    ::</span>

<span class="sd">        {&#39;Hn&#39;: 7.0, &#39;Nh&#39;: 110}</span>


<span class="sd">    Example calling function:</span>

<span class="sd">    &gt;&gt;&gt; peak = spectrum.createPeak(**limitsDict)</span>
<span class="sd">    &gt;&gt;&gt; peak = spectrum.createPeak(peakList, **limitsDict)</span>
<span class="sd">    &gt;&gt;&gt; peak = spectrum.createPeak(peakList=peakList, Hn=7.0, Nh=110)</span>

<span class="sd">    :param peakList: peakList to create new peak in, or None for the last peakList belonging to spectrum</span>
<span class="sd">    :param ppmPositions: dict of (axisCode, ppmValue) key,value pairs</span>
<span class="sd">    :return: new peak or None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="n">undoBlockWithoutSideBar</span><span class="p">():</span>

        <span class="n">axisCodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">_ppmPositions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">axis</span><span class="p">,</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">ppmPositions</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">axisCodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
            <span class="n">_ppmPositions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">pos</span><span class="p">))</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># try and match the axis codes before creating new peakList (if required)</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">getByAxisCodes</span><span class="p">(</span><span class="s1">&#39;dimensionIndices&#39;</span><span class="p">,</span> <span class="n">axisCodes</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">es</span><span class="p">:</span>
            <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Non-matching axis codes found </span><span class="si">{</span><span class="n">axisCodes</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="n">peakList</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">project</span><span class="o">.</span><span class="n">getByPid</span><span class="p">(</span><span class="n">peakList</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">peakList</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">peakList</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">peakList</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">peakLists</span><span class="p">:</span>
                <span class="n">peakList</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">peakLists</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># log warning that no peakList exists - this SHOULD never happen</span>
                <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Spectrum </span><span class="si">{</span><span class="n">spectrum</span><span class="si">}</span><span class="s1"> has no peakLists - creating new&#39;</span><span class="p">)</span>
                <span class="n">peakList</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">newPeakList</span><span class="p">()</span>

        <span class="c1"># should get all ppm&#39;s from the reference - shouldn&#39;t really be any Nones now though</span>
        <span class="n">_ppmPositions</span> <span class="o">=</span> <span class="p">[</span><span class="n">_ppmPositions</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">height</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">height</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">getHeight</span><span class="p">(</span><span class="n">_ppmPositions</span><span class="p">)</span>
        <span class="n">specLimits</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">spectrumLimits</span>
        <span class="n">aliasInds</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">aliasingIndexes</span>

        <span class="k">for</span> <span class="n">dim</span><span class="p">,</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">_ppmPositions</span><span class="p">):</span>
            <span class="c1"># check that the picked peak lies in the bounded region of the spectrum</span>
            <span class="n">minSpectrumFrequency</span><span class="p">,</span> <span class="n">maxSpectrumFrequency</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">specLimits</span><span class="p">[</span><span class="n">dim</span><span class="p">])</span>
            <span class="n">visibleAlias</span> <span class="o">=</span> <span class="n">aliasInds</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>
            <span class="n">regionBounds</span> <span class="o">=</span> <span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">minSpectrumFrequency</span> <span class="o">+</span> <span class="n">visibleAlias</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">maxSpectrumFrequency</span> <span class="o">-</span> <span class="n">minSpectrumFrequency</span><span class="p">),</span> <span class="mi">3</span><span class="p">),</span>
                            <span class="nb">round</span><span class="p">(</span><span class="n">minSpectrumFrequency</span> <span class="o">+</span> <span class="p">(</span><span class="n">visibleAlias</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">maxSpectrumFrequency</span> <span class="o">-</span> <span class="n">minSpectrumFrequency</span><span class="p">),</span> <span class="mi">3</span><span class="p">))</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">regionBounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">pos</span> <span class="o">&lt;=</span> <span class="n">regionBounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="k">break</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># get the list of existing peak pointPositions in this peakList</span>
            <span class="n">pointCounts</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">pointCounts</span>
            <span class="n">intPositions</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(((</span><span class="n">spectrum</span><span class="o">.</span><span class="n">ppm2point</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="n">indx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">np</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
                            <span class="k">for</span> <span class="n">indx</span><span class="p">,</span> <span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">np</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">_ppmPositions</span><span class="p">,</span> <span class="n">pointCounts</span><span class="p">))]</span>

            <span class="c1"># get the existing peak point-positions for this list</span>
            <span class="n">existingPositions</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">int</span><span class="p">(</span><span class="n">pp</span><span class="p">)</span> <span class="k">for</span> <span class="n">pp</span> <span class="ow">in</span> <span class="n">pk</span><span class="o">.</span><span class="n">pointPositions</span><span class="p">]</span> <span class="k">for</span> <span class="n">pk</span> <span class="ow">in</span> <span class="n">peakList</span><span class="o">.</span><span class="n">peaks</span> <span class="k">if</span> <span class="kc">None</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">pk</span><span class="o">.</span><span class="n">pointPositions</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">intPositions</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">existingPositions</span><span class="p">:</span>
                <span class="c1"># add the new peak only if one doesn&#39;t exist at these pointPositions</span>
                <span class="n">pk</span> <span class="o">=</span> <span class="n">peakList</span><span class="o">.</span><span class="n">newPeak</span><span class="p">(</span><span class="n">ppmPositions</span><span class="o">=</span><span class="n">_ppmPositions</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="n">height</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">pk</span>


<span class="c1"># def _pickPeaks(spectrum, peakList=None, positiveThreshold=None, negativeThreshold=None, **ppmRegions) -&gt; Tuple[&#39;Peak&#39;, ...]:</span>
<span class="c1">#     &quot;&quot;&quot;Pick peaks in the region defined by the ppmRegions dict.</span>
<span class="c1">#</span>
<span class="c1">#     Ppm regions are passed in as a dict containing the axis codes and the required limits.</span>
<span class="c1">#     Each limit is defined as a key, value pair: (str, tuple), with the tuple supplied as (min, max) axis limits in ppm.</span>
<span class="c1">#     Axis codes supplied are mapped to the closest matching axis.</span>
<span class="c1">#</span>
<span class="c1">#     Illegal or non-matching axisCodes will return None.</span>
<span class="c1">#</span>
<span class="c1">#     Example ppmRegions dict:</span>
<span class="c1">#</span>
<span class="c1">#     ::</span>
<span class="c1">#</span>
<span class="c1">#         {&#39;Hn&#39;: (7.0, 9.0),</span>
<span class="c1">#          &#39;Nh&#39;: (110, 130)</span>
<span class="c1">#          }</span>
<span class="c1">#</span>
<span class="c1">#     Example calling function:</span>
<span class="c1">#</span>
<span class="c1">#     &gt;&gt;&gt; peaks = spectrum.pickPeaks(**regionsDict)</span>
<span class="c1">#     &gt;&gt;&gt; peaks = spectrum.pickPeaks(peakList, **regionsDict)</span>
<span class="c1">#     &gt;&gt;&gt; peaks = spectrum.pickPeaks(peakList=peakList, Hn=(7.0, 9.0), Nh=(110, 130))</span>
<span class="c1">#</span>
<span class="c1">#     :param peakList: peakList to create new peak in, or None for the last peakList belonging to spectrum</span>
<span class="c1">#     :param positiveThreshold: float or None specifying the positive threshold above which to find peaks.</span>
<span class="c1">#                               if None, positive peak picking is disabled.</span>
<span class="c1">#     :param negativeThreshold: float or None specifying the negative threshold below which to find peaks.</span>
<span class="c1">#                               if None, negative peak picking is disabled.</span>
<span class="c1">#     :param ppmRegions: dict of (axisCode, tupleValue) key, value pairs</span>
<span class="c1">#     :return: tuple of new peaks</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     # local import as cycles otherwise</span>
<span class="c1">#     from ccpn.core.Spectrum import Spectrum</span>
<span class="c1">#</span>
<span class="c1">#     application = getApplication()</span>
<span class="c1">#     preferences = application.preferences</span>
<span class="c1">#     logger = getLogger()</span>
<span class="c1">#</span>
<span class="c1">#     if spectrum is None or not isinstance(spectrum, Spectrum):</span>
<span class="c1">#         raise ValueError(&#39;_pickPeaks: required Spectrum instance, got:%r&#39; % spectrum)</span>
<span class="c1">#</span>
<span class="c1">#     if peakList is None:</span>
<span class="c1">#         peakList = spectrum.peakLists[-1]</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#     # get the dimensions by mapping the keys of the ppmRegions dict</span>
<span class="c1">#     dimensions = spectrum.getByAxisCodes(&#39;dimensions&#39;, [a for a in ppmRegions.keys()])</span>
<span class="c1">#     # now get all other parameters in dimensions order</span>
<span class="c1">#     axisCodes = spectrum.getByDimensions(&#39;axisCodes&#39;, dimensions)</span>
<span class="c1">#     ppmValues = [sorted(float(pos) for pos in region) for region in ppmRegions.values()]</span>
<span class="c1">#     ppmValues = spectrum.orderByDimensions(ppmValues, dimensions) # sorted in order of dimensions</span>
<span class="c1">#</span>
<span class="c1">#     axisDict = dict((axisCode, region) for axisCode, region in zip(axisCodes, ppmValues))</span>
<span class="c1">#     sliceTuples = spectrum._axisDictToSliceTuples(axisDict)</span>
<span class="c1">#</span>
<span class="c1">#     return _pickPeaksByRegion(spectrum, sliceTuples= sliceTuples, peakList=peakList,</span>
<span class="c1">#                               positiveThreshold=positiveThreshold, negativeThreshold=negativeThreshold)</span>


<span class="k">def</span> <span class="nf">_pickPeaksByRegion</span><span class="p">(</span><span class="n">spectrum</span><span class="p">,</span> <span class="n">sliceTuples</span><span class="p">,</span> <span class="n">peakList</span><span class="p">,</span> <span class="n">positiveThreshold</span><span class="p">,</span> <span class="n">negativeThreshold</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Helper function to pick peaks of spectrum in region defined by sliceTuples</span>

<span class="sd">    :param spectrum: a Spectrum instance</span>
<span class="sd">    :param sliceTuples: a list of (startPoint,stopPoint) tuples (1-based, inclusive) per dimension</span>
<span class="sd">    :param peakList: peakList to hold newly created peak.</span>
<span class="sd">    :param positiveThreshold: float or None specifying the positive threshold above which to find peaks.</span>
<span class="sd">                              if None, positive peak picking is disabled.</span>
<span class="sd">    :param negativeThreshold: float or None specifying the negative threshold below which to find peaks.</span>
<span class="sd">                              if None, negative peak picking is disabled.</span>

<span class="sd">    :return: list of new peaks</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># local import as cycles otherwise</span>
    <span class="kn">from</span> <span class="nn">ccpn.core.Spectrum</span> <span class="kn">import</span> <span class="n">Spectrum</span>
    <span class="kn">from</span> <span class="nn">ccpn.core.PeakList</span> <span class="kn">import</span> <span class="n">PeakList</span>

    <span class="n">application</span> <span class="o">=</span> <span class="n">getApplication</span><span class="p">()</span>
    <span class="n">preferences</span> <span class="o">=</span> <span class="n">application</span><span class="o">.</span><span class="n">preferences</span>
    <span class="n">logger</span> <span class="o">=</span> <span class="n">getLogger</span><span class="p">()</span>

    <span class="n">spectrum</span> <span class="o">=</span> <span class="n">application</span><span class="o">.</span><span class="n">project</span><span class="o">.</span><span class="n">getByPid</span><span class="p">(</span><span class="n">spectrum</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spectrum</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">spectrum</span>
    <span class="k">if</span> <span class="n">spectrum</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spectrum</span><span class="p">,</span> <span class="n">Spectrum</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;_pickPeaksByRegion: required Spectrum instance, got:</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">spectrum</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="n">peakList</span> <span class="o">=</span> <span class="n">application</span><span class="o">.</span><span class="n">project</span><span class="o">.</span><span class="n">getByPid</span><span class="p">(</span><span class="n">peakList</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">peakList</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">peakList</span>
    <span class="k">if</span> <span class="n">peakList</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">peakList</span><span class="p">,</span> <span class="n">PeakList</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;_pickPeaksByRegion: required peakList instance, got:</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">peakList</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="c1"># get the peakPicker</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">peakPicker</span> <span class="o">:=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">peakPicker</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">txt</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;_pickPeakByRegion: No valid peakPicker for </span><span class="si">{</span><span class="n">spectrum</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span>

    <span class="c1"># check the sliceTuples; make a copy as list of lists first</span>
    <span class="n">_sliceTuples</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">sl</span><span class="p">)</span> <span class="k">for</span> <span class="n">sl</span> <span class="ow">in</span> <span class="n">sliceTuples</span><span class="p">]</span>
    <span class="n">cropped</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">for</span> <span class="n">dimIdx</span><span class="p">,</span> <span class="n">_slice</span><span class="p">,</span> <span class="n">points</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">spectrum</span><span class="o">.</span><span class="n">dimensionIndices</span><span class="p">,</span> <span class="n">_sliceTuples</span><span class="p">,</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">aliasingPointLimits</span><span class="p">):</span>
        <span class="c1"># check if the region is not completely outside the spectrum;</span>
        <span class="c1"># if so, issue a warning</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">_slice</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">_slice</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">or</span> \
           <span class="p">(</span><span class="n">_slice</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">_slice</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="c1"># region is fully outside the spectral range</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;_pickPeaksByRegion: </span><span class="si">%s</span><span class="s1">: sliceTuples[</span><span class="si">%d</span><span class="s1">]=</span><span class="si">%r</span><span class="s1"> out of range </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span>
                       <span class="p">(</span><span class="n">spectrum</span><span class="p">,</span> <span class="n">dimIdx</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_slice</span><span class="p">),</span> <span class="n">points</span><span class="p">))</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;could not pick peaks for </span><span class="si">{</span><span class="n">spectrum</span><span class="si">}</span><span class="s1"> in region </span><span class="si">{</span><span class="n">sliceTuples</span><span class="si">}</span><span class="s1">; &#39;</span>\
                           <span class="sa">f</span><span class="s1">&#39;dimension </span><span class="si">{</span><span class="n">dimIdx</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s1">,&quot;</span><span class="si">{</span><span class="n">spectrum</span><span class="o">.</span><span class="n">axisCodes</span><span class="p">[</span><span class="n">dimIdx</span><span class="p">]</span><span class="si">}</span><span class="s1">&quot; = </span><span class="si">{</span><span class="nb">tuple</span><span class="p">(</span><span class="n">_slice</span><span class="p">)</span><span class="si">}</span><span class="s1"> out of range </span><span class="si">{</span><span class="n">points</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">_slice</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">_slice</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">_sliceTuples</span><span class="p">[</span><span class="n">dimIdx</span><span class="p">]</span> <span class="o">=</span> <span class="n">_slice</span>
            <span class="n">cropped</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">_slice</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">_slice</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">_sliceTuples</span><span class="p">[</span><span class="n">dimIdx</span><span class="p">]</span> <span class="o">=</span> <span class="n">_slice</span>
            <span class="n">cropped</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># revert to a list of tuples</span>
    <span class="n">_sliceTuples</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">sl</span><span class="p">)</span> <span class="k">for</span> <span class="n">sl</span> <span class="ow">in</span> <span class="n">_sliceTuples</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">cropped</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;_pickPeaksByRegion: </span><span class="si">%s</span><span class="s1">: cropped sliceTuples from </span><span class="si">%r</span><span class="s1"> to </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span>
                       <span class="p">(</span><span class="n">spectrum</span><span class="p">,</span> <span class="n">sliceTuples</span><span class="p">,</span> <span class="n">_sliceTuples</span><span class="p">))</span>

    <span class="c1"># set any additional parameters from preferences</span>
    <span class="n">minDropFactor</span> <span class="o">=</span> <span class="n">preferences</span><span class="o">.</span><span class="n">general</span><span class="o">.</span><span class="n">peakDropFactor</span>
    <span class="n">fitMethod</span> <span class="o">=</span> <span class="n">preferences</span><span class="o">.</span><span class="n">general</span><span class="o">.</span><span class="n">peakFittingMethod</span>
    <span class="n">peakPicker</span><span class="o">.</span><span class="n">setParameters</span><span class="p">(</span><span class="n">dropFactor</span><span class="o">=</span><span class="n">minDropFactor</span><span class="p">,</span>
                             <span class="n">fitMethod</span><span class="o">=</span><span class="n">fitMethod</span><span class="p">,</span>
                             <span class="n">setLineWidths</span><span class="o">=</span><span class="kc">True</span>
                             <span class="p">)</span>

    <span class="n">peaks</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">with</span> <span class="n">undoBlockWithoutSideBar</span><span class="p">():</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">peaks</span> <span class="o">=</span> <span class="n">peakPicker</span><span class="o">.</span><span class="n">pickPeaks</span><span class="p">(</span><span class="n">sliceTuples</span><span class="o">=</span><span class="n">_sliceTuples</span><span class="p">,</span>
                                         <span class="n">peakList</span><span class="o">=</span><span class="n">peakList</span><span class="p">,</span>
                                         <span class="n">positiveThreshold</span><span class="o">=</span><span class="n">positiveThreshold</span><span class="p">,</span>
                                         <span class="n">negativeThreshold</span><span class="o">=</span><span class="n">negativeThreshold</span>
                                         <span class="p">)</span>

        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="c1"># need to trap error that Nd spectra may not be defined in all dimensions of axisDict</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;_pickPeaks </span><span class="si">%s</span><span class="s1">, trapped error: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">spectrum</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">err</span><span class="p">)))</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;could not pick peaks for </span><span class="si">{</span><span class="n">spectrum</span><span class="si">}</span><span class="s1"> in region </span><span class="si">{</span><span class="n">sliceTuples</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="c1"># if application._isInDebugMode:</span>
            <span class="c1">#     raise  err</span>

    <span class="k">return</span> <span class="n">peaks</span>

<div class="viewcode-block" id="fetchPeakPicker"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.SpectrumLib.fetchPeakPicker">[docs]</a><span class="k">def</span> <span class="nf">fetchPeakPicker</span><span class="p">(</span><span class="n">spectrum</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get a peakPicker; either by restore from spectrum or the default relevant for spectrum</span>
<span class="sd">    :return a PeakPicker instance or None on errors</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">ccpn.util.traits.CcpNmrJson</span> <span class="kn">import</span> <span class="n">CcpNmrJson</span>
    <span class="kn">from</span> <span class="nn">ccpn.core.Spectrum</span> <span class="kn">import</span> <span class="n">Spectrum</span>
    <span class="kn">from</span> <span class="nn">ccpn.core.lib.PeakPickers.PeakPicker1D</span> <span class="kn">import</span> <span class="n">PeakPicker1D</span>
    <span class="kn">from</span> <span class="nn">ccpn.core.lib.PeakPickers.PeakPickerNd</span> <span class="kn">import</span> <span class="n">PeakPickerNd</span>
    <span class="kn">from</span> <span class="nn">ccpn.core.lib.PeakPickers.PeakPickerABC</span> <span class="kn">import</span> <span class="n">getPeakPickerTypes</span><span class="p">,</span> <span class="n">PEAKPICKERPARAMETERS</span>

    <span class="k">if</span> <span class="n">spectrum</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;fetchPeakPicker: spectrum is None&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spectrum</span><span class="p">,</span> <span class="n">Spectrum</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;fetchPeakPicker: spectrum is not of Spectrum class&#39;</span><span class="p">)</span>

    <span class="n">project</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">project</span>
    <span class="n">application</span> <span class="o">=</span> <span class="n">project</span><span class="o">.</span><span class="n">application</span>
    <span class="n">preferences</span> <span class="o">=</span> <span class="n">application</span><span class="o">.</span><span class="n">preferences</span>

    <span class="n">peakPickers</span> <span class="o">=</span> <span class="n">getPeakPickerTypes</span><span class="p">()</span>
    <span class="n">default1DPickerType</span> <span class="o">=</span> <span class="n">preferences</span><span class="o">.</span><span class="n">general</span><span class="o">.</span><span class="n">peakPicker1d</span>
    <span class="k">if</span> <span class="n">default1DPickerType</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">default1DPickerType</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">default1DPickerType</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">peakPickers</span><span class="p">:</span>
        <span class="n">default1DPickerType</span> <span class="o">=</span> <span class="n">PeakPicker1D</span><span class="o">.</span><span class="n">peakPickerType</span>

    <span class="n">defaultNDPickerType</span> <span class="o">=</span> <span class="n">preferences</span><span class="o">.</span><span class="n">general</span><span class="o">.</span><span class="n">peakPickerNd</span>
    <span class="k">if</span> <span class="n">defaultNDPickerType</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">defaultNDPickerType</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">defaultNDPickerType</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">peakPickers</span><span class="p">:</span>
        <span class="n">defaultNDPickerType</span> <span class="o">=</span> <span class="n">PeakPickerNd</span><span class="o">.</span><span class="n">peakPickerType</span>

    <span class="n">_picker</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># read peakPicker from CCPNinternal</span>
        <span class="n">jsonString</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">_getInternalParameter</span><span class="p">(</span><span class="n">PEAKPICKERPARAMETERS</span><span class="p">)</span>
        <span class="n">_picker</span> <span class="o">=</span> <span class="n">CcpNmrJson</span><span class="o">.</span><span class="n">newObjectFromJson</span><span class="p">(</span><span class="n">jsonString</span><span class="o">=</span><span class="n">jsonString</span><span class="p">,</span> <span class="n">spectrum</span><span class="o">=</span><span class="n">spectrum</span><span class="p">)</span>

    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">es</span><span class="p">:</span>
        <span class="c1"># No internal definition found</span>
        <span class="n">_pickerType</span> <span class="o">=</span> <span class="n">default1DPickerType</span> <span class="k">if</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">dimensionCount</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">defaultNDPickerType</span>
        <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;peakPicker not restored from </span><span class="si">{</span><span class="n">spectrum</span><span class="si">}</span><span class="s1">; selected </span><span class="si">{</span><span class="n">_pickerType</span><span class="si">}</span><span class="s1"> instead&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">cls</span> <span class="o">:=</span> <span class="n">peakPickers</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">_pickerType</span><span class="p">))</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_picker</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">spectrum</span><span class="o">=</span><span class="n">spectrum</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Failed to initiate </span><span class="si">{</span><span class="n">_pickerType</span><span class="si">}</span><span class="s1"> peakPicker&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">_picker</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;peakPicker for </span><span class="si">{</span><span class="n">spectrum</span><span class="si">}</span><span class="s1"> not defined&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_picker</span></div>

<span class="c1">#===========================================================================================================</span>
<span class="c1"># Spectrum axis permutations</span>
<span class="c1">#===========================================================================================================</span>

<span class="k">def</span> <span class="nf">_searchAxisCodePermutations</span><span class="p">(</span><span class="n">spectrum</span><span class="p">,</span> <span class="n">checkCodes</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
    <span class="sd">&quot;&quot;&quot;Generate the permutations of the current axisCodes</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">checkCodes</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;checkCodes is not defined&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">checkCodes</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;checkCodes is not a list/tuple&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">ss</span> <span class="ow">in</span> <span class="n">checkCodes</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;checkCodes elements must be strings&#39;</span><span class="p">)</span>

    <span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">permutations</span>

    <span class="c1"># add permutations for the axes</span>
    <span class="n">axisPerms</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">permutations</span><span class="p">(</span><span class="n">spectrum</span><span class="o">.</span><span class="n">axisCodes</span><span class="p">))</span>
    <span class="n">axisOrder</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">permutations</span><span class="p">(</span><span class="n">spectrum</span><span class="o">.</span><span class="n">dimensionIndices</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">perm</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axisPerms</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">checkCodes</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">perm</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">n</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">pCode</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">cCode</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">pCode</span><span class="p">,</span> <span class="n">cCode</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">perm</span><span class="p">[:</span><span class="n">n</span><span class="p">],</span> <span class="n">checkCodes</span><span class="p">[:</span><span class="n">n</span><span class="p">])):</span>
            <span class="k">return</span> <span class="n">axisOrder</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">_setDefaultAxisOrdering</span><span class="p">(</span><span class="n">spectrum</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Establish and set a preferred axis ordering, based on some default rules;</span>
<span class="sd">    e.g. HCN for triple-resonance experiment</span>
<span class="sd">    called once from _newSpectrum to set the preferredAxisOrdering</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pOrder</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="c1"># Define the preferred orderings</span>
    <span class="k">if</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">dimensionCount</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">dCodes</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;H N&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">(),</span> <span class="s1">&#39;H C&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">(),</span> <span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">,)]</span>
    <span class="k">elif</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">dimensionCount</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">dCodes</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;H C N&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">(),</span> <span class="s1">&#39;H H&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">(),</span> <span class="s1">&#39;C C&#39;</span><span class="o">.</span> <span class="n">split</span><span class="p">(),</span> <span class="s1">&#39;N N&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">()]</span>
    <span class="k">elif</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">dimensionCount</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
        <span class="n">dCodes</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;H C H N&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">(),</span> <span class="s1">&#39;H C H C&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">()]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dCodes</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># See if we can map one of the preferred orderings</span>
    <span class="k">for</span> <span class="n">dCode</span> <span class="ow">in</span> <span class="n">dCodes</span><span class="p">:</span>
        <span class="n">pOrder</span> <span class="o">=</span> <span class="n">_searchAxisCodePermutations</span><span class="p">(</span><span class="n">spectrum</span><span class="p">,</span> <span class="n">dCode</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pOrder</span> <span class="ow">and</span> <span class="n">pOrder</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">X_DIM_INDEX</span><span class="p">:</span>
            <span class="n">spectrum</span><span class="o">.</span><span class="n">_preferredAxisOrdering</span> <span class="o">=</span> <span class="n">pOrder</span>
            <span class="k">break</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">pOrder</span><span class="p">:</span>
        <span class="c1"># didn&#39;t find anything; revert to default [0...dimensionCount-1]</span>
        <span class="n">pOrder</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">dimensionIndices</span>

    <span class="k">return</span>

<span class="c1">#===========================================================================================================</span>
<span class="c1"># Spectrum/Peak parameter management</span>
<span class="c1">#===========================================================================================================</span>

<span class="k">def</span> <span class="nf">_setParameterValues</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">parameterName</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span><span class="n">Sequence</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">:</span><span class="n">Sequence</span><span class="p">,</span> <span class="n">dimensionCount</span><span class="p">:</span><span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;A helper function to reduce code overhead in setting parameters of Spectrum and Peak</span>
<span class="sd">    :return The list with values</span>

<span class="sd">    CCPNINTERNAL: used in setByAxisCode and setByDimension methods of</span>
<span class="sd">                  Spectrum and Peak classes</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">parameterName</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;object &quot;</span><span class="si">%s</span><span class="s1">&quot; does not have parameter &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span>
                         <span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">parameterName</span><span class="p">))</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">isIterable</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;setting &quot;</span><span class="si">%s</span><span class="s1">.</span><span class="si">%s</span><span class="s1">&quot; requires &quot;values&quot; tuple or list; got </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span>
                         <span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">parameterName</span><span class="p">,</span> <span class="n">values</span><span class="p">))</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">isIterable</span><span class="p">(</span><span class="n">dimensions</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;setting &quot;</span><span class="si">%s</span><span class="s1">.</span><span class="si">%s</span><span class="s1">&quot; requires &quot;dimensionIndices&quot; tuple or list; got </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span>
                         <span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">parameterName</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">))</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dimensions</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;setting &quot;</span><span class="si">%s</span><span class="s1">.</span><span class="si">%s</span><span class="s1">&quot;: unequal length of &quot;values&quot; and &quot;dimensionIndices&quot;; got </span><span class="si">%r</span><span class="s1"> and </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span>
                         <span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">parameterName</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">))</span>

    <span class="n">newValues</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">parameterName</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">dim</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dimensions</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">dim</span> <span class="o">&gt;</span> <span class="n">dimensionCount</span><span class="p">:</span>
            <span class="c1"># report error in 1-based, as the error is caught by the calling routines</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">: invalid dimension &quot;</span><span class="si">%s</span><span class="s1">&quot;; should be in range (1,</span><span class="si">%d</span><span class="s1">)&#39;</span> <span class="o">%</span>
                             <span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">dimensionCount</span><span class="p">))</span>
        <span class="n">newValues</span><span class="p">[</span><span class="n">dim</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">parameterName</span><span class="p">,</span> <span class="n">newValues</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;setting &quot;</span><span class="si">%s</span><span class="s1">.</span><span class="si">%s</span><span class="s1">&quot;: unable to set to </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span>
                         <span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">parameterName</span><span class="p">,</span> <span class="n">newValues</span><span class="p">))</span>

    <span class="c1"># we get the values from the obj, just in case some haven been modified</span>
    <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">parameterName</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_getParameterValues</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">parameterName</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">:</span><span class="n">Sequence</span><span class="p">,</span> <span class="n">dimensionCount</span><span class="p">:</span><span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;A helper function to reduce code overhead in setting parameters of Spectrum and Peak</span>
<span class="sd">    :return The list with values</span>

<span class="sd">    CCPNINTERNAL: used in getByAxisCode and getByDimension methods of</span>
<span class="sd">                  Spectrum and Peak classes</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">parameterName</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;object &quot;</span><span class="si">%s</span><span class="s1">&quot; does not have parameter &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span>
                         <span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">parameterName</span><span class="p">))</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">isIterable</span><span class="p">(</span><span class="n">dimensions</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;getting &quot;</span><span class="si">%s</span><span class="s1">.</span><span class="si">%s</span><span class="s1">&quot; requires &quot;dimensions&quot; tuple or list; got </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span>
                         <span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">parameterName</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">))</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">values</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">parameterName</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">: unable to get parameter &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">parameterName</span><span class="p">))</span>

    <span class="n">newValues</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">values</span><span class="p">):</span>
        <span class="c1"># this could be the case as in peak.assignedNmrAtoms</span>
        <span class="k">for</span> <span class="n">ll</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
            <span class="n">_newValuesForDim</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">dimensions</span><span class="p">:</span>
                <span class="n">_newValuesForDim</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ll</span><span class="p">[</span><span class="n">dim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">newValues</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">_newValuesForDim</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">newValues</span>

    <span class="n">newValues</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">dimensions</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">dim</span> <span class="o">&gt;</span> <span class="n">dimensionCount</span><span class="p">:</span>
            <span class="c1"># report error in 1-based, as the error is caught by the calling routines</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">: invalid dimension &quot;</span><span class="si">%s</span><span class="s1">&quot;; should be in range (1,</span><span class="si">%d</span><span class="s1">)&#39;</span> <span class="o">%</span>
                             <span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">dimensionCount</span><span class="p">))</span>
        <span class="n">newValues</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">dim</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">newValues</span>


<span class="k">def</span> <span class="nf">_orderByDimensions</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">,</span> <span class="n">dimensionCount</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Return a list of values of iterable in order defined by dimensions (default order if None).</span>

<span class="sd">    :param iterable: an iterable (tuple, list)</span>
<span class="sd">    :param dimensions: a tuple or list of dimensions (1..dimensionCount)</span>
<span class="sd">    :return: a list with values defined by iterable in dimensions order</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isIterable</span><span class="p">(</span><span class="n">iterable</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;not an iterable; got </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">iterable</span><span class="p">))</span>
    <span class="n">values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">isIterable</span><span class="p">(</span><span class="n">dimensions</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;&quot;dimensions&quot; is not iterable; got </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">dimensions</span><span class="p">))</span>

    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">dimensions</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="o">&lt;</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">dim</span> <span class="o">&gt;</span> <span class="n">dimensionCount</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;invalid dimension &quot;</span><span class="si">%s</span><span class="s1">&quot;; should be in range (1,</span><span class="si">%d</span><span class="s1">)&#39;</span> <span class="o">%</span>
                             <span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">dimensionCount</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">dim</span><span class="o">-</span><span class="mi">1</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;invalid dimension &quot;</span><span class="si">%s</span><span class="s1">&quot;; to large for iterable (</span><span class="si">%r</span><span class="s1">)&#39;</span> <span class="o">%</span>
                             <span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">values</span><span class="p">))</span>

        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">values</span><span class="p">[</span><span class="n">dim</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="c1">#===========================================================================================================</span>
<span class="c1"># GWV testing only</span>
<span class="c1">#===========================================================================================================</span>

<span class="kn">from</span> <span class="nn">ccpn.util.traits.CcpNmrTraits</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Int</span><span class="p">,</span> <span class="n">Float</span><span class="p">,</span> <span class="n">TraitError</span>


<div class="viewcode-block" id="SpectrumDimensionTrait"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.SpectrumLib.SpectrumDimensionTrait">[docs]</a><span class="k">class</span> <span class="nc">SpectrumDimensionTrait</span><span class="p">(</span><span class="n">List</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A trait to implement a Spectrum dimensional attribute; e.g. like spectrumFrequencies</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># GWV test</span>
    <span class="c1"># _spectrometerFrequencies = SpectrumDimensionTrait(trait=Float(min=0.0)).tag(</span>
    <span class="c1">#                            attributeName=&#39;spectrometerFrequency&#39;,</span>
    <span class="c1">#                            doCopy = True</span>
    <span class="c1"># )</span>

    <span class="n">isDimensional</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="SpectrumDimensionTrait.validate"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.SpectrumLib.SpectrumDimensionTrait.validate">[docs]</a>    <span class="k">def</span> <span class="nf">validate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Validate the value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">!=</span> <span class="n">obj</span><span class="o">.</span><span class="n">dimensionCount</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TraitError</span><span class="p">(</span><span class="s1">&#39;Setting &quot;</span><span class="si">%s</span><span class="s1">&quot;, invalid value &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">validate_elements</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">value</span></div>

    <span class="k">def</span> <span class="nf">_getValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the value of trait, obtained from the obj (i.e.spectrum) dimensions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dimensionAttributeName</span> <span class="o">:=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_metadata</span><span class="p">(</span><span class="s1">&#39;attributeName&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Undefined dimensional attributeName for trait </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="n">specDim</span><span class="p">,</span> <span class="n">dimensionAttributeName</span><span class="p">)</span> <span class="k">for</span> <span class="n">specDim</span> <span class="ow">in</span> <span class="n">obj</span><span class="o">.</span><span class="n">spectrumReferences</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">value</span>

<div class="viewcode-block" id="SpectrumDimensionTrait.get"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.SpectrumLib.SpectrumDimensionTrait.get">[docs]</a>    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getValue</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

        <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="ne">RuntimeError</span><span class="p">):</span>
            <span class="c1"># Check for a dynamic initializer.</span>
            <span class="n">dynamic_default</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dynamic_default_callable</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dynamic_default</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">TraitError</span><span class="p">(</span><span class="s2">&quot;No default value found for </span><span class="si">%s</span><span class="s2"> trait of </span><span class="si">%r</span><span class="s2">&quot;</span>
                                 <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">obj</span><span class="p">))</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">dynamic_default</span><span class="p">())</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">_trait_values</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">return</span> <span class="n">value</span>

        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="c1"># This should never be reached.</span>
            <span class="k">raise</span> <span class="n">TraitError</span><span class="p">(</span><span class="s1">&#39;Unexpected error in DimensionTrait&#39;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span> <span class="o">=</span> <span class="n">obj</span>  <span class="c1"># last obj used for get</span>
            <span class="k">return</span> <span class="n">value</span></div>

    <span class="k">def</span> <span class="nf">_setValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the value of trait, stored in the obj (i.e.spectrum) dimensions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dimensionAttributeName</span> <span class="o">:=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_metadata</span><span class="p">(</span><span class="s1">&#39;attributeName&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Undefined dimensional attributeName for trait </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">axis</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">spectrumReferences</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span> <span class="n">dimensionAttributeName</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

<div class="viewcode-block" id="SpectrumDimensionTrait.set"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.SpectrumLib.SpectrumDimensionTrait.set">[docs]</a>    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>

        <span class="n">new_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">old_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getValue</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="ne">RuntimeError</span><span class="p">):</span>
            <span class="n">old_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_value</span>

        <span class="c1"># obj._trait_values[self.name] = new_value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setValue</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">new_value</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">silent</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">old_value</span> <span class="o">==</span> <span class="n">new_value</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="c1"># if there is an error in comparing, default to notify</span>
            <span class="n">silent</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">silent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># we explicitly compare silent to True just in case the equality</span>
            <span class="c1"># comparison above returns something other than True/False</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">_notify_trait</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">old_value</span><span class="p">,</span> <span class="n">new_value</span><span class="p">)</span></div></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">Python  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">ccpn.core.lib.SpectrumLib</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright .
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.4.0.
    </div>
  </body>
</html>