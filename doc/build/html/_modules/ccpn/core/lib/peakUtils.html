
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ccpn.core.lib.peakUtils &#8212; Python  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/classic.css" />
    
    <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">Python  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">ccpn.core.lib.peakUtils</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for ccpn.core.lib.peakUtils</h1><div class="highlight"><pre>
<span></span><span class="c1">#=========================================================================================</span>
<span class="c1"># Licence, Reference and Credits</span>
<span class="c1">#=========================================================================================</span>
<span class="n">__copyright__</span> <span class="o">=</span> <span class="s2">&quot;Copyright (C) CCPN project (https://www.ccpn.ac.uk) 2014 - 2022&quot;</span>
<span class="n">__credits__</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Ed Brooksbank, Joanna Fox, Victoria A Higman, Luca Mureddu, Eliza Płoskoń&quot;</span><span class="p">,</span>
               <span class="s2">&quot;Timothy J Ragan, Brian O Smith, Gary S Thompson &amp; Geerten W Vuister&quot;</span><span class="p">)</span>
<span class="n">__licence__</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;CCPN licence. See https://ccpn.ac.uk/software/licensing/&quot;</span><span class="p">)</span>
<span class="n">__reference__</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Skinner, S.P., Fogh, R.H., Boucher, W., Ragan, T.J., Mureddu, L.G., &amp; Vuister, G.W.&quot;</span><span class="p">,</span>
                 <span class="s2">&quot;CcpNmr AnalysisAssign: a flexible platform for integrated NMR analysis&quot;</span><span class="p">,</span>
                 <span class="s2">&quot;J.Biomol.Nmr (2016), 66, 111-124, http://doi.org/10.1007/s10858-016-0060-y&quot;</span><span class="p">)</span>
<span class="c1">#=========================================================================================</span>
<span class="c1"># Last code modification</span>
<span class="c1">#=========================================================================================</span>
<span class="n">__modifiedBy__</span> <span class="o">=</span> <span class="s2">&quot;$modifiedBy: Ed Brooksbank $&quot;</span>
<span class="n">__dateModified__</span> <span class="o">=</span> <span class="s2">&quot;$dateModified: 2022-07-05 13:20:39 +0100 (Tue, July 05, 2022) $&quot;</span>
<span class="n">__version__</span> <span class="o">=</span> <span class="s2">&quot;$Revision: 3.1.0 $&quot;</span>
<span class="c1">#=========================================================================================</span>
<span class="c1"># Created</span>
<span class="c1">#=========================================================================================</span>
<span class="n">__author__</span> <span class="o">=</span> <span class="s2">&quot;$Author: CCPN $&quot;</span>
<span class="n">__date__</span> <span class="o">=</span> <span class="s2">&quot;$Date: 2017-04-07 10:28:41 +0000 (Fri, April 07, 2017) $&quot;</span>
<span class="c1">#=========================================================================================</span>
<span class="c1"># Start of code</span>
<span class="c1">#=========================================================================================</span>

<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Union</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">ccpn.util.Logging</span> <span class="kn">import</span> <span class="n">getLogger</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">curve_fit</span>
<span class="kn">from</span> <span class="nn">ccpn.core.PeakList</span> <span class="kn">import</span> <span class="n">GAUSSIANMETHOD</span><span class="p">,</span> <span class="n">PARABOLICMETHOD</span>
<span class="kn">from</span> <span class="nn">ccpn.core.lib.ContextManagers</span> <span class="kn">import</span> <span class="n">newObject</span><span class="p">,</span> <span class="n">undoBlock</span><span class="p">,</span> <span class="n">undoBlockWithoutSideBar</span><span class="p">,</span> <span class="n">notificationEchoBlocking</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">MultiIndex</span> <span class="k">as</span> <span class="n">m_ix</span>
<span class="kn">from</span> <span class="nn">ccpn.util.Common</span> <span class="kn">import</span> <span class="n">makeIterableList</span><span class="p">,</span> <span class="n">percentage</span>


<span class="c1"># This variables will be moved to SeriesAnalysisVariables.py</span>
<span class="n">_POSITION</span> <span class="o">=</span> <span class="s1">&#39;position&#39;</span>
<span class="n">_POINTPOSITION</span> <span class="o">=</span> <span class="s1">&#39;pointPosition&#39;</span>
<span class="n">_PPMPOSITION</span> <span class="o">=</span> <span class="s1">&#39;ppmPosition&#39;</span>
<span class="n">_LINEWIDTH</span> <span class="o">=</span> <span class="s1">&#39;lineWidth&#39;</span>
<span class="n">HEIGHT</span> <span class="o">=</span> <span class="s1">&#39;height&#39;</span>
<span class="n">VOLUME</span> <span class="o">=</span> <span class="s1">&#39;volume&#39;</span>
<span class="n">POSITIONS</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">_POSITION</span><span class="si">}</span><span class="s1">s&#39;</span>
<span class="n">LINEWIDTHS</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">_LINEWIDTH</span><span class="si">}</span><span class="s1">s&#39;</span>
<span class="n">POINTPOSITIONS</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">_POINTPOSITION</span><span class="si">}</span><span class="s1">s&#39;</span>
<span class="n">PPMPOSITIONS</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">_PPMPOSITION</span><span class="si">}</span><span class="s1">s&#39;</span>
<span class="n">RAW</span> <span class="o">=</span> <span class="s1">&#39;raw&#39;</span>
<span class="n">DELTAS</span> <span class="o">=</span> <span class="s1">&#39;deltas&#39;</span>
<span class="n">DELTA</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\u0394</span><span class="s1">&#39;</span>
<span class="n">Delta</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\u03B4</span><span class="s1">&#39;</span>
<span class="n">MODES</span> <span class="o">=</span> <span class="p">[</span><span class="n">POSITIONS</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">VOLUME</span><span class="p">,</span> <span class="n">LINEWIDTHS</span><span class="p">]</span>
<span class="n">DISPLAYDATA</span> <span class="o">=</span> <span class="p">[</span><span class="n">DELTA</span> <span class="o">+</span> <span class="n">Delta</span><span class="p">,</span> <span class="n">RAW</span><span class="p">]</span>
<span class="n">OTHER</span> <span class="o">=</span> <span class="s1">&#39;Other&#39;</span>
<span class="n">H</span> <span class="o">=</span> <span class="s1">&#39;H&#39;</span>
<span class="n">N</span> <span class="o">=</span> <span class="s1">&#39;N&#39;</span>
<span class="n">C</span> <span class="o">=</span> <span class="s1">&#39;C&#39;</span>
<span class="n">DefaultAtomWeights</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(((</span><span class="n">H</span><span class="p">,</span> <span class="mf">7.00</span><span class="p">),</span> <span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mf">1.00</span><span class="p">),</span> <span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="mf">4.00</span><span class="p">),</span> <span class="p">(</span><span class="n">OTHER</span><span class="p">,</span> <span class="mf">1.00</span><span class="p">)))</span>
<span class="n">NR_ID</span> <span class="o">=</span> <span class="s1">&#39;NR_ID&#39;</span>


<div class="viewcode-block" id="Dictlist"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.peakUtils.Dictlist">[docs]</a><span class="k">class</span> <span class="nc">Dictlist</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">Dictlist</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">[])</span>
        <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span></div>


<div class="viewcode-block" id="getMultipletPosition"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.peakUtils.getMultipletPosition">[docs]</a><span class="k">def</span> <span class="nf">getMultipletPosition</span><span class="p">(</span><span class="n">multiplet</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;ppm&#39;</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># skip if the position is None, otherwise check for dimensions</span>
        <span class="k">if</span> <span class="n">multiplet</span><span class="o">.</span><span class="n">position</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">multiplet</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1">#&quot;*NOT SET*&quot;</span>

        <span class="k">elif</span> <span class="n">unit</span> <span class="o">==</span> <span class="s1">&#39;ppm&#39;</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">multiplet</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>

        <span class="k">elif</span> <span class="n">unit</span> <span class="o">==</span> <span class="s1">&#39;point&#39;</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">multiplet</span><span class="o">.</span><span class="n">pointPositions</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>

        <span class="k">elif</span> <span class="n">unit</span> <span class="o">==</span> <span class="s1">&#39;Hz&#39;</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">multiplet</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">*</span> <span class="n">multiplet</span><span class="o">.</span><span class="n">multipletList</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">spectrometerFrequencies</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>  <span class="c1"># sampled</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unit passed to getPeakPosition must be &#39;ppm&#39;, &#39;point&#39;, or &#39;Hz&#39;, was </span><span class="si">%s</span><span class="s2">&quot;</span>
                             <span class="o">%</span> <span class="n">unit</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">value</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)):</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>  <span class="c1"># &#39;{0:.2f}&#39;.format(value)</span>

    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Error on setting Position. </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">e</span><span class="p">)</span></div>


<span class="c1"># return None</span>

<div class="viewcode-block" id="getMultipletLinewidth"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.peakUtils.getMultipletLinewidth">[docs]</a><span class="k">def</span> <span class="nf">getMultipletLinewidth</span><span class="p">(</span><span class="n">peak</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">dim</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">peak</span><span class="o">.</span><span class="n">lineWidths</span><span class="p">):</span>
        <span class="n">lw</span> <span class="o">=</span> <span class="n">peak</span><span class="o">.</span><span class="n">lineWidths</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">lw</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">lw</span><span class="p">)</span></div>


<div class="viewcode-block" id="getPeakPosition"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.peakUtils.getPeakPosition">[docs]</a><span class="k">def</span> <span class="nf">getPeakPosition</span><span class="p">(</span><span class="n">peak</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;ppm&#39;</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">peak</span><span class="o">.</span><span class="n">dimensionNmrAtoms</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">dim</span><span class="p">:</span>
        <span class="c1"># peakDim = peak.position[dim]</span>

        <span class="k">if</span> <span class="n">peak</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1">#&quot;*NOT SET*&quot;</span>

        <span class="k">elif</span> <span class="n">unit</span> <span class="o">==</span> <span class="s1">&#39;ppm&#39;</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">peak</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>

        <span class="k">elif</span> <span class="n">unit</span> <span class="o">==</span> <span class="s1">&#39;point&#39;</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">peak</span><span class="o">.</span><span class="n">pointPositions</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>

        <span class="k">elif</span> <span class="n">unit</span> <span class="o">==</span> <span class="s1">&#39;Hz&#39;</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">peak</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">*</span> <span class="n">peak</span><span class="o">.</span><span class="n">peakList</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">spectrometerFrequencies</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>  <span class="c1"># sampled</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unit passed to getPeakPosition must be &#39;ppm&#39;, &#39;point&#39;, or &#39;Hz&#39;, was </span><span class="si">%s</span><span class="s2">&quot;</span>
                             <span class="o">%</span> <span class="n">unit</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)):</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>  <span class="c1"># &#39;{0:.4f}&#39;.format(value)</span>

        <span class="k">return</span> <span class="kc">None</span></div>

        <span class="c1"># if isinstance(value, [int, float]):</span>
        <span class="c1"># # if type(value) is int or type(value) in (float, float32, float64):</span>
        <span class="c1">#   return &#39;%7.2f&#39; % float(value)</span>


<div class="viewcode-block" id="getPeakAnnotation"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.peakUtils.getPeakAnnotation">[docs]</a><span class="k">def</span> <span class="nf">getPeakAnnotation</span><span class="p">(</span><span class="n">peak</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">separator</span><span class="o">=</span><span class="s1">&#39;, &#39;</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">peak</span><span class="o">.</span><span class="n">dimensionNmrAtoms</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">dim</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">separator</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">dna</span><span class="o">.</span><span class="n">pid</span><span class="o">.</span><span class="n">id</span> <span class="k">for</span> <span class="n">dna</span> <span class="ow">in</span> <span class="n">peak</span><span class="o">.</span><span class="n">dimensionNmrAtoms</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">dna</span><span class="o">.</span><span class="n">isDeleted</span><span class="p">])</span></div>


<div class="viewcode-block" id="getPeakLinewidth"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.peakUtils.getPeakLinewidth">[docs]</a><span class="k">def</span> <span class="nf">getPeakLinewidth</span><span class="p">(</span><span class="n">peak</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the lineWidth in dimension &#39;dim&#39; for the peakTable entries</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lineWidths</span> <span class="o">=</span> <span class="n">peak</span><span class="o">.</span><span class="n">lineWidths</span>
    <span class="k">if</span> <span class="n">lineWidths</span> <span class="ow">and</span> <span class="n">dim</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">lineWidths</span><span class="p">):</span>
        <span class="n">lw</span> <span class="o">=</span> <span class="n">peak</span><span class="o">.</span><span class="n">lineWidths</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">lw</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">lw</span><span class="p">)</span>

    <span class="c1"># need to return this as a string otherwise the table changes between &#39;None&#39; and &#39;nan&#39;</span>
    <span class="k">return</span> <span class="s1">&#39;None&#39;</span></div>


<span class="k">def</span> <span class="nf">_pairIntersectionPoints</span><span class="p">(</span><span class="n">intersectionPoints</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Yield successive pair chunks from list of intersectionPoints &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">intersectionPoints</span><span class="p">),</span> <span class="mi">2</span><span class="p">):</span>
        <span class="n">pair</span> <span class="o">=</span> <span class="n">intersectionPoints</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">pair</span>


<span class="k">def</span> <span class="nf">_getIntersectionPoints</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">line</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :param line: x points of line to intersect y points</span>
<span class="sd">    :return: list of intersecting points</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">line</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">cross</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">z</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">z</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

    <span class="n">x_intersect</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">dx</span> <span class="o">/</span> <span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">z</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">z</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">negatives</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">cross</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">points</span> <span class="o">=</span> <span class="n">x_intersect</span><span class="p">[</span><span class="n">negatives</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">points</span>


<div class="viewcode-block" id="estimate1DPeakFWHM"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.peakUtils.estimate1DPeakFWHM">[docs]</a><span class="k">def</span> <span class="nf">estimate1DPeakFWHM</span><span class="p">(</span><span class="n">peak</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Estimate the 1D peak Full Width at Half Maximum.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    width:  The width for the peak in points.</span>
<span class="sd">    widthHeight: The height of the contour lines at which the `width` was evaluated.</span>
<span class="sd">    limits: tuple, Interpolated positions of left and right intersection points of a</span>
<span class="sd">        horizontal line at the respective evaluation height.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">peak_widths</span>
    <span class="kn">from</span> <span class="nn">ccpn.core.Peak</span> <span class="kn">import</span> <span class="n">Peak</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">peak</span><span class="p">,</span> <span class="n">Peak</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span>

    <span class="k">if</span> <span class="n">peak</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">dimensionCount</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span>

    <span class="n">y</span> <span class="o">=</span> <span class="n">peak</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">intensities</span>
    <span class="n">pointPositions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">peak</span><span class="o">.</span><span class="n">pointPosition</span><span class="p">[</span><span class="mi">0</span><span class="p">])])</span>
    <span class="n">widths</span><span class="p">,</span> <span class="n">widthHeight</span><span class="p">,</span> <span class="o">*</span><span class="n">limits</span> <span class="o">=</span> <span class="n">peak_widths</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">pointPositions</span><span class="p">,</span> <span class="n">rel_height</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="n">limits</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">limits</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">widths</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">widths</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">widths</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">widthHeight</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span></div>


<span class="k">def</span> <span class="nf">_getAtomWeight</span><span class="p">(</span><span class="n">axisCode</span><span class="p">,</span> <span class="n">atomWeights</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span> <span class="ow">or</span> <span class="nb">int</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    :param axisCode: str of peak axis code</span>
<span class="sd">    :param atomWeights: dictionary of atomWeights eg {&#39;H&#39;: 7.00, &#39;N&#39;: 1.00, &#39;C&#39;: 4.00, &#39;Other&#39;: 1.00}</span>
<span class="sd">    :return: float or int from dict atomWeights</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">value</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axisCode</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">firstLetterAxisCode</span> <span class="o">=</span> <span class="n">axisCode</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">firstLetterAxisCode</span> <span class="ow">in</span> <span class="n">atomWeights</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">atomWeights</span><span class="p">[</span><span class="n">firstLetterAxisCode</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">OTHER</span> <span class="ow">in</span> <span class="n">atomWeights</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">atomWeights</span><span class="p">[</span><span class="n">OTHER</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">atomWeights</span><span class="p">[</span><span class="n">OTHER</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="mf">1.0</span>

    <span class="k">return</span> <span class="n">value</span>


<span class="k">def</span> <span class="nf">_traverse</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">tree_types</span><span class="o">=</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
    <span class="sd">&quot;&quot;&quot;used to flat the state in a long list &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">tree_types</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">o</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">subvalue</span> <span class="ow">in</span> <span class="n">_traverse</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">tree_types</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">subvalue</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">o</span>


<span class="k">def</span> <span class="nf">_getPeaksForNmrResidueByNmrAtomNames</span><span class="p">(</span><span class="n">nmrResidue</span><span class="p">,</span> <span class="n">nmrAtomsNames</span><span class="p">,</span> <span class="n">spectra</span><span class="p">):</span>
    <span class="n">peaks</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">nmrAtoms</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">peakLists</span> <span class="o">=</span> <span class="p">[</span><span class="n">sp</span><span class="o">.</span><span class="n">peakLists</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">peakLists</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;No PeakList for </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">sp</span><span class="p">)</span>
                 <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">spectra</span><span class="p">]</span>  <span class="c1"># take only the last peakList if more then 1</span>
    <span class="k">for</span> <span class="n">nmrAtomName</span> <span class="ow">in</span> <span class="n">nmrAtomsNames</span><span class="p">:</span>
        <span class="n">nmrAtom</span> <span class="o">=</span> <span class="n">nmrResidue</span><span class="o">.</span><span class="n">getNmrAtom</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">nmrAtomName</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">nmrAtom</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nmrAtoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nmrAtom</span><span class="p">)</span>
    <span class="n">filteredPeaks</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">nmrAtomsNamesAvailable</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">nmrAtom</span> <span class="ow">in</span> <span class="n">nmrAtoms</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">nmrAtom</span><span class="o">.</span><span class="n">assignedPeaks</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">peak</span><span class="o">.</span><span class="n">peakList</span><span class="o">.</span><span class="n">spectrum</span> <span class="ow">in</span> <span class="n">spectra</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">nmrAtom</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">nmrAtomsNames</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">peak</span><span class="o">.</span><span class="n">peakList</span> <span class="ow">in</span> <span class="n">peakLists</span><span class="p">:</span>
                        <span class="n">filteredPeaks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">peak</span><span class="p">)</span>
                        <span class="n">nmrAtomsNamesAvailable</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nmrAtom</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">filteredPeaks</span><span class="p">)))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">spectra</span><span class="p">):</span>  <span class="c1"># deals when a residue is assigned to multiple peaks</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">nmrAtomsNamesAvailable</span><span class="p">)))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">nmrAtomsNames</span><span class="p">):</span>
            <span class="n">peaks</span> <span class="o">+=</span> <span class="n">filteredPeaks</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">filteredPeaks</span><span class="p">:</span>
            <span class="n">assignedNmrAtoms</span> <span class="o">=</span> <span class="n">_traverse</span><span class="p">(</span><span class="n">peak</span><span class="o">.</span><span class="n">assignedNmrAtoms</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">assignedNmrAtoms</span><span class="p">):</span>
                <span class="n">assignedNmrAtoms</span> <span class="o">=</span> <span class="p">[</span><span class="n">na</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">na</span> <span class="ow">in</span> <span class="n">assignedNmrAtoms</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">assignedNmrAtoms</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">list</span><span class="p">(</span><span class="n">assignedNmrAtoms</span><span class="p">)</span> <span class="o">==</span> <span class="n">nmrAtomsNames</span><span class="p">:</span>
                        <span class="n">peaks</span> <span class="o">+=</span> <span class="p">[</span><span class="n">peak</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nmrAtomsNames</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">nmrAtomsNames</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">assignedNmrAtoms</span><span class="p">:</span>
                        <span class="n">peaks</span> <span class="o">+=</span> <span class="p">[</span><span class="n">peak</span><span class="p">]</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">OrderedDict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">peaks</span><span class="p">))</span>


<div class="viewcode-block" id="getNmrResiduePeakProperty"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.peakUtils.getNmrResiduePeakProperty">[docs]</a><span class="k">def</span> <span class="nf">getNmrResiduePeakProperty</span><span class="p">(</span><span class="n">nmrResidue</span><span class="p">,</span> <span class="n">nmrAtomsNames</span><span class="p">,</span> <span class="n">spectra</span><span class="p">,</span> <span class="n">theProperty</span><span class="o">=</span><span class="s1">&#39;height&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    :param nmrResidue:</span>
<span class="sd">    :param nmrAtomsNames: nmr Atoms to compare. str &#39;H&#39;, &#39;N&#39;, &#39;CA&#39; etc</span>
<span class="sd">    :param spectra: compare peaks only from given spectra</span>
<span class="sd">    :param theProperty: &#39;height&#39; or &#39;volume&#39;</span>
<span class="sd">    :return:</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">ll</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spectra</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">theProperty</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">,</span> <span class="s1">&#39;volume&#39;</span><span class="p">]:</span>
        <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Property not currently available </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">theProperty</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="n">peaks</span> <span class="o">=</span> <span class="n">_getPeaksForNmrResidueByNmrAtomNames</span><span class="p">(</span><span class="n">nmrResidue</span><span class="p">,</span> <span class="n">nmrAtomsNames</span><span class="p">,</span> <span class="n">spectra</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">peaks</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">peaks</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">peak</span><span class="o">.</span><span class="n">peakList</span><span class="o">.</span><span class="n">spectrum</span> <span class="ow">in</span> <span class="n">spectra</span><span class="p">:</span>
                <span class="n">p</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">peak</span><span class="p">,</span> <span class="n">theProperty</span><span class="p">)</span>
                <span class="n">ll</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ll</span><span class="p">,</span> <span class="n">peaks</span></div>


<div class="viewcode-block" id="getNmrResiduePeakHeight"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.peakUtils.getNmrResiduePeakHeight">[docs]</a><span class="k">def</span> <span class="nf">getNmrResiduePeakHeight</span><span class="p">(</span><span class="n">nmrResidue</span><span class="p">,</span> <span class="n">nmrAtomsNames</span><span class="p">,</span> <span class="n">spectra</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :param nmrResidue:</span>
<span class="sd">    :param nmrAtomsNames: nmr Atoms to compare. str &#39;H&#39;, &#39;N&#39;, &#39;CA&#39; etc</span>
<span class="sd">    :param spectra: compare peaks only from given spectra</span>
<span class="sd">    :return:</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Deprecated. Used getNmrResiduePeakProperty with theProperty = &quot;height&quot;&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">getNmrResiduePeakProperty</span><span class="p">(</span><span class="n">nmrResidue</span><span class="p">,</span> <span class="n">nmrAtomsNames</span><span class="p">,</span> <span class="n">spectra</span><span class="p">,</span> <span class="n">theProperty</span><span class="o">=</span><span class="s1">&#39;height&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="getRawDataFrame"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.peakUtils.getRawDataFrame">[docs]</a><span class="k">def</span> <span class="nf">getRawDataFrame</span><span class="p">(</span><span class="n">nmrResidues</span><span class="p">,</span> <span class="n">nmrAtomsNames</span><span class="p">,</span> <span class="n">spectra</span><span class="p">,</span> <span class="n">theProperty</span><span class="p">):</span>
    <span class="n">dfs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">sp</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">spectra</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">nmrResidue</span> <span class="ow">in</span> <span class="n">nmrResidues</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="s1">&#39;-&#39;</span> <span class="ow">in</span> <span class="n">nmrResidue</span><span class="o">.</span><span class="n">sequenceCode</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">):</span>  <span class="c1"># not consider the +1 and -1 residues</span>
            <span class="n">ll</span> <span class="o">=</span> <span class="n">getNmrResiduePeakProperty</span><span class="p">(</span><span class="n">nmrResidue</span><span class="p">,</span> <span class="n">nmrAtomsNames</span><span class="p">,</span> <span class="n">spectra</span><span class="p">,</span> <span class="n">theProperty</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ll</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">ll</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="n">nmrResidue</span><span class="o">.</span><span class="n">pid</span><span class="p">],</span> <span class="n">columns</span><span class="o">=</span><span class="n">names</span><span class="p">)</span>
                <span class="n">dfs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">dfs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">data</span></div>


<span class="k">def</span> <span class="nf">_getPeaksForNmrResidue</span><span class="p">(</span><span class="n">nmrResidue</span><span class="p">,</span> <span class="n">nmrAtomsNames</span><span class="p">,</span> <span class="n">spectra</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spectra</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="n">_peaks</span> <span class="o">=</span> <span class="n">_getPeaksForNmrResidueByNmrAtomNames</span><span class="p">(</span><span class="n">nmrResidue</span><span class="p">,</span> <span class="n">nmrAtomsNames</span><span class="p">,</span> <span class="n">spectra</span><span class="p">)</span>
    <span class="n">usepeaks</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">_peaks</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">_peaks</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">peak</span><span class="o">.</span><span class="n">peakList</span><span class="o">.</span><span class="n">spectrum</span> <span class="ow">in</span> <span class="n">spectra</span><span class="p">:</span>
                <span class="n">usepeaks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">peak</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">usepeaks</span>


<div class="viewcode-block" id="getNmrResidueDeltas"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.peakUtils.getNmrResidueDeltas">[docs]</a><span class="k">def</span> <span class="nf">getNmrResidueDeltas</span><span class="p">(</span><span class="n">nmrResidue</span><span class="p">,</span> <span class="n">nmrAtomsNames</span><span class="p">,</span> <span class="n">spectra</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">POSITIONS</span><span class="p">,</span> <span class="n">atomWeights</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    :param nmrResidue:</span>
<span class="sd">    :param nmrAtomsNames: nmr Atoms to compare. str &#39;H&#39;, &#39;N&#39;, &#39;CA&#39; etc</span>
<span class="sd">    :param spectra: compare peaks only from given spectra</span>
<span class="sd">    :return:</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">deltas</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spectra</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="n">peaks</span> <span class="o">=</span> <span class="n">_getPeaksForNmrResidueByNmrAtomNames</span><span class="p">(</span><span class="n">nmrResidue</span><span class="p">,</span> <span class="n">nmrAtomsNames</span><span class="p">,</span> <span class="n">spectra</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">atomWeights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">atomWeights</span> <span class="o">=</span> <span class="n">DefaultAtomWeights</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">peaks</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">peaks</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">peak</span><span class="o">.</span><span class="n">peakList</span><span class="o">.</span><span class="n">spectrum</span> <span class="ow">in</span> <span class="n">spectra</span><span class="p">:</span>
                <span class="c1"># try:  #some None value can get in here</span>
                <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="n">POSITIONS</span><span class="p">:</span>
                    <span class="n">deltaTemp</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">axisCode</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">peak</span><span class="o">.</span><span class="n">axisCodes</span><span class="p">):</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axisCode</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">axisCode</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">nmrAtomsNames</span><span class="p">):</span>
                                <span class="n">weight</span> <span class="o">=</span> <span class="n">_getAtomWeight</span><span class="p">(</span><span class="n">axisCode</span><span class="p">,</span> <span class="n">atomWeights</span><span class="p">)</span>
                                <span class="k">if</span> <span class="n">peaks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">peak</span><span class="p">:</span>  <span class="c1"># dont&#39; compare to same peak</span>
                                    <span class="n">delta</span> <span class="o">=</span> <span class="n">peak</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">peaks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                                    <span class="n">delta</span> <span class="o">=</span> <span class="n">delta</span> <span class="o">**</span> <span class="mi">2</span>
                                    <span class="n">delta</span> <span class="o">=</span> <span class="n">delta</span> <span class="o">*</span> <span class="n">weight</span>
                                    <span class="n">deltaTemp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span>
                                    <span class="c1"># deltaInts.append(((peak.position[i] - list(peaks)[0].position[i]) * weight) ** 2)</span>
                                    <span class="c1"># delta += ((list(peaks)[0].position[i] - peak.position[i]) * weight) ** 2</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">deltaTemp</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">delta</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">deltaTemp</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span>
                        <span class="n">deltas</span> <span class="o">+=</span> <span class="p">[</span><span class="n">delta</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="n">VOLUME</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">list</span><span class="p">(</span><span class="n">peaks</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">peak</span><span class="p">:</span>  <span class="c1"># dont&#39; compare to same peak</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">peak</span><span class="o">.</span><span class="n">volume</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">peaks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">volume</span> <span class="ow">or</span> <span class="n">peaks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">volume</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Volume has to be set for peaks: </span><span class="si">%s</span><span class="s1">, </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">peak</span><span class="p">,</span> <span class="n">peaks</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                            <span class="k">break</span>

                        <span class="n">delta1Atoms</span> <span class="o">=</span> <span class="p">(</span><span class="n">peak</span><span class="o">.</span><span class="n">volume</span> <span class="o">/</span> <span class="nb">list</span><span class="p">(</span><span class="n">peaks</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">volume</span><span class="p">)</span>
                        <span class="n">deltas</span> <span class="o">+=</span> <span class="p">[((</span><span class="n">delta1Atoms</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">,</span> <span class="p">]</span>

                <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="n">HEIGHT</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">list</span><span class="p">(</span><span class="n">peaks</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">peak</span><span class="p">:</span>  <span class="c1"># dont&#39; compare to same peak</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">peak</span><span class="o">.</span><span class="n">height</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">peaks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">height</span> <span class="ow">or</span> <span class="n">peaks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">height</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Height has to be set for peaks: </span><span class="si">%s</span><span class="s1">, </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">peak</span><span class="p">,</span> <span class="n">peaks</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                            <span class="k">break</span>

                        <span class="n">delta1Atoms</span> <span class="o">=</span> <span class="p">(</span><span class="n">peak</span><span class="o">.</span><span class="n">height</span> <span class="o">/</span> <span class="nb">list</span><span class="p">(</span><span class="n">peaks</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">height</span><span class="p">)</span>
                        <span class="n">deltas</span> <span class="o">+=</span> <span class="p">[((</span><span class="n">delta1Atoms</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">,</span> <span class="p">]</span>

                <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="n">LINEWIDTHS</span><span class="p">:</span>
                    <span class="n">deltaTemp</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">axisCode</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">peak</span><span class="o">.</span><span class="n">axisCodes</span><span class="p">):</span>
                        <span class="k">if</span> <span class="nb">list</span><span class="p">(</span><span class="n">peaks</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">peak</span><span class="p">:</span>  <span class="c1"># dont&#39; compare to same peak</span>
                            <span class="k">if</span> <span class="n">axisCode</span><span class="p">:</span>
                                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axisCode</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                                    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">axisCode</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">nmrAtomsNames</span><span class="p">):</span>
                                        <span class="n">weight</span> <span class="o">=</span> <span class="n">_getAtomWeight</span><span class="p">(</span><span class="n">axisCode</span><span class="p">,</span> <span class="n">atomWeights</span><span class="p">)</span>
                                        <span class="k">if</span> <span class="ow">not</span> <span class="n">peak</span><span class="o">.</span><span class="n">lineWidths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">peaks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lineWidths</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                                            <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;lineWidth has to be set for peaks: </span><span class="si">%s</span><span class="s1">, </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">peak</span><span class="p">,</span> <span class="n">peaks</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                                            <span class="k">break</span>
                                        <span class="n">delta</span> <span class="o">=</span> <span class="p">((</span><span class="n">peak</span><span class="o">.</span><span class="n">lineWidths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="nb">list</span><span class="p">(</span><span class="n">peaks</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lineWidths</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="n">weight</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
                                        <span class="n">deltaTemp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">deltaTemp</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">delta</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">deltaTemp</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span>
                        <span class="n">deltas</span> <span class="o">+=</span> <span class="p">[</span><span class="n">delta</span><span class="p">]</span>

            <span class="c1"># except Exception as e:</span>
            <span class="c1">#     message = &#39;Error for calculation mode: %s on %s and %s. &#39; % (mode, peak.pid, list(peaks)[0].pid) + str(e)</span>
            <span class="c1">#     getLogger().debug(message)</span>

    <span class="k">if</span> <span class="n">deltas</span> <span class="ow">and</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">in</span> <span class="n">deltas</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">round</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">deltas</span><span class="p">)),</span> <span class="mi">3</span><span class="p">)</span>
    <span class="k">return</span></div>


<span class="k">def</span> <span class="nf">_getKd</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">param</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">maxfev</span><span class="o">=</span><span class="mi">6000</span><span class="p">)</span>
        <span class="n">bindingUnscaled</span><span class="p">,</span> <span class="n">bmax</span> <span class="o">=</span> <span class="n">param</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">yScaled</span> <span class="o">=</span> <span class="n">y</span> <span class="o">/</span> <span class="n">bmax</span>

        <span class="n">paramScaled</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">yScaled</span><span class="p">,</span> <span class="n">maxfev</span><span class="o">=</span><span class="mi">6000</span><span class="p">)</span>
        <span class="n">kd</span><span class="p">,</span> <span class="n">bmax</span> <span class="o">=</span> <span class="n">paramScaled</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
        <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Impossible to estimate Kd values. </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">err</span><span class="p">)</span>
        <span class="n">kd</span><span class="p">,</span> <span class="n">bmax</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">kd</span>


<div class="viewcode-block" id="oneSiteBindingCurve"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.peakUtils.oneSiteBindingCurve">[docs]</a><span class="k">def</span> <span class="nf">oneSiteBindingCurve</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">kd</span><span class="p">,</span> <span class="n">bmax</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">bmax</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">kd</span><span class="p">)</span></div>


<div class="viewcode-block" id="exponenial_func"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.peakUtils.exponenial_func">[docs]</a><span class="k">def</span> <span class="nf">exponenial_func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">b</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_fit1SiteBindCurve</span><span class="p">(</span><span class="n">bindingCurves</span><span class="p">,</span> <span class="n">aFunc</span><span class="o">=</span><span class="n">oneSiteBindingCurve</span><span class="p">,</span> <span class="n">xfStep</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">xfPercent</span><span class="o">=</span><span class="mi">30</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :param bindingCurves: DataFrame as: Columns -&gt; float or int.</span>
<span class="sd">                                                  Used as xs points (e.g. concentration/time/etc value)</span>
<span class="sd">                                        rows    -&gt; float or int.</span>
<span class="sd">                                                  Used as ys points (e.g. Deltadelta in ppm)</span>
<span class="sd">                                                  the actual curve points</span>
<span class="sd">                                        index   -&gt; obj. E.g. nmrResidue obj. used as identifier for the curve origin</span>

<span class="sd">                                        | index          |    1   |   2   |</span>
<span class="sd">                                        |----------------+--------|-------|</span>
<span class="sd">                                        | obj1           |    1.0 |   1.1 |</span>
<span class="sd">                                        | obj2           |    2.0 |   1.2 |</span>

<span class="sd">    :param aFunc:  Default: oneSiteBindingCurve.</span>
<span class="sd">    :param xfStep: number of x points for generating the fitted curve.</span>
<span class="sd">    :param xfPercent: percent to add to max X value of the fitted curve, so to have a longer curve after the last</span>
<span class="sd">                    experimental value.</span>

<span class="sd">    :return: tuple of parameters for plotting fitted curves.</span>
<span class="sd">             x_atHalf_Y: the x value for half of Y. Used as estimated  kd</span>
<span class="sd">             xs: array of xs. Original xs points from the dataFrame columns</span>
<span class="sd">             yScaled: array of yScaled. Scaled to have values 0 to 1</span>
<span class="sd">             xf: array of x point for the new fitted curve. A range from 0 to max of xs.</span>
<span class="sd">             yf: array the fitted curve</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">curve_fit</span>
    <span class="kn">from</span> <span class="nn">ccpn.util.Common</span> <span class="kn">import</span> <span class="n">percentage</span>

    <span class="n">errorValue</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span> <span class="o">*</span> <span class="mi">6</span>
    <span class="k">if</span> <span class="n">aFunc</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">aFunc</span><span class="p">):</span>
        <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Error. Fitting curve </span><span class="si">%s</span><span class="s2"> is not callable&quot;</span> <span class="o">%</span> <span class="n">aFunc</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">errorValue</span>
    <span class="k">if</span> <span class="n">bindingCurves</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Error. Binding curves not found&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">errorValue</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">bindingCurves</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">ys</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>  <span class="c1">#puts all y values in a single 1d array.</span>
    <span class="n">xss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span> <span class="o">*</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">xs</span> <span class="o">=</span> <span class="n">xss</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>  <span class="c1"># #puts all x values in a 1d array preserving the original y positions (order=&#39;F&#39;).</span>
    <span class="c1"># print(( xs, ys), &#39;$$$&#39;)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">errorValue</span>  <span class="c1">#not enough datapoints</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">param</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span><span class="n">aFunc</span><span class="p">,</span> <span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">)</span>
        <span class="n">xhalfUnscaled</span><span class="p">,</span> <span class="n">bMaxUnscaled</span> <span class="o">=</span> <span class="n">param</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">yScaled</span> <span class="o">=</span> <span class="n">ys</span> <span class="o">/</span> <span class="n">bMaxUnscaled</span>  <span class="c1">#scales y to have values 0-1</span>
        <span class="n">paramScaled</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span><span class="n">aFunc</span><span class="p">,</span> <span class="n">xs</span><span class="p">,</span> <span class="n">yScaled</span><span class="p">)</span>
        <span class="n">xfRange</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span>
        <span class="n">xfPerc</span> <span class="o">=</span> <span class="n">percentage</span><span class="p">(</span><span class="n">xfPercent</span><span class="p">,</span> <span class="n">xfRange</span><span class="p">)</span>
        <span class="n">xfMax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span> <span class="o">+</span> <span class="n">xfPerc</span>
        <span class="n">xf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">xfMax</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="n">xfStep</span><span class="p">)</span>
        <span class="n">yf</span> <span class="o">=</span> <span class="n">aFunc</span><span class="p">(</span><span class="n">xf</span><span class="p">,</span> <span class="o">*</span><span class="n">paramScaled</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">x_atHalf_Y</span><span class="p">,</span> <span class="n">bmax</span> <span class="o">=</span> <span class="n">paramScaled</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">x_atHalf_Y</span><span class="p">,</span> <span class="n">bmax</span><span class="p">,</span> <span class="n">xs</span><span class="p">,</span> <span class="n">yScaled</span><span class="p">,</span> <span class="n">xf</span><span class="p">,</span> <span class="n">yf</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
        <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Impossible to estimate Kd value </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">err</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">errorValue</span>


<span class="k">def</span> <span class="nf">_fitExpDecayCurve</span><span class="p">(</span><span class="n">bindingCurves</span><span class="p">,</span> <span class="n">aFunc</span><span class="o">=</span><span class="n">exponenial_func</span><span class="p">,</span> <span class="n">xfStep</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">xfPercent</span><span class="o">=</span><span class="mi">80</span><span class="p">,</span> <span class="n">p0</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :param TODO</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">errorValue</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span> <span class="o">*</span> <span class="mi">6</span>
    <span class="k">if</span> <span class="n">aFunc</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">aFunc</span><span class="p">):</span>
        <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Error. Fitting curve </span><span class="si">%s</span><span class="s2"> is not callable&quot;</span> <span class="o">%</span> <span class="n">aFunc</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">errorValue</span>
    <span class="k">if</span> <span class="n">bindingCurves</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Error. Binding curves not found&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">errorValue</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">bindingCurves</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">ys</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>  <span class="c1">#puts all y values in a single 1d array.</span>
    <span class="n">xss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span> <span class="o">*</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">xs</span> <span class="o">=</span> <span class="n">xss</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>  <span class="c1"># #puts all x values in a 1d array preserving the original y positions (order=&#39;F&#39;).</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">errorValue</span>  <span class="c1">#not enough datapoints</span>
    <span class="c1"># try:</span>

    <span class="n">popt</span><span class="p">,</span> <span class="n">pcov</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span><span class="n">aFunc</span><span class="p">,</span> <span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="n">p0</span><span class="o">=</span><span class="n">p0</span><span class="p">)</span>

    <span class="n">interc</span><span class="p">,</span> <span class="n">slope</span> <span class="o">=</span> <span class="n">popt</span>
    <span class="c1"># yScaled = ys / interc  # scales y to have values 0-1</span>
    <span class="c1"># poptScaled, pcov  = curve_fit(aFunc, xs, yScaled)</span>
    <span class="n">yScaled</span> <span class="o">=</span> <span class="p">(</span><span class="n">ys</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">ys</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ys</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">ys</span><span class="p">))</span>
    <span class="n">yScaled</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">yScaled</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># cannot fit nans</span>
    <span class="n">popt</span><span class="p">,</span> <span class="n">pcov</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span><span class="n">exponenial_func</span><span class="p">,</span> <span class="n">xs</span><span class="p">,</span> <span class="n">yScaled</span><span class="p">,</span> <span class="n">p0</span><span class="o">=</span><span class="n">popt</span><span class="p">)</span>
    <span class="n">interc</span><span class="p">,</span> <span class="n">slope</span> <span class="o">=</span> <span class="n">popt</span>
    <span class="n">xfRange</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span>
    <span class="n">xfPerc</span> <span class="o">=</span> <span class="n">percentage</span><span class="p">(</span><span class="n">xfPercent</span><span class="p">,</span> <span class="n">xfRange</span><span class="p">)</span>
    <span class="n">xfMax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span> <span class="o">+</span> <span class="n">xfPerc</span>
    <span class="n">xf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">xfMax</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="n">xfStep</span><span class="p">)</span>
    <span class="n">yf</span> <span class="o">=</span> <span class="n">aFunc</span><span class="p">(</span><span class="n">xf</span><span class="p">,</span> <span class="o">*</span><span class="n">popt</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">yScaled</span><span class="p">,</span> <span class="n">xf</span><span class="p">,</span> <span class="n">yf</span><span class="p">,</span> <span class="o">*</span><span class="n">popt</span><span class="p">)</span>
    <span class="c1"># except Exception as err:</span>
    <span class="c1">#     getLogger().warning(&#39;Impossible to estimate Kd value %s&#39; % (err))</span>
    <span class="c1"># return errorValue</span>


<div class="viewcode-block" id="snapToExtremum"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.peakUtils.snapToExtremum">[docs]</a><span class="k">def</span> <span class="nf">snapToExtremum</span><span class="p">(</span><span class="n">peak</span><span class="p">:</span> <span class="s1">&#39;Peak&#39;</span><span class="p">,</span> <span class="n">halfBoxSearchWidth</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">halfBoxFitWidth</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
                   <span class="n">minDropFactor</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">fitMethod</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">PARABOLICMETHOD</span><span class="p">,</span>
                   <span class="n">searchBoxMode</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">searchBoxDoFit</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Snap the position of the peak the nearest extremum.</span>
<span class="sd">    Assumes called with an existing peak, will fit within a box ±halfBoxSearchWidth about the current peak position.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">ccpn.framework.Application</span> <span class="kn">import</span> <span class="n">getApplication</span>

    <span class="n">spectrum</span> <span class="o">=</span> <span class="n">peak</span><span class="o">.</span><span class="n">spectrum</span>
    <span class="n">numDim</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">dimensionCount</span>
    <span class="n">getApp</span> <span class="o">=</span> <span class="n">getApplication</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">numDim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># do the fit for 1D here</span>
        <span class="n">doNeg</span> <span class="o">=</span> <span class="n">getApp</span><span class="o">.</span><span class="n">preferences</span><span class="o">.</span><span class="n">general</span><span class="o">.</span><span class="n">negativePeakPick1D</span>
        <span class="n">_snap1DPeakToClosestExtremum</span><span class="p">(</span><span class="n">peak</span><span class="p">,</span> <span class="n">maximumLimit</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">doNeg</span><span class="o">=</span><span class="n">doNeg</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">ccpn.core.lib.PeakPickers.PeakPickerNd</span> <span class="kn">import</span> <span class="n">PeakPickerNd</span>

        <span class="n">spectrum</span> <span class="o">=</span> <span class="n">peak</span><span class="o">.</span><span class="n">spectrum</span>
        <span class="n">myPeakPicker</span> <span class="o">=</span> <span class="n">PeakPickerNd</span><span class="p">(</span><span class="n">spectrum</span><span class="o">=</span><span class="n">spectrum</span><span class="p">)</span>
        <span class="n">myPeakPicker</span><span class="o">.</span><span class="n">setParameters</span><span class="p">(</span><span class="n">dropFactor</span><span class="o">=</span><span class="n">minDropFactor</span><span class="p">,</span>
                                   <span class="n">fitMethod</span><span class="o">=</span><span class="n">fitMethod</span><span class="p">,</span>
                                   <span class="n">searchBoxMode</span><span class="o">=</span><span class="n">searchBoxMode</span><span class="p">,</span>
                                   <span class="n">searchBoxDoFit</span><span class="o">=</span><span class="n">searchBoxDoFit</span><span class="p">,</span>
                                   <span class="n">halfBoxSearchWidth</span><span class="o">=</span><span class="n">halfBoxSearchWidth</span><span class="p">,</span>
                                   <span class="n">halfBoxFitWidth</span><span class="o">=</span><span class="n">halfBoxFitWidth</span><span class="p">,</span>
                                   <span class="n">searchBoxWidths</span><span class="o">=</span><span class="n">getApp</span><span class="o">.</span><span class="n">preferences</span><span class="o">.</span><span class="n">general</span><span class="o">.</span><span class="n">searchBoxWidthsNd</span><span class="p">,</span>
                                   <span class="p">)</span>

        <span class="n">myPeakPicker</span><span class="o">.</span><span class="n">snapToExtremum</span><span class="p">(</span><span class="n">peak</span><span class="p">)</span></div>


<div class="viewcode-block" id="peakParabolicInterpolation"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.peakUtils.peakParabolicInterpolation">[docs]</a><span class="k">def</span> <span class="nf">peakParabolicInterpolation</span><span class="p">(</span><span class="n">peak</span><span class="p">:</span> <span class="s1">&#39;Peak&#39;</span><span class="p">,</span> <span class="n">update</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    return a (position, height, heightError) tuple using parabolic interpolation</span>
<span class="sd">    of the peak.position</span>

<span class="sd">    :param peak: a core.Peak instance or Pid or valid pid-string</span>
<span class="sd">    :param update: flag indicating peak position and height to be updated</span>

<span class="sd">    :return: (position, height) tuple;  position is a list with length</span>
<span class="sd">                                        spectrum.dimensionCount</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">numpy</span>
    <span class="kn">from</span> <span class="nn">ccpn.core.Peak</span> <span class="kn">import</span> <span class="n">Peak</span>
    <span class="kn">from</span> <span class="nn">ccpn.core.lib.Pid</span> <span class="kn">import</span> <span class="n">Pid</span>
    <span class="kn">from</span> <span class="nn">ccpn.framework.Application</span> <span class="kn">import</span> <span class="n">getApplication</span>
    <span class="kn">from</span> <span class="nn">ccpn.util.Parabole</span> <span class="kn">import</span> <span class="n">Parabole</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">peak</span><span class="p">,</span> <span class="n">Peak</span><span class="p">):</span>
        <span class="k">pass</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">peak</span><span class="p">,</span> <span class="p">(</span><span class="n">Pid</span><span class="p">,</span> <span class="nb">str</span><span class="p">)):</span>
        <span class="n">_peak</span> <span class="o">=</span> <span class="n">getApplication</span><span class="p">()</span><span class="o">.</span><span class="n">project</span><span class="o">.</span><span class="n">getByPid</span><span class="p">(</span><span class="n">peak</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">_peak</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Error retrieving valid peak instance from &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="n">peak</span><span class="p">)</span>
        <span class="n">peak</span> <span class="o">=</span> <span class="n">_peak</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Expected a Peak, Pid or valid pid-string for the &quot;peak&quot; argument&#39;</span><span class="p">)</span>

    <span class="n">spectrum</span> <span class="o">=</span> <span class="n">peak</span><span class="o">.</span><span class="n">peakList</span><span class="o">.</span><span class="n">spectrum</span>
    <span class="n">spectrum</span><span class="o">.</span><span class="n">checkValidPath</span><span class="p">()</span>

    <span class="c1"># get the position as the nearest grid point</span>
    <span class="n">position</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">peak</span><span class="o">.</span><span class="n">pointPositions</span><span class="p">]</span>
    <span class="c1"># # get the data +/-1 point along each axis</span>
    <span class="c1"># sliceTuples = [(p - 1, p + 1) for p in position]  # nb: sliceTuples run [1,n] with n inclusive</span>

    <span class="n">_valuesPerPoint</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">ppmPerPoints</span>
    <span class="n">_axisCodes</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">axisCodes</span>
    <span class="n">_regionData</span> <span class="o">=</span> <span class="p">{</span><span class="n">axisCode</span><span class="p">:</span> <span class="p">(</span><span class="n">ppm</span> <span class="o">-</span> <span class="n">valPerPoint</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ppm</span> <span class="o">+</span> <span class="n">valPerPoint</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,)</span> <span class="k">for</span> <span class="n">axisCode</span><span class="p">,</span> <span class="n">ppm</span><span class="p">,</span> <span class="n">valPerPoint</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">_axisCodes</span><span class="p">,</span> <span class="n">peak</span><span class="o">.</span><span class="n">ppmPositions</span><span class="p">,</span> <span class="n">_valuesPerPoint</span><span class="p">)}</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">getRegion</span><span class="p">(</span><span class="o">**</span><span class="n">_regionData</span><span class="p">)</span>

    <span class="n">heights</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span> <span class="o">*</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">dimensionCount</span>
    <span class="n">newPosition</span> <span class="o">=</span> <span class="n">position</span><span class="p">[:]</span>
    <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">spectrum</span><span class="o">.</span><span class="n">dimensionCount</span><span class="p">):</span>
        <span class="c1"># get the three y-values along axis, but centered for the other axes</span>
        <span class="n">slices</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">spectrum</span><span class="o">.</span><span class="n">dimensionCount</span><span class="p">)]</span>
        <span class="n">slices</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">yValues</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slices</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="c1"># create points list for the Parabole method</span>
        <span class="n">point</span> <span class="o">=</span> <span class="n">position</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
        <span class="n">points</span> <span class="o">=</span> <span class="p">[(</span><span class="n">p</span><span class="p">,</span> <span class="n">yValues</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">((</span><span class="n">point</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">point</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))]</span>
        <span class="n">parabole</span> <span class="o">=</span> <span class="n">Parabole</span><span class="o">.</span><span class="n">fromPoints</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="n">newPosition</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span> <span class="n">heights</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">parabole</span><span class="o">.</span><span class="n">maxValue</span><span class="p">()</span>

    <span class="n">arr</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">heights</span><span class="p">)</span>
    <span class="n">height</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">arr</span><span class="p">))</span>
    <span class="n">heightError</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">update</span><span class="p">:</span>
        <span class="n">peak</span><span class="o">.</span><span class="n">pointPositions</span> <span class="o">=</span> <span class="n">newPosition</span>
        <span class="n">peak</span><span class="o">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">height</span>
        <span class="n">peak</span><span class="o">.</span><span class="n">heightError</span> <span class="o">=</span> <span class="n">heightError</span>
    <span class="k">return</span> <span class="n">newPosition</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">heightError</span></div>


<div class="viewcode-block" id="estimateVolumes"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.peakUtils.estimateVolumes">[docs]</a><span class="k">def</span> <span class="nf">estimateVolumes</span><span class="p">(</span><span class="n">peaks</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="s1">&#39;Peak&#39;</span><span class="p">]],</span> <span class="n">volumeIntegralLimit</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">noWarning</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Estimate the volumes for the peaks</span>
<span class="sd">    :param peaks: list of peaks as pids or strings</span>
<span class="sd">    :param volumeIntegralLimit: integral width as a multiple of lineWidth (FWHM)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># move to peakList</span>

    <span class="kn">from</span> <span class="nn">ccpn.core.Peak</span> <span class="kn">import</span> <span class="n">Peak</span>
    <span class="kn">from</span> <span class="nn">ccpn.framework.Application</span> <span class="kn">import</span> <span class="n">getApplication</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">getApplication</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">getApplication</span><span class="p">()</span><span class="o">.</span><span class="n">project</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;There is no project&#39;</span><span class="p">)</span>

    <span class="n">getByPid</span> <span class="o">=</span> <span class="n">getApplication</span><span class="p">()</span><span class="o">.</span><span class="n">project</span><span class="o">.</span><span class="n">getByPid</span>

    <span class="c1"># error checking - that the peaks are valid</span>
    <span class="n">peakList</span> <span class="o">=</span> <span class="n">makeIterableList</span><span class="p">(</span><span class="n">peaks</span><span class="p">)</span>
    <span class="n">pks</span> <span class="o">=</span> <span class="p">[</span><span class="n">getByPid</span><span class="p">(</span><span class="n">peak</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">peak</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">peak</span> <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">peakList</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">pp</span> <span class="ow">in</span> <span class="n">pks</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pp</span><span class="p">,</span> <span class="n">Peak</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> is not of type Peak&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">pp</span><span class="p">))</span>

    <span class="c1"># estimate the volume for each peak</span>
    <span class="k">for</span> <span class="n">pp</span> <span class="ow">in</span> <span class="n">pks</span><span class="p">:</span>
        <span class="n">height</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">height</span>
        <span class="n">lineWidths</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">lineWidths</span>
        <span class="k">if</span> <span class="n">lineWidths</span> <span class="ow">and</span> <span class="kc">None</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lineWidths</span> <span class="ow">and</span> <span class="n">height</span><span class="p">:</span>
            <span class="n">pp</span><span class="o">.</span><span class="n">estimateVolume</span><span class="p">(</span><span class="n">volumeIntegralLimit</span><span class="o">=</span><span class="n">volumeIntegralLimit</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">noWarning</span><span class="p">:</span>
            <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Peak </span><span class="si">%s</span><span class="s1"> contains undefined height/lineWidths&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">pp</span><span class="p">))</span></div>


<div class="viewcode-block" id="movePeak"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.peakUtils.movePeak">[docs]</a><span class="k">def</span> <span class="nf">movePeak</span><span class="p">(</span><span class="n">peak</span><span class="p">,</span> <span class="n">ppmPositions</span><span class="p">,</span> <span class="n">updateHeight</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Move a peak based on it&#39;s delta shift and optionally update to the height at the new position</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="n">undoBlockWithoutSideBar</span><span class="p">():</span>
        <span class="n">peak</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">ppmPositions</span>

        <span class="k">if</span> <span class="n">updateHeight</span><span class="p">:</span>
            <span class="c1"># get the interpolated height at this position</span>
            <span class="n">peak</span><span class="o">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">peak</span><span class="o">.</span><span class="n">peakList</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">getHeight</span><span class="p">(</span><span class="n">ppmPositions</span><span class="p">)</span></div>


<div class="viewcode-block" id="updateHeight"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.peakUtils.updateHeight">[docs]</a><span class="k">def</span> <span class="nf">updateHeight</span><span class="p">(</span><span class="n">peak</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">undoBlockWithoutSideBar</span><span class="p">():</span>
        <span class="n">peak</span><span class="o">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">peak</span><span class="o">.</span><span class="n">peakList</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">getHeight</span><span class="p">(</span><span class="n">peak</span><span class="o">.</span><span class="n">position</span><span class="p">)</span></div>


<span class="c1"># added for pipelines</span>


<span class="k">def</span> <span class="nf">_1Dregions</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">lim</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
    <span class="c1"># centre of position, peak position</span>
    <span class="c1"># lim in ppm where to look left and right</span>
    <span class="n">referenceRegion</span> <span class="o">=</span> <span class="p">[</span><span class="n">value</span> <span class="o">-</span> <span class="n">lim</span><span class="p">,</span> <span class="n">value</span> <span class="o">+</span> <span class="n">lim</span><span class="p">]</span>
    <span class="n">point1</span><span class="p">,</span> <span class="n">point2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">referenceRegion</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">referenceRegion</span><span class="p">)</span>
    <span class="n">x_filtered</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">point1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="n">point2</span><span class="p">))</span>  <span class="c1"># only the region of interest for the reference spectrum</span>
    <span class="n">y_filtered</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">x_filtered</span><span class="p">]</span>
    <span class="n">x_filtered</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">x_filtered</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">x_filtered</span><span class="p">,</span> <span class="n">y_filtered</span>


<span class="k">def</span> <span class="nf">_1DregionsFromLimits</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">limits</span><span class="p">):</span>
    <span class="c1"># centre of position, peak position</span>
    <span class="c1"># lim in ppm where to look left and right</span>

    <span class="n">point1</span><span class="p">,</span> <span class="n">point2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">limits</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">limits</span><span class="p">)</span>
    <span class="n">x_filtered</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">point1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="n">point2</span><span class="p">))</span>  <span class="c1"># only the region of interest for the reference spectrum</span>
    <span class="n">y_filtered</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">x_filtered</span><span class="p">]</span>
    <span class="n">x_filtered</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">x_filtered</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">x_filtered</span><span class="p">,</span> <span class="n">y_filtered</span>


<span class="k">def</span> <span class="nf">_snap1DPeaksToExtremaSimple</span><span class="p">(</span><span class="n">peaks</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mf">0.003</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">peaks</span><span class="p">:</span>  <span class="c1"># peaks can be from diff peakLists</span>
        <span class="k">if</span> <span class="n">peak</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">peak</span><span class="o">.</span><span class="n">peakList</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">positions</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">peak</span><span class="o">.</span><span class="n">peakList</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">intensities</span>
            <span class="n">x_filtered</span><span class="p">,</span> <span class="n">y_filtered</span> <span class="o">=</span> <span class="n">_1Dregions</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">peak</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">lim</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_filtered</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">y_filtered</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span>
                <span class="n">peakHeight</span> <span class="o">=</span> <span class="n">y_filtered</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                <span class="n">peakPos</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">x_filtered</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">idx</span><span class="p">]]</span>  <span class="c1"># ppm positions</span>
                <span class="n">peak</span><span class="o">.</span><span class="n">height</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">peakHeight</span><span class="p">)</span>
                <span class="n">peak</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">peakPos</span><span class="p">),</span> <span class="p">]</span>


<div class="viewcode-block" id="find_nearest"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.peakUtils.find_nearest">[docs]</a><span class="k">def</span> <span class="nf">find_nearest</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">array</span> <span class="o">-</span> <span class="n">value</span><span class="p">))</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">array</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span></div>


<div class="viewcode-block" id="snap1DPeaksToExtrema"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.peakUtils.snap1DPeaksToExtrema">[docs]</a><span class="k">def</span> <span class="nf">snap1DPeaksToExtrema</span><span class="p">(</span><span class="n">peaks</span><span class="p">,</span> <span class="n">maximumLimit</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">figOfMeritLimit</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">doNeg</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">undoBlockWithoutSideBar</span><span class="p">():</span>
        <span class="k">with</span> <span class="n">notificationEchoBlocking</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">peaks</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">peaks</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  <span class="c1"># reorder peaks by position</span>
                <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">peaks</span><span class="p">:</span>  <span class="c1"># peaks can be from diff peakLists</span>
                    <span class="k">if</span> <span class="n">peak</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">_snap1DPeakToClosestExtremum</span><span class="p">(</span><span class="n">peak</span><span class="p">,</span> <span class="n">maximumLimit</span><span class="o">=</span><span class="n">maximumLimit</span><span class="p">,</span>
                                                     <span class="n">figOfMeritLimit</span><span class="o">=</span><span class="n">figOfMeritLimit</span><span class="p">,</span>
                                                     <span class="n">doNeg</span><span class="o">=</span><span class="n">doNeg</span><span class="p">)</span></div>


<div class="viewcode-block" id="recalculatePeaksHeightAtPosition"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.peakUtils.recalculatePeaksHeightAtPosition">[docs]</a><span class="k">def</span> <span class="nf">recalculatePeaksHeightAtPosition</span><span class="p">(</span><span class="n">peaks</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">undoBlockWithoutSideBar</span><span class="p">():</span>
        <span class="k">with</span> <span class="n">notificationEchoBlocking</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">peaks</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">peaks</span><span class="p">:</span>  <span class="c1"># peaks can be from diff peakLists</span>
                    <span class="k">if</span> <span class="n">peak</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">height</span> <span class="o">=</span> <span class="n">peak</span><span class="o">.</span><span class="n">peakList</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">getHeight</span><span class="p">(</span><span class="n">peak</span><span class="o">.</span><span class="n">position</span><span class="p">)</span>
                        <span class="n">peak</span><span class="o">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">height</span></div>


<div class="viewcode-block" id="updatePeaksFigureOfMerits"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.peakUtils.updatePeaksFigureOfMerits">[docs]</a><span class="k">def</span> <span class="nf">updatePeaksFigureOfMerits</span><span class="p">(</span><span class="n">peaks</span><span class="p">,</span> <span class="n">newMerit</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Set the figure of merit to the given value if the peak height is below the Noise threshold &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="n">undoBlockWithoutSideBar</span><span class="p">():</span>
        <span class="k">with</span> <span class="n">notificationEchoBlocking</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">peaks</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">peaks</span><span class="p">:</span>  <span class="c1"># peaks can be from diff peakLists</span>
                    <span class="k">if</span> <span class="n">peak</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">noiseLevel</span> <span class="o">=</span> <span class="n">peak</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">noiseLevel</span> <span class="ow">or</span> <span class="n">peak</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">estimateNoise</span><span class="p">()</span>
                        <span class="k">if</span> <span class="n">peak</span><span class="o">.</span><span class="n">height</span> <span class="o">&lt;</span> <span class="n">noiseLevel</span><span class="p">:</span>
                            <span class="n">peak</span><span class="o">.</span><span class="n">figureOfMerit</span> <span class="o">=</span> <span class="n">newMerit</span></div>


<span class="k">def</span> <span class="nf">_fitBins</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">bins</span><span class="p">):</span>
    <span class="c1"># fit a gauss curve over the bins</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="n">fittedCurve</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">sigma</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">bins</span> <span class="o">-</span> <span class="n">mu</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">sigma</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">fittedCurve</span>


<span class="k">def</span> <span class="nf">_getBins</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">binCount</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :param y:</span>
<span class="sd">    :return:</span>
<span class="sd">    ### plot example:</span>
<span class="sd">    # import matplotlib.pyplot as plt  # to plot</span>
<span class="sd">    # plt.hist(y, bins=int(len(y)/2), density=True)</span>
<span class="sd">    # plt.plot(edges, fittedCurve, linewidth=2, color=&#39;r&#39;)</span>
<span class="sd">    # plt.show()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">binned_statistic</span>

    <span class="n">binCount</span> <span class="o">=</span> <span class="n">binCount</span> <span class="ow">or</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">statistics</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">binNumbers</span> <span class="o">=</span> <span class="n">binned_statistic</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">binCount</span><span class="p">,</span> <span class="n">statistic</span><span class="o">=</span><span class="s1">&#39;median&#39;</span><span class="p">)</span>
    <span class="n">mostCommonBinNumber</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">binNumbers</span><span class="p">))</span>
    <span class="n">highestValues</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">binNumbers</span> <span class="o">==</span> <span class="n">mostCommonBinNumber</span><span class="p">]</span>  <span class="c1"># values corresponding to most frequent binNumber</span>
    <span class="n">fittedCurve</span> <span class="o">=</span> <span class="n">_fitBins</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">edges</span><span class="p">)</span>
    <span class="n">fittedCurveExtremum</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">fittedCurve</span><span class="p">)]</span>  <span class="c1"># value at the Extremum of the fitted curve</span>
    <span class="k">return</span> <span class="n">statistics</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">binNumbers</span><span class="p">,</span> <span class="n">fittedCurve</span><span class="p">,</span> <span class="n">mostCommonBinNumber</span><span class="p">,</span> <span class="n">highestValues</span><span class="p">,</span> <span class="n">fittedCurveExtremum</span>


<div class="viewcode-block" id="snap1DPeaksAndRereferenceSpectrum"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.peakUtils.snap1DPeaksAndRereferenceSpectrum">[docs]</a><span class="k">def</span> <span class="nf">snap1DPeaksAndRereferenceSpectrum</span><span class="p">(</span><span class="n">peaks</span><span class="p">,</span> <span class="n">maximumLimit</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">useAdjacientPeaksAsLimits</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                      <span class="n">doNeg</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">figOfMeritLimit</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">spectrum</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">autoRereferenceSpectrum</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Snap all peaks to closest maxima</span>

<span class="sd">    Steps:</span>
<span class="sd">    - reorder the peaks by heights to give higher peaks priority to the snap</span>
<span class="sd">    - 1st iteration: search for nearest maxima and calculate delta positions (don&#39;t set peak.position here yet)</span>
<span class="sd">    - use deltas to fit patterns of shifts and detect the most probable global shift</span>
<span class="sd">    - use the global shift to re-reference the spectrum</span>
<span class="sd">    - 2nd iteration: re-search for nearest maxima</span>
<span class="sd">    - set newly detected position to peak if found better fits</span>
<span class="sd">    - re-set the spectrum referencing to original (if not requested as argument)</span>

<span class="sd">    :param peaks: list of peaks to snap</span>
<span class="sd">    :param maximumLimit: float to use as + left-right limits from peak position where to search new maxima</span>
<span class="sd">    :param useAdjacientPeaksAsLimits: bool. use adj peak position as left-right limits. don&#39;t search maxima after adjacent peaks</span>
<span class="sd">    :param doNeg: snap also negative peaks</span>
<span class="sd">    :param figOfMeritLimit: float. don&#39;t snap peaks with FOM below limit threshold</span>
<span class="sd">    :param spectrum: the spectum obj. optional if all peaks belong to the same spectrum</span>
<span class="sd">    :return:</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">peaks</span><span class="p">:</span>
        <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Cannot snap peaks. No peaks found&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">spectrum</span><span class="p">:</span>
        <span class="n">spectrum</span> <span class="o">=</span> <span class="n">peaks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">peakList</span><span class="o">.</span><span class="n">spectrum</span>

    <span class="c1"># - reorder the peaks by heights to give higher peaks priority to the snap</span>
    <span class="n">peaks</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">height</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># reorder peaks by height</span>
    <span class="n">oPositions</span><span class="p">,</span> <span class="n">oHeights</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">position</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">peaks</span><span class="p">],</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">height</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">peaks</span><span class="p">]</span>
    <span class="n">nPositions</span><span class="p">,</span> <span class="n">nHeights</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>

    <span class="c1"># - 1st iteration: search for nearest maxima and calculate deltas</span>
    <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">peaks</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">peak</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">position</span><span class="p">,</span> <span class="n">height</span> <span class="o">=</span> <span class="n">_get1DClosestExtremum</span><span class="p">(</span><span class="n">peak</span><span class="p">,</span> <span class="n">maximumLimit</span><span class="o">=</span><span class="n">maximumLimit</span><span class="p">,</span>
                                                     <span class="n">useAdjacientPeaksAsLimits</span><span class="o">=</span><span class="n">useAdjacientPeaksAsLimits</span><span class="p">,</span> <span class="n">doNeg</span><span class="o">=</span><span class="n">doNeg</span><span class="p">,</span>
                                                     <span class="n">figOfMeritLimit</span><span class="o">=</span><span class="n">figOfMeritLimit</span><span class="p">)</span>
            <span class="n">nPositions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">position</span><span class="p">)</span>
            <span class="n">nHeights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">height</span><span class="p">)</span>
    <span class="n">deltas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nPositions</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">oPositions</span><span class="p">)</span>
    <span class="n">deltas</span> <span class="o">=</span> <span class="n">deltas</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">peaks</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">peaks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">nPositions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">peaks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">nHeights</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">deltas</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># - use deltas to fit patterns of shifts and detect the most probable global shift</span>
    <span class="n">stats</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">binNumbers</span><span class="p">,</span> <span class="n">fittedCurve</span><span class="p">,</span> <span class="n">mostCommonBinNumber</span><span class="p">,</span> <span class="n">highestValues</span><span class="p">,</span> <span class="n">fittedCurveExtremum</span> <span class="o">=</span> <span class="n">_getBins</span><span class="p">(</span><span class="n">deltas</span><span class="p">)</span>
    <span class="n">shift</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">highestValues</span><span class="p">)</span>
    <span class="n">oReferenceValues</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">referenceValues</span>
    <span class="n">oPositions</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">positions</span>
    <span class="c1">#  - use the global shift to re-reference the spectrum</span>
    <span class="n">spectrum</span><span class="o">.</span><span class="n">referenceValues</span> <span class="o">=</span> <span class="p">[</span><span class="n">spectrum</span><span class="o">.</span><span class="n">referenceValues</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">shift</span><span class="p">]</span>
    <span class="n">spectrum</span><span class="o">.</span><span class="n">positions</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">positions</span> <span class="o">-</span> <span class="n">shift</span>

    <span class="c1">#  - 2nd iteration: re-search for nearest maxima</span>
    <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">peaks</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">peak</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">oPosition</span> <span class="o">=</span> <span class="n">peak</span><span class="o">.</span><span class="n">position</span>
            <span class="n">peak</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="p">[</span><span class="n">peak</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">shift</span><span class="p">,</span> <span class="p">]</span>  <span class="c1">#  - use the shift to re-reference the peak to the moved spectrum</span>
            <span class="n">position</span><span class="p">,</span> <span class="n">height</span> <span class="o">=</span> <span class="n">_get1DClosestExtremum</span><span class="p">(</span><span class="n">peak</span><span class="p">,</span> <span class="n">maximumLimit</span><span class="o">=</span><span class="n">maximumLimit</span><span class="p">,</span>
                                                     <span class="n">useAdjacientPeaksAsLimits</span><span class="o">=</span><span class="n">useAdjacientPeaksAsLimits</span><span class="p">,</span> <span class="n">doNeg</span><span class="o">=</span><span class="n">doNeg</span><span class="p">,</span>
                                                     <span class="n">figOfMeritLimit</span><span class="o">=</span><span class="n">figOfMeritLimit</span><span class="p">)</span>
            <span class="c1">#  - set newly detected position if found better fits</span>
            <span class="k">if</span> <span class="n">peak</span><span class="o">.</span><span class="n">position</span> <span class="o">==</span> <span class="n">position</span><span class="p">:</span>  <span class="c1"># Same position detected. Revert</span>
                <span class="n">peak</span><span class="o">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">peak</span><span class="o">.</span><span class="n">peakList</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">getHeight</span><span class="p">(</span><span class="n">oPosition</span><span class="p">)</span>
                <span class="n">peak</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">oPosition</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">peak</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">position</span>
                <span class="n">peak</span><span class="o">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">height</span>
    <span class="c1"># - re-set the spectrum referencing to original (if not requested as argument)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">autoRereferenceSpectrum</span><span class="p">:</span>
        <span class="n">spectrum</span><span class="o">.</span><span class="n">referenceValues</span> <span class="o">=</span> <span class="n">oReferenceValues</span>
        <span class="n">spectrum</span><span class="o">.</span><span class="n">positions</span> <span class="o">=</span> <span class="n">oPositions</span>

    <span class="c1"># check for missed maxima or peaks snapped to height@position but had other unpicked maxima close-by</span>
    <span class="k">return</span> <span class="n">shift</span></div>


<span class="k">def</span> <span class="nf">_add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span>


<span class="k">def</span> <span class="nf">_sub</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_sub</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_sub</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span>


<span class="k">def</span> <span class="nf">_getAdjacentPeakPositions1D</span><span class="p">(</span><span class="n">peak</span><span class="p">):</span>
    <span class="n">positions</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">peak</span><span class="o">.</span><span class="n">peakList</span><span class="o">.</span><span class="n">peaks</span><span class="p">]</span>
    <span class="n">positions</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="n">queryPos</span> <span class="o">=</span> <span class="n">peak</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">tot</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">positions</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">queryPos</span><span class="p">)</span>
    <span class="n">previous</span><span class="p">,</span> <span class="nb">next</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span>
    <span class="n">previousPeakPosition</span><span class="p">,</span> <span class="n">nextPeakPosition</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">previous</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="n">tot</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
        <span class="nb">next</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">previous</span><span class="p">:</span>
        <span class="n">previousPeakPosition</span> <span class="o">=</span> <span class="n">positions</span><span class="p">[</span><span class="n">positions</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">queryPos</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">next</span><span class="p">:</span>
        <span class="n">nextPeakPosition</span> <span class="o">=</span> <span class="n">positions</span><span class="p">[</span><span class="n">positions</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">queryPos</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">previousPeakPosition</span><span class="p">,</span> <span class="n">nextPeakPosition</span>


<span class="k">def</span> <span class="nf">_correctNegativeHeight</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">doNeg</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;return height either Positive or Negative value if doNEg=True. If height is negative and doNeg=False:</span>
<span class="sd">    return the smallest positive number (non-zero) like 4.9e-324.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">height</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">doNeg</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nextafter</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">height</span>


<span class="k">def</span> <span class="nf">_get1DClosestExtremum</span><span class="p">(</span><span class="n">peak</span><span class="p">,</span> <span class="n">maximumLimit</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">useAdjacientPeaksAsLimits</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">doNeg</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                          <span class="n">figOfMeritLimit</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :param peak:</span>
<span class="sd">    :param maximumLimit: don&#39;t snap peaks over this threshold in ppm</span>
<span class="sd">    :param useAdjacientPeaksAsLimits: stop a peak to go over pre-existing peaks (to the left/right)</span>
<span class="sd">    :param doNeg: include negative peaks as solutions</span>
<span class="sd">    :param figOfMeritLimit: skip if below this threshold and give only height at position</span>
<span class="sd">    :return: position, height : position is a list of length 1,  height is a float</span>

<span class="sd">    search  maxima close to a given peak based on the maximumLimit (left/right) or using the adjacent peaks position as limits.</span>
<span class="sd">     return the nearest coordinates position, height</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">ccpn.core.lib.SpectrumLib</span> <span class="kn">import</span> <span class="n">estimateNoiseLevel1D</span>
    <span class="kn">from</span> <span class="nn">ccpn.core.lib.PeakPickers.PeakPicker1D</span> <span class="kn">import</span> <span class="n">_find1DMaxima</span>

    <span class="n">spectrum</span> <span class="o">=</span> <span class="n">peak</span><span class="o">.</span><span class="n">peakList</span><span class="o">.</span><span class="n">spectrum</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">positions</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">intensities</span>
    <span class="n">position</span><span class="p">,</span> <span class="n">height</span> <span class="o">=</span> <span class="n">peak</span><span class="o">.</span><span class="n">position</span><span class="p">,</span> <span class="n">peak</span><span class="o">.</span><span class="n">height</span>
    <span class="k">if</span> <span class="n">peak</span><span class="o">.</span><span class="n">figureOfMerit</span> <span class="o">&lt;</span> <span class="n">figOfMeritLimit</span><span class="p">:</span>
        <span class="n">height</span> <span class="o">=</span> <span class="n">peak</span><span class="o">.</span><span class="n">peakList</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">getHeight</span><span class="p">(</span><span class="n">peak</span><span class="o">.</span><span class="n">position</span><span class="p">)</span>
        <span class="n">height</span> <span class="o">=</span> <span class="n">_correctNegativeHeight</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">doNeg</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">position</span><span class="p">,</span> <span class="n">height</span>

    <span class="k">if</span> <span class="n">useAdjacientPeaksAsLimits</span><span class="p">:</span>  <span class="c1">#  a left # b right limit</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_getAdjacentPeakPositions1D</span><span class="p">(</span><span class="n">peak</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">a</span><span class="p">:</span>  <span class="c1"># could not find adjacient peaks if the snapping peak is the first or last</span>
            <span class="k">if</span> <span class="n">peak</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1">#it&#39;s positive</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">peak</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">maximumLimit</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">peak</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">maximumLimit</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">b</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">peak</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># it&#39;s positive</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">peak</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">maximumLimit</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">peak</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">maximumLimit</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">peak</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">maximumLimit</span><span class="p">,</span> <span class="n">peak</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">maximumLimit</span>

    <span class="c1"># refind maxima</span>
    <span class="n">noiseLevel</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">noiseLevel</span>
    <span class="n">negativeNoiseLevel</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">negativeNoiseLevel</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">noiseLevel</span><span class="p">:</span>  <span class="c1"># estimate as you can from the spectrum</span>
        <span class="n">spectrum</span><span class="o">.</span><span class="n">noiseLevel</span><span class="p">,</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">negativeNoiseLevel</span> <span class="o">=</span> <span class="n">noiseLevel</span><span class="p">,</span> <span class="n">negativeNoiseLevel</span> <span class="o">=</span> <span class="n">estimateNoiseLevel1D</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">negativeNoiseLevel</span><span class="p">:</span>
        <span class="n">noiseLevel</span><span class="p">,</span> <span class="n">negativeNoiseLevel</span> <span class="o">=</span> <span class="n">estimateNoiseLevel1D</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">spectrum</span><span class="o">.</span><span class="n">negativeNoiseLevel</span> <span class="o">=</span> <span class="n">negativeNoiseLevel</span>

    <span class="n">x_filtered</span><span class="p">,</span> <span class="n">y_filtered</span> <span class="o">=</span> <span class="n">_1DregionsFromLimits</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">])</span>

    <span class="n">maxValues</span><span class="p">,</span> <span class="n">minValues</span> <span class="o">=</span> <span class="n">_find1DMaxima</span><span class="p">(</span><span class="n">y_filtered</span><span class="p">,</span> <span class="n">x_filtered</span><span class="p">,</span> <span class="n">positiveThreshold</span><span class="o">=</span><span class="n">noiseLevel</span><span class="p">,</span> <span class="n">negativeThreshold</span><span class="o">=</span><span class="n">negativeNoiseLevel</span><span class="p">,</span> <span class="n">findNegative</span><span class="o">=</span><span class="n">doNeg</span><span class="p">)</span>
    <span class="n">allValues</span> <span class="o">=</span> <span class="n">maxValues</span> <span class="o">+</span> <span class="n">minValues</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">allValues</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">allValues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">allValues</span><span class="p">)</span>
        <span class="n">positions</span> <span class="o">=</span> <span class="n">allValues</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">heights</span> <span class="o">=</span> <span class="n">allValues</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">nearestPosition</span> <span class="o">=</span> <span class="n">find_nearest</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span> <span class="n">peak</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">nearestHeight</span> <span class="o">=</span> <span class="n">heights</span><span class="p">[</span><span class="n">positions</span> <span class="o">==</span> <span class="n">nearestPosition</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">useAdjacientPeaksAsLimits</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="n">nearestPosition</span> <span class="ow">or</span> <span class="n">b</span> <span class="o">==</span> <span class="n">nearestPosition</span><span class="p">:</span>  <span class="c1"># avoid snapping to an existing peak, as it might be a wrong snap.</span>
                <span class="n">height</span> <span class="o">=</span> <span class="n">peak</span><span class="o">.</span><span class="n">peakList</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">getHeight</span><span class="p">(</span><span class="n">peak</span><span class="o">.</span><span class="n">position</span><span class="p">)</span>
            <span class="c1"># elif abs(nearestPosition) &gt; abs(peak.position[0] + maximumLimit):  # avoid snapping on the noise if not maximum found</span>
            <span class="c1"># peak.height = peak.peakList.spectrum.getHeight(peak.position)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">position</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">nearestPosition</span><span class="p">),</span> <span class="p">]</span>
                <span class="n">height</span> <span class="o">=</span> <span class="n">nearestHeight</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_getAdjacentPeakPositions1D</span><span class="p">(</span><span class="n">peak</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">float</span><span class="p">(</span><span class="n">nearestPosition</span><span class="p">)</span> <span class="ow">in</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>  <span class="c1"># avoid snapping to an existing peak,</span>
                <span class="n">height</span> <span class="o">=</span> <span class="n">peak</span><span class="o">.</span><span class="n">peakList</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">getHeight</span><span class="p">(</span><span class="n">peak</span><span class="o">.</span><span class="n">position</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">position</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">nearestPosition</span><span class="p">),</span> <span class="p">]</span>
                <span class="n">height</span> <span class="o">=</span> <span class="n">nearestHeight</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">height</span> <span class="o">=</span> <span class="n">peak</span><span class="o">.</span><span class="n">peakList</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">getHeight</span><span class="p">(</span><span class="n">peak</span><span class="o">.</span><span class="n">position</span><span class="p">)</span>

    <span class="n">height</span> <span class="o">=</span> <span class="n">_correctNegativeHeight</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">doNeg</span><span class="p">)</span>  <span class="c1"># Very important. don&#39;t return a negative height if doNeg is False.</span>
    <span class="k">return</span> <span class="n">position</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">height</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_snap1DPeakToClosestExtremum</span><span class="p">(</span><span class="n">peak</span><span class="p">,</span> <span class="n">maximumLimit</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">doNeg</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">figOfMeritLimit</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    It snaps a peak to its closest extremum, that can be considered as a peak.</span>
<span class="sd">    it uses adjacent peak positions as boundaries. However if no adjacent peaks then uses the maximumlimits.</span>
<span class="sd">    Uses peak</span>
<span class="sd">    :param peak: obj peak</span>
<span class="sd">    :param maximumLimit: maximum tolerance left or right from the peak position (ppm)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">position</span><span class="p">,</span> <span class="n">height</span> <span class="o">=</span> <span class="n">_get1DClosestExtremum</span><span class="p">(</span><span class="n">peak</span><span class="p">,</span> <span class="n">maximumLimit</span><span class="p">,</span> <span class="n">doNeg</span><span class="o">=</span><span class="n">doNeg</span><span class="p">,</span> <span class="n">figOfMeritLimit</span><span class="o">=</span><span class="n">figOfMeritLimit</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">undoBlockWithoutSideBar</span><span class="p">():</span>
        <span class="k">with</span> <span class="n">notificationEchoBlocking</span><span class="p">():</span>
            <span class="n">peak</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">position</span>
            <span class="n">peak</span><span class="o">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">height</span>


<div class="viewcode-block" id="getSpectralPeakHeights"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.peakUtils.getSpectralPeakHeights">[docs]</a><span class="k">def</span> <span class="nf">getSpectralPeakHeights</span><span class="p">(</span><span class="n">spectra</span><span class="p">,</span> <span class="n">peakListIndexes</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">_getSpectralPeakPropertyAsDataFrame</span><span class="p">(</span><span class="n">spectra</span><span class="p">,</span> <span class="n">peakProperty</span><span class="o">=</span><span class="n">HEIGHT</span><span class="p">,</span> <span class="n">peakListIndexes</span><span class="o">=</span><span class="n">peakListIndexes</span><span class="p">)</span></div>


<div class="viewcode-block" id="getSpectralPeakVolumes"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.peakUtils.getSpectralPeakVolumes">[docs]</a><span class="k">def</span> <span class="nf">getSpectralPeakVolumes</span><span class="p">(</span><span class="n">spectra</span><span class="p">,</span> <span class="n">peakListIndexes</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">_getSpectralPeakPropertyAsDataFrame</span><span class="p">(</span><span class="n">spectra</span><span class="p">,</span> <span class="n">peakProperty</span><span class="o">=</span><span class="n">VOLUME</span><span class="p">,</span> <span class="n">peakListIndexes</span><span class="o">=</span><span class="n">peakListIndexes</span><span class="p">)</span></div>


<div class="viewcode-block" id="getSpectralPeakHeightForNmrResidue"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.peakUtils.getSpectralPeakHeightForNmrResidue">[docs]</a><span class="k">def</span> <span class="nf">getSpectralPeakHeightForNmrResidue</span><span class="p">(</span><span class="n">spectra</span><span class="p">,</span> <span class="n">peakListIndexes</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    return: Pandas DataFrame with the following structure:</span>
<span class="sd">            Index:  ID for the nmrResidue(s) assigned to the peak ;</span>
<span class="sd">            Columns =&gt; Spectrum series values sorted by ascending values, if series values are not set, then the</span>
<span class="sd">                       spectrum name is used instead.</span>

<span class="sd">                   |   SP1     |    SP2    |   SP3</span>
<span class="sd">        NR_ID      |           |           |</span>
<span class="sd">       ------------+-----------+-----------+----------</span>
<span class="sd">        A.1.ARG    |    10     |  100      | 1000</span>

<span class="sd">        &quot;&quot;&quot;</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">getSpectralPeakHeights</span><span class="p">(</span><span class="n">spectra</span><span class="p">,</span> <span class="n">peakListIndexes</span><span class="p">)</span>
    <span class="n">newDf</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="n">NR_ID</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">]</span>  <span class="c1"># remove rows if NR_ID is not defined</span>
    <span class="n">newDf</span> <span class="o">=</span> <span class="n">newDf</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">NR_ID</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">newDf</span></div>


<div class="viewcode-block" id="getSpectralPeakVolumeForNmrResidue"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.peakUtils.getSpectralPeakVolumeForNmrResidue">[docs]</a><span class="k">def</span> <span class="nf">getSpectralPeakVolumeForNmrResidue</span><span class="p">(</span><span class="n">spectra</span><span class="p">,</span> <span class="n">peakListIndexes</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    return: Pandas DataFrame with the following structure:</span>
<span class="sd">            Index:  ID for the nmrResidue(s) assigned to the peak ;</span>
<span class="sd">            Columns =&gt; Spectrum series values sorted by ascending values, if series values are not set, then the</span>
<span class="sd">                       spectrum name is used instead.</span>

<span class="sd">                   |   SP1     |    SP2    |   SP3</span>
<span class="sd">        NR_ID      |           |           |</span>
<span class="sd">       ------------+-----------+-----------+----------</span>
<span class="sd">        A.1.ARG    |    10     |  100      | 1000</span>

<span class="sd">        &quot;&quot;&quot;</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">getSpectralPeakVolumes</span><span class="p">(</span><span class="n">spectra</span><span class="p">,</span> <span class="n">peakListIndexes</span><span class="p">)</span>
    <span class="n">newDf</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="n">NR_ID</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">]</span>  <span class="c1"># remove rows if NR_ID is not defined</span>
    <span class="n">newDf</span> <span class="o">=</span> <span class="n">newDf</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">NR_ID</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">newDf</span></div>


<span class="k">def</span> <span class="nf">_getSpectralPeakPropertyAsDataFrame</span><span class="p">(</span><span class="n">spectra</span><span class="p">,</span> <span class="n">peakProperty</span><span class="o">=</span><span class="n">HEIGHT</span><span class="p">,</span> <span class="n">NR_ID</span><span class="o">=</span><span class="n">NR_ID</span><span class="p">,</span> <span class="n">peakListIndexes</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :param spectra: list of spectra</span>
<span class="sd">    :param peakProperty: &#39;height&#39;or&#39;volume&#39;</span>
<span class="sd">    :param NR_ID: columnName for the NmrResidue ID</span>
<span class="sd">    :param peakListIndex: list of peakList indexes for getting the right peakList from the given spectra,</span>
<span class="sd">                         default: the last peakList available</span>
<span class="sd">    :return: Pandas DataFrame with the following structure:</span>
<span class="sd">            Index: multiIndex =&gt; axisCodes as levels;</span>
<span class="sd">            Columns =&gt; NR_ID: the nmrResidue(s) assigned for the peak if available</span>
<span class="sd">                       Spectrum series values sorted by ascending values, if series values are not set, then the</span>
<span class="sd">                       spectrum name is used instead.</span>

<span class="sd">                    |  NR_ID  |   SP1     |    SP2    |   SP3</span>
<span class="sd">        H     N     |         |           |           |</span>
<span class="sd">       -------------+-------- +-----------+-----------+---------</span>
<span class="sd">        7.5  104.3  | A.1.ARG |    10    |  100       | 1000</span>

<span class="sd">    to sort the dataframe by an axisCode, eg &#39;H&#39; use:</span>
<span class="sd">    df = df.sort_index(level=&#39;H&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dfs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">peakListIndexes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">peakListIndexes</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">spectra</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">spectrum</span><span class="p">,</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">spectra</span><span class="p">,</span> <span class="n">peakListIndexes</span><span class="p">):</span>
        <span class="n">positions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">nmrResidues</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">serieValue</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">name</span>  <span class="c1"># use spectrumName as default. if series defined use that instead.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spectrum</span><span class="o">.</span><span class="n">spectrumGroups</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">sGserieValue</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">_getSeriesItem</span><span class="p">(</span><span class="n">spectrum</span><span class="o">.</span><span class="n">spectrumGroups</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">sGserieValue</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">serieValue</span> <span class="o">=</span> <span class="n">sGserieValue</span>
        <span class="n">peaks</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">peakLists</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">peaks</span>
        <span class="n">peaks</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">position</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">peaks</span><span class="p">:</span>
            <span class="n">positions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">peak</span><span class="o">.</span><span class="n">position</span><span class="p">)</span>
            <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">peak</span><span class="p">,</span> <span class="n">peakProperty</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
            <span class="n">assignedResidues</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">nmrResidue</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
                                                         <span class="n">makeIterableList</span><span class="p">(</span><span class="n">peak</span><span class="o">.</span><span class="n">assignments</span><span class="p">)))))</span>
            <span class="n">nmrResidues</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">assignedResidues</span><span class="p">))</span>
        <span class="n">_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="n">serieValue</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="n">m_ix</span><span class="o">.</span><span class="n">from_tuples</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">spectrum</span><span class="o">.</span><span class="n">axisCodes</span><span class="p">))</span>
        <span class="n">_df</span><span class="p">[</span><span class="n">NR_ID</span><span class="p">]</span> <span class="o">=</span> <span class="n">nmrResidues</span>
        <span class="n">_df</span> <span class="o">=</span> <span class="n">_df</span><span class="p">[</span><span class="o">~</span><span class="n">_df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">duplicated</span><span class="p">()]</span>
        <span class="n">dfs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_df</span><span class="p">)</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">dfs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="n">NR_ID</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span> <span class="o">==</span> <span class="n">NR_ID</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">x</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">notnull</span><span class="p">()]])))</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="o">~</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">duplicated</span><span class="p">()]</span>
    <span class="n">cols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
    <span class="n">resColumn</span> <span class="o">=</span> <span class="n">cols</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">cols</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">NR_ID</span><span class="p">))</span>
    <span class="n">sortedCols</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">cols</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">sortedCols</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">resColumn</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span><span class="p">[</span><span class="n">sortedCols</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_getPeakSNRatio</span><span class="p">(</span><span class="n">peak</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mf">2.5</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Estimate the Signal to Noise ratio based on the spectrum Positive and Negative noise values.</span>
<span class="sd">    If Noise thresholds are not defined in the spectrum, then they are estimated as well.</span>
<span class="sd">    If only the positive noise threshold is defined, the negative noise threshold will be the inverse of the positive.</span>
<span class="sd">        SNratio = |factor*(height/|NoiseMax-NoiseMin|)|</span>
<span class="sd">                height is the peak height</span>
<span class="sd">                NoiseMax is the spectrum positive noise threshold</span>
<span class="sd">                NoiseMin is the spectrum negative noise threshold</span>
<span class="sd">    :param factor: float, multiplication factor.</span>
<span class="sd">    :return: float, SignalToNoise Ratio value for the peak</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">spectrum</span> <span class="o">=</span> <span class="n">peak</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">spectrum</span>
    <span class="kn">from</span> <span class="nn">ccpn.core.lib.SpectrumLib</span> <span class="kn">import</span> <span class="n">estimateNoiseLevel1D</span>
    <span class="kn">from</span> <span class="nn">ccpn.core.lib.SpectrumLib</span> <span class="kn">import</span> <span class="n">estimateSNR</span>

    <span class="n">noiseLevel</span><span class="p">,</span> <span class="n">negativeNoiseLevel</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">noiseLevel</span><span class="p">,</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">negativeNoiseLevel</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">negativeNoiseLevel</span> <span class="ow">and</span> <span class="n">noiseLevel</span><span class="p">:</span>
        <span class="n">negativeNoiseLevel</span> <span class="o">=</span> <span class="o">-</span> <span class="n">noiseLevel</span> <span class="k">if</span> <span class="n">noiseLevel</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">noiseLevel</span> <span class="o">*</span> <span class="mi">2</span>
        <span class="n">spectrum</span><span class="o">.</span><span class="n">negativeNoiseLevel</span> <span class="o">=</span> <span class="n">negativeNoiseLevel</span>
        <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Spectrum Negative noise not defined for </span><span class="si">%s</span><span class="s1">. Estimated default&#39;</span> <span class="o">%</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">pid</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">noiseLevel</span><span class="p">:</span>  <span class="c1"># estimate it</span>
        <span class="n">noiseLevel</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">estimateNoise</span><span class="p">()</span>
        <span class="n">negativeNoiseLevel</span> <span class="o">=</span> <span class="o">-</span><span class="n">noiseLevel</span>
        <span class="n">spectrum</span><span class="o">.</span><span class="n">noiseLevel</span><span class="p">,</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">negativeNoiseLevel</span> <span class="o">=</span> <span class="n">noiseLevel</span><span class="p">,</span> <span class="n">negativeNoiseLevel</span>
        <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Spectrum noise level(s) not defined for </span><span class="si">%s</span><span class="s1">. Estimated default&#39;</span> <span class="o">%</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">pid</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">peak</span><span class="o">.</span><span class="n">height</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">updateHeight</span><span class="p">(</span><span class="n">peak</span><span class="p">)</span>
        <span class="n">_getPeakSNRatio</span><span class="p">(</span><span class="n">peak</span><span class="p">)</span>
    <span class="n">snr</span> <span class="o">=</span> <span class="n">estimateSNR</span><span class="p">(</span><span class="n">noiseLevels</span><span class="o">=</span><span class="p">[</span><span class="n">noiseLevel</span><span class="p">,</span> <span class="n">negativeNoiseLevel</span><span class="p">],</span> <span class="n">signalPoints</span><span class="o">=</span><span class="p">[</span><span class="n">peak</span><span class="o">.</span><span class="n">height</span><span class="p">],</span> <span class="n">factor</span><span class="o">=</span><span class="n">factor</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">snr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1">## estimateSNR return a list with a lenght always &gt; 0</span>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">Python  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">ccpn.core.lib.peakUtils</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright .
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.4.0.
    </div>
  </body>
</html>