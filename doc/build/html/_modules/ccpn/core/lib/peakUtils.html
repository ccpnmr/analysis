<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>ccpn.core.lib.peakUtils &mdash; Python  documentation</title>
    
    <link rel="stylesheet" href="../../../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <link rel="top" title="Python  documentation" href="../../../../index.html" />
    <link rel="up" title="Module code" href="../../../index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">Python  documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for ccpn.core.lib.peakUtils</h1><div class="highlight"><pre>
<span></span><span class="c1">#=========================================================================================</span>
<span class="c1"># Licence, Reference and Credits</span>
<span class="c1">#=========================================================================================</span>
<span class="n">__copyright__</span> <span class="o">=</span> <span class="s2">&quot;Copyright (C) CCPN project (http://www.ccpn.ac.uk) 2014 - 2019&quot;</span>
<span class="n">__credits__</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Ed Brooksbank, Luca Mureddu, Timothy J Ragan &amp; Geerten W Vuister&quot;</span><span class="p">)</span>
<span class="n">__licence__</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;CCPN licence. See http://www.ccpn.ac.uk/v3-software/downloads/license&quot;</span><span class="p">)</span>
<span class="n">__reference__</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Skinner, S.P., Fogh, R.H., Boucher, W., Ragan, T.J., Mureddu, L.G., &amp; Vuister, G.W.&quot;</span><span class="p">,</span>
                 <span class="s2">&quot;CcpNmr AnalysisAssign: a flexible platform for integrated NMR analysis&quot;</span><span class="p">,</span>
                 <span class="s2">&quot;J.Biomol.Nmr (2016), 66, 111-124, http://doi.org/10.1007/s10858-016-0060-y&quot;</span><span class="p">)</span>
<span class="c1">#=========================================================================================</span>
<span class="c1"># Last code modification</span>
<span class="c1">#=========================================================================================</span>
<span class="n">__modifiedBy__</span> <span class="o">=</span> <span class="s2">&quot;$modifiedBy: CCPN $&quot;</span>
<span class="n">__dateModified__</span> <span class="o">=</span> <span class="s2">&quot;$dateModified: 2017-07-07 16:32:32 +0100 (Fri, July 07, 2017) $&quot;</span>
<span class="n">__version__</span> <span class="o">=</span> <span class="s2">&quot;$Revision: 3.0.0 $&quot;</span>
<span class="c1">#=========================================================================================</span>
<span class="c1"># Created</span>
<span class="c1">#=========================================================================================</span>
<span class="n">__author__</span> <span class="o">=</span> <span class="s2">&quot;$Author: CCPN $&quot;</span>
<span class="n">__date__</span> <span class="o">=</span> <span class="s2">&quot;$Date: 2017-04-07 10:28:41 +0000 (Fri, April 07, 2017) $&quot;</span>
<span class="c1">#=========================================================================================</span>
<span class="c1"># Start of code</span>
<span class="c1">#=========================================================================================</span>

<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Union</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">ccpn.util.Logging</span> <span class="kn">import</span> <span class="n">getLogger</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">curve_fit</span>
<span class="kn">from</span> <span class="nn">ccpn.core.PeakList</span> <span class="kn">import</span> <span class="n">GAUSSIANMETHOD</span><span class="p">,</span> <span class="n">PARABOLICMETHOD</span>
<span class="kn">from</span> <span class="nn">ccpn.util.Common</span> <span class="kn">import</span> <span class="n">makeIterableList</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="kn">as</span> <span class="nn">pd</span>

<span class="n">POSITIONS</span> <span class="o">=</span> <span class="s1">&#39;positions&#39;</span>
<span class="n">HEIGHT</span> <span class="o">=</span> <span class="s1">&#39;height&#39;</span>
<span class="n">VOLUME</span> <span class="o">=</span> <span class="s1">&#39;volume&#39;</span>
<span class="n">LINEWIDTHS</span> <span class="o">=</span> <span class="s1">&#39;lineWidths&#39;</span>
<span class="n">RAW</span> <span class="o">=</span> <span class="s1">&#39;raw&#39;</span>
<span class="n">DELTAS</span> <span class="o">=</span> <span class="s1">&#39;deltas&#39;</span>
<span class="n">DELTA</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\u0394</span><span class="s1">&#39;</span>
<span class="n">Delta</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\u03B4</span><span class="s1">&#39;</span>
<span class="n">MODES</span> <span class="o">=</span> <span class="p">[</span><span class="n">POSITIONS</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">VOLUME</span><span class="p">,</span> <span class="n">LINEWIDTHS</span><span class="p">]</span>
<span class="n">DISPLAYDATA</span> <span class="o">=</span> <span class="p">[</span><span class="n">DELTA</span> <span class="o">+</span> <span class="n">Delta</span><span class="p">,</span> <span class="n">RAW</span><span class="p">]</span>
<span class="n">OTHER</span> <span class="o">=</span> <span class="s1">&#39;Other&#39;</span>
<span class="n">H</span> <span class="o">=</span> <span class="s1">&#39;H&#39;</span>
<span class="n">N</span> <span class="o">=</span> <span class="s1">&#39;N&#39;</span>
<span class="n">C</span> <span class="o">=</span> <span class="s1">&#39;C&#39;</span>
<span class="n">DefaultAtomWeights</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(((</span><span class="n">H</span><span class="p">,</span> <span class="mf">7.00</span><span class="p">),</span> <span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mf">1.00</span><span class="p">),</span> <span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="mf">4.00</span><span class="p">),</span> <span class="p">(</span><span class="n">OTHER</span><span class="p">,</span> <span class="mf">1.00</span><span class="p">)))</span>


<div class="viewcode-block" id="Dictlist"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.peakUtils.Dictlist">[docs]</a><span class="k">class</span> <span class="nc">Dictlist</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">Dictlist</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__setitem__</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">[])</span>
        <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span></div>


<div class="viewcode-block" id="getMultipletPosition"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.peakUtils.getMultipletPosition">[docs]</a><span class="k">def</span> <span class="nf">getMultipletPosition</span><span class="p">(</span><span class="n">multiplet</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;ppm&#39;</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># skip if the position is None, otherwise check for dimensions</span>
        <span class="k">if</span> <span class="n">multiplet</span><span class="o">.</span><span class="n">position</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">multiplet</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">None</span>  <span class="c1">#&quot;*NOT SET*&quot;</span>

        <span class="k">elif</span> <span class="n">unit</span> <span class="o">==</span> <span class="s1">&#39;ppm&#39;</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">multiplet</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>

        <span class="c1">#  NOT implemented for multiplets</span>
        <span class="c1"># elif unit == &#39;point&#39;:</span>
        <span class="c1">#   value = multiplet.pointPosition[dim]</span>

        <span class="k">elif</span> <span class="n">unit</span> <span class="o">==</span> <span class="s1">&#39;Hz&#39;</span><span class="p">:</span>
            <span class="c1"># value = peak.position[dim]*peak._apiPeak.sortedPeakDims()[dim].dataDimRef.expDimRef.sf</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">multiplet</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">*</span> <span class="n">multiplet</span><span class="o">.</span><span class="n">multipletList</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">spectrometerFrequencies</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>  <span class="c1"># sampled</span>
            <span class="c1"># value = unit.pointValues[int(peak._apiPeak.sortedPeakDims()[dim].position)-1]</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unit passed to getPeakPosition must be &#39;ppm&#39;, &#39;point&#39;, or &#39;Hz&#39;, was </span><span class="si">%s</span><span class="s2">&quot;</span>
                             <span class="o">%</span> <span class="n">unit</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">value</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)):</span>
            <span class="k">return</span> <span class="s1">&#39;{0:.2f}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Error on setting Position. </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">e</span><span class="p">)</span></div>


<span class="c1"># return None</span>

<div class="viewcode-block" id="getMultipletLinewidth"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.peakUtils.getMultipletLinewidth">[docs]</a><span class="k">def</span> <span class="nf">getMultipletLinewidth</span><span class="p">(</span><span class="n">peak</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">dim</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">peak</span><span class="o">.</span><span class="n">lineWidths</span><span class="p">):</span>
        <span class="n">lw</span> <span class="o">=</span> <span class="n">peak</span><span class="o">.</span><span class="n">lineWidths</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">lw</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">lw</span><span class="p">)</span></div>


<div class="viewcode-block" id="getPeakPosition"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.peakUtils.getPeakPosition">[docs]</a><span class="k">def</span> <span class="nf">getPeakPosition</span><span class="p">(</span><span class="n">peak</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;ppm&#39;</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">peak</span><span class="o">.</span><span class="n">dimensionNmrAtoms</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">dim</span><span class="p">:</span>
        <span class="c1"># peakDim = peak.position[dim]</span>

        <span class="k">if</span> <span class="n">peak</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">None</span>  <span class="c1">#&quot;*NOT SET*&quot;</span>

        <span class="k">elif</span> <span class="n">unit</span> <span class="o">==</span> <span class="s1">&#39;ppm&#39;</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">peak</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>

        <span class="k">elif</span> <span class="n">unit</span> <span class="o">==</span> <span class="s1">&#39;point&#39;</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">peak</span><span class="o">.</span><span class="n">pointPosition</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>

        <span class="k">elif</span> <span class="n">unit</span> <span class="o">==</span> <span class="s1">&#39;Hz&#39;</span><span class="p">:</span>
            <span class="c1"># value = peak.position[dim]*peak._apiPeak.sortedPeakDims()[dim].dataDimRef.expDimRef.sf</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">peak</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">*</span> <span class="n">peak</span><span class="o">.</span><span class="n">peakList</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">spectrometerFrequencies</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>  <span class="c1"># sampled</span>
            <span class="c1"># value = unit.pointValues[int(peak._apiPeak.sortedPeakDims()[dim].position)-1]</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unit passed to getPeakPosition must be &#39;ppm&#39;, &#39;point&#39;, or &#39;Hz&#39;, was </span><span class="si">%s</span><span class="s2">&quot;</span>
                             <span class="o">%</span> <span class="n">unit</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)):</span>
            <span class="k">return</span> <span class="s1">&#39;{0:.2f}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">None</span></div>

        <span class="c1"># if isinstance(value, [int, float]):</span>
        <span class="c1"># # if type(value) is int or type(value) in (float, float32, float64):</span>
        <span class="c1">#   return &#39;%7.2f&#39; % float(value)</span>


<div class="viewcode-block" id="getPeakAnnotation"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.peakUtils.getPeakAnnotation">[docs]</a><span class="k">def</span> <span class="nf">getPeakAnnotation</span><span class="p">(</span><span class="n">peak</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">separator</span><span class="o">=</span><span class="s1">&#39;, &#39;</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">peak</span><span class="o">.</span><span class="n">dimensionNmrAtoms</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">dim</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">separator</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">dna</span><span class="o">.</span><span class="n">pid</span><span class="o">.</span><span class="n">id</span> <span class="k">for</span> <span class="n">dna</span> <span class="ow">in</span> <span class="n">peak</span><span class="o">.</span><span class="n">dimensionNmrAtoms</span><span class="p">[</span><span class="n">dim</span><span class="p">]])</span></div>


<div class="viewcode-block" id="getPeakLinewidth"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.peakUtils.getPeakLinewidth">[docs]</a><span class="k">def</span> <span class="nf">getPeakLinewidth</span><span class="p">(</span><span class="n">peak</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the lineWidth in dimension &#39;dim&#39; for the peakTable entries</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lineWidths</span> <span class="o">=</span> <span class="n">peak</span><span class="o">.</span><span class="n">lineWidths</span>
    <span class="k">if</span> <span class="n">lineWidths</span> <span class="ow">and</span> <span class="n">dim</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">lineWidths</span><span class="p">):</span>
        <span class="n">lw</span> <span class="o">=</span> <span class="n">peak</span><span class="o">.</span><span class="n">lineWidths</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">lw</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">lw</span><span class="p">)</span>

    <span class="c1"># need to return this as a string otherwise the table changes between &#39;None&#39; and &#39;nan&#39;</span>
    <span class="k">return</span> <span class="s1">&#39;None&#39;</span></div>

<span class="k">def</span> <span class="nf">_get1DPeaksPosAndHeightAsArray</span><span class="p">(</span><span class="n">peakList</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

    <span class="n">positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">peak</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">peakList</span><span class="o">.</span><span class="n">peaks</span><span class="p">])</span>
    <span class="n">heights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">peak</span><span class="o">.</span><span class="n">height</span> <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">peakList</span><span class="o">.</span><span class="n">peaks</span><span class="p">])</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">positions</span><span class="p">,</span> <span class="n">heights</span><span class="p">]</span>


<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">NaN</span><span class="p">,</span> <span class="n">Inf</span><span class="p">,</span> <span class="n">arange</span><span class="p">,</span> <span class="n">isscalar</span><span class="p">,</span> <span class="n">asarray</span><span class="p">,</span> <span class="n">array</span>


<div class="viewcode-block" id="peakdet"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.peakUtils.peakdet">[docs]</a><span class="k">def</span> <span class="nf">peakdet</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">negative</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converted from MATLAB script at http://billauer.co.il/peakdet.html</span>
<span class="sd">    % Eli Billauer, 3.4.05 (Explicitly not copyrighted).</span>
<span class="sd">    % This function is released to the public domain; Any use is allowed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># import time</span>
    <span class="c1">#</span>
    <span class="c1"># start = time.time()</span>

    <span class="n">maxtab</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">mintab</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">mn</span><span class="p">,</span> <span class="n">mx</span> <span class="o">=</span> <span class="n">Inf</span><span class="p">,</span> <span class="o">-</span><span class="n">Inf</span>
    <span class="n">mnpos</span><span class="p">,</span> <span class="n">mxpos</span> <span class="o">=</span> <span class="n">NaN</span><span class="p">,</span> <span class="n">NaN</span>
    <span class="n">lookformax</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)):</span>
        <span class="n">this</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">this</span> <span class="o">&gt;</span> <span class="n">mx</span><span class="p">:</span>
            <span class="n">mx</span> <span class="o">=</span> <span class="n">this</span>
            <span class="n">mxpos</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">this</span> <span class="o">&lt;</span> <span class="n">mn</span><span class="p">:</span>
            <span class="n">mn</span> <span class="o">=</span> <span class="n">this</span>
            <span class="n">mnpos</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">lookformax</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">negative</span><span class="p">:</span>  <span class="c1"># just positives</span>
                <span class="n">this</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">this</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">this</span> <span class="o">&lt;</span> <span class="n">mx</span> <span class="o">-</span> <span class="n">delta</span><span class="p">:</span>
                <span class="n">maxtab</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">float</span><span class="p">(</span><span class="n">mxpos</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">mx</span><span class="p">)))</span>
                <span class="n">mn</span> <span class="o">=</span> <span class="n">this</span>
                <span class="n">mnpos</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">lookformax</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">this</span> <span class="o">&gt;</span> <span class="n">mn</span> <span class="o">+</span> <span class="n">delta</span><span class="p">:</span>
                <span class="n">mintab</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">float</span><span class="p">(</span><span class="n">mnpos</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">mn</span><span class="p">)))</span>
                <span class="n">mx</span> <span class="o">=</span> <span class="n">this</span>
                <span class="n">mxpos</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">lookformax</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="k">return</span> <span class="n">maxtab</span><span class="p">,</span> <span class="n">mintab</span></div>


<span class="k">def</span> <span class="nf">_estimateDeltaPeakDetect</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">xPercent</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

    <span class="n">deltas</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">deltas</span><span class="p">))</span>
    <span class="c1"># just on the noisy part of spectrum</span>
    <span class="n">partialYpercent</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="n">xPercent</span><span class="p">)</span> <span class="o">/</span> <span class="mi">100</span>
    <span class="n">partialY</span> <span class="o">=</span> <span class="n">y</span><span class="p">[:</span><span class="nb">int</span><span class="p">(</span><span class="n">partialYpercent</span><span class="p">)]</span>
    <span class="n">partialDeltas</span> <span class="o">=</span> <span class="n">partialY</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">partialY</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">partialDelta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">partialDeltas</span><span class="p">))</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">partialDelta</span> <span class="o">+</span> <span class="n">delta</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="n">delta</span>


<span class="k">def</span> <span class="nf">_estimateDeltaPeakDetectSTD</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">xPercent</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    :param y: intensities of spectrum</span>
<span class="sd">    :param xPercent: the percentage of the spectra points to use as training to calculate delta.</span>
<span class="sd">    :return: a delta intesities of the required percentage of the spectra</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

    <span class="c1"># just on the noisy part of spectrum</span>
    <span class="n">partialYpercent</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="n">xPercent</span><span class="p">)</span> <span class="o">/</span> <span class="mi">100</span>
    <span class="n">partialY</span> <span class="o">=</span> <span class="n">y</span><span class="p">[:</span><span class="nb">int</span><span class="p">(</span><span class="n">partialYpercent</span><span class="p">)]</span>
    <span class="n">partialDeltas</span> <span class="o">=</span> <span class="n">partialY</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">partialY</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">partialDelta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">partialDeltas</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">partialDelta</span>


<span class="k">def</span> <span class="nf">_pairIntersectionPoints</span><span class="p">(</span><span class="n">intersectionPoints</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Yield successive pair chunks from list of intersectionPoints &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">intersectionPoints</span><span class="p">),</span> <span class="mi">2</span><span class="p">):</span>
        <span class="n">pair</span> <span class="o">=</span> <span class="n">intersectionPoints</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">pair</span>


<span class="k">def</span> <span class="nf">_getIntersectionPoints</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">line</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    :param line: x points of line to intersect y points</span>
<span class="sd">    :return: list of intersecting points</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">line</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">cross</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">z</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">z</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

    <span class="n">x_intersect</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">dx</span> <span class="o">/</span> <span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">z</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">z</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">negatives</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">cross</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">points</span> <span class="o">=</span> <span class="n">x_intersect</span><span class="p">[</span><span class="n">negatives</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">points</span>


<span class="k">def</span> <span class="nf">_getAtomWeight</span><span class="p">(</span><span class="n">axisCode</span><span class="p">,</span> <span class="n">atomWeights</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span> <span class="ow">or</span> <span class="nb">int</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>

<span class="sd">    :param axisCode: str of peak axis code</span>
<span class="sd">    :param atomWeights: dictionary of atomWeights eg {&#39;H&#39;: 7.00, &#39;N&#39;: 1.00, &#39;C&#39;: 4.00, &#39;Other&#39;: 1.00}</span>
<span class="sd">    :return: float or int from dict atomWeights</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">value</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axisCode</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">firstLetterAxisCode</span> <span class="o">=</span> <span class="n">axisCode</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">firstLetterAxisCode</span> <span class="ow">in</span> <span class="n">atomWeights</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">atomWeights</span><span class="p">[</span><span class="n">firstLetterAxisCode</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">OTHER</span> <span class="ow">in</span> <span class="n">atomWeights</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">atomWeights</span><span class="p">[</span><span class="n">OTHER</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">atomWeights</span><span class="p">[</span><span class="n">OTHER</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="mf">1.0</span>

    <span class="k">return</span> <span class="n">value</span>


<span class="k">def</span> <span class="nf">_traverse</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">tree_types</span><span class="o">=</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
    <span class="sd">&#39;&#39;&#39;used to flat the state in a long list &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">tree_types</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">o</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">subvalue</span> <span class="ow">in</span> <span class="n">_traverse</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">tree_types</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">subvalue</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">o</span>


<span class="k">def</span> <span class="nf">__filterPeaksBySelectedNmrAtomOption</span><span class="p">(</span><span class="n">nmrResidue</span><span class="p">,</span> <span class="n">nmrAtomsNames</span><span class="p">,</span> <span class="n">spectra</span><span class="p">):</span>
    <span class="n">peaks</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">nmrAtoms</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">peakLists</span> <span class="o">=</span> <span class="p">[</span><span class="n">sp</span><span class="o">.</span><span class="n">peakLists</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">peakLists</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;No PeakList for </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">sp</span><span class="p">)</span>
                 <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">spectra</span><span class="p">]</span>  <span class="c1"># take only the last peakList if more then 1</span>
    <span class="k">for</span> <span class="n">nmrAtomName</span> <span class="ow">in</span> <span class="n">nmrAtomsNames</span><span class="p">:</span>
        <span class="n">nmrAtom</span> <span class="o">=</span> <span class="n">nmrResidue</span><span class="o">.</span><span class="n">getNmrAtom</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">nmrAtomName</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">nmrAtom</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">nmrAtoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nmrAtom</span><span class="p">)</span>
    <span class="n">filteredPeaks</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">nmrAtomsNamesAvailable</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">nmrAtom</span> <span class="ow">in</span> <span class="n">nmrAtoms</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">nmrAtom</span><span class="o">.</span><span class="n">assignedPeaks</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">peak</span><span class="o">.</span><span class="n">peakList</span><span class="o">.</span><span class="n">spectrum</span> <span class="ow">in</span> <span class="n">spectra</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">nmrAtom</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">nmrAtomsNames</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">peak</span><span class="o">.</span><span class="n">peakList</span> <span class="ow">in</span> <span class="n">peakLists</span><span class="p">:</span>
                        <span class="n">filteredPeaks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">peak</span><span class="p">)</span>
                        <span class="n">nmrAtomsNamesAvailable</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nmrAtom</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">filteredPeaks</span><span class="p">)))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">spectra</span><span class="p">):</span>  <span class="c1"># deals when a residue is assigned to multiple peaks</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">nmrAtomsNamesAvailable</span><span class="p">)))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">nmrAtomsNames</span><span class="p">):</span>
            <span class="n">peaks</span> <span class="o">+=</span> <span class="n">filteredPeaks</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">filteredPeaks</span><span class="p">:</span>
            <span class="n">assignedNmrAtoms</span> <span class="o">=</span> <span class="n">_traverse</span><span class="p">(</span><span class="n">peak</span><span class="o">.</span><span class="n">assignedNmrAtoms</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">assignedNmrAtoms</span><span class="p">):</span>
                <span class="n">assignedNmrAtoms</span> <span class="o">=</span> <span class="p">[</span><span class="n">na</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">na</span> <span class="ow">in</span> <span class="n">assignedNmrAtoms</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">assignedNmrAtoms</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">list</span><span class="p">(</span><span class="n">assignedNmrAtoms</span><span class="p">)</span> <span class="o">==</span> <span class="n">nmrAtomsNames</span><span class="p">:</span>
                        <span class="n">peaks</span> <span class="o">+=</span> <span class="p">[</span><span class="n">peak</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nmrAtomsNames</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">nmrAtomsNames</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">assignedNmrAtoms</span><span class="p">:</span>
                        <span class="n">peaks</span> <span class="o">+=</span> <span class="p">[</span><span class="n">peak</span><span class="p">]</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">OrderedDict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">peaks</span><span class="p">))</span>




<div class="viewcode-block" id="getNmrResiduePeakProperty"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.peakUtils.getNmrResiduePeakProperty">[docs]</a><span class="k">def</span> <span class="nf">getNmrResiduePeakProperty</span><span class="p">(</span><span class="n">nmrResidue</span><span class="p">,</span> <span class="n">nmrAtomsNames</span><span class="p">,</span> <span class="n">spectra</span><span class="p">,</span> <span class="n">theProperty</span><span class="o">=</span><span class="s1">&#39;height&#39;</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>

<span class="sd">    :param nmrResidue:</span>
<span class="sd">    :param nmrAtomsNames: nmr Atoms to compare. str &#39;H&#39;, &#39;N&#39;, &#39;CA&#39; etc</span>
<span class="sd">    :param spectra: compare peaks only from given spectra</span>
<span class="sd">    :param theProperty: &#39;height&#39; or &#39;volume&#39;</span>
<span class="sd">    :return:</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">ll</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spectra</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">theProperty</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">,</span><span class="s1">&#39;volume&#39;</span><span class="p">]:</span>
        <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Property not currently available </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span><span class="n">theProperty</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="n">peaks</span> <span class="o">=</span> <span class="n">__filterPeaksBySelectedNmrAtomOption</span><span class="p">(</span><span class="n">nmrResidue</span><span class="p">,</span> <span class="n">nmrAtomsNames</span><span class="p">,</span> <span class="n">spectra</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">peaks</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">peaks</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">peak</span><span class="o">.</span><span class="n">peakList</span><span class="o">.</span><span class="n">spectrum</span> <span class="ow">in</span> <span class="n">spectra</span><span class="p">:</span>
                <span class="n">p</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">peak</span><span class="p">,</span> <span class="n">theProperty</span><span class="p">)</span>
                <span class="n">ll</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ll</span><span class="p">,</span> <span class="n">peaks</span></div>

<div class="viewcode-block" id="getNmrResiduePeakHeight"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.peakUtils.getNmrResiduePeakHeight">[docs]</a><span class="k">def</span> <span class="nf">getNmrResiduePeakHeight</span><span class="p">(</span><span class="n">nmrResidue</span><span class="p">,</span> <span class="n">nmrAtomsNames</span><span class="p">,</span> <span class="n">spectra</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    :param nmrResidue:</span>
<span class="sd">    :param nmrAtomsNames: nmr Atoms to compare. str &#39;H&#39;, &#39;N&#39;, &#39;CA&#39; etc</span>
<span class="sd">    :param spectra: compare peaks only from given spectra</span>
<span class="sd">    :return:</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Deprecated. Used getNmrResiduePeakProperty with theProperty = &quot;height&quot;&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">getNmrResiduePeakProperty</span><span class="p">(</span><span class="n">nmrResidue</span><span class="p">,</span> <span class="n">nmrAtomsNames</span><span class="p">,</span> <span class="n">spectra</span><span class="p">,</span> <span class="n">theProperty</span><span class="o">=</span><span class="s1">&#39;height&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="getRawDataFrame"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.peakUtils.getRawDataFrame">[docs]</a><span class="k">def</span> <span class="nf">getRawDataFrame</span><span class="p">(</span><span class="n">nmrResidues</span><span class="p">,</span> <span class="n">nmrAtomsNames</span><span class="p">,</span> <span class="n">spectra</span><span class="p">,</span> <span class="n">theProperty</span><span class="p">):</span>
    <span class="n">dfs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">sp</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">spectra</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">nmrResidue</span> <span class="ow">in</span> <span class="n">nmrResidues</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="s1">&#39;-&#39;</span> <span class="ow">in</span> <span class="n">nmrResidue</span><span class="o">.</span><span class="n">sequenceCode</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">):</span> <span class="c1"># not consider the +1 and -1 residues</span>
            <span class="n">ll</span> <span class="o">=</span>  <span class="n">getNmrResiduePeakProperty</span><span class="p">(</span><span class="n">nmrResidue</span><span class="p">,</span> <span class="n">nmrAtomsNames</span><span class="p">,</span> <span class="n">spectra</span><span class="p">,</span> <span class="n">theProperty</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ll</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">ll</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="n">nmrResidue</span><span class="o">.</span><span class="n">pid</span><span class="p">],</span> <span class="n">columns</span><span class="o">=</span><span class="n">names</span><span class="p">)</span>
                <span class="n">dfs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">dfs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">data</span></div>

<span class="k">def</span> <span class="nf">_getPeaksForNmrResidue</span><span class="p">(</span><span class="n">nmrResidue</span><span class="p">,</span> <span class="n">nmrAtomsNames</span><span class="p">,</span> <span class="n">spectra</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spectra</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="n">_peaks</span> <span class="o">=</span> <span class="n">__filterPeaksBySelectedNmrAtomOption</span><span class="p">(</span><span class="n">nmrResidue</span><span class="p">,</span> <span class="n">nmrAtomsNames</span><span class="p">,</span> <span class="n">spectra</span><span class="p">)</span>
    <span class="n">usepeaks</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">_peaks</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">_peaks</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">peak</span><span class="o">.</span><span class="n">peakList</span><span class="o">.</span><span class="n">spectrum</span> <span class="ow">in</span> <span class="n">spectra</span><span class="p">:</span>
                <span class="n">usepeaks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">peak</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">usepeaks</span>

<div class="viewcode-block" id="getNmrResidueDeltas"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.peakUtils.getNmrResidueDeltas">[docs]</a><span class="k">def</span> <span class="nf">getNmrResidueDeltas</span><span class="p">(</span><span class="n">nmrResidue</span><span class="p">,</span> <span class="n">nmrAtomsNames</span><span class="p">,</span> <span class="n">spectra</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">POSITIONS</span><span class="p">,</span> <span class="n">atomWeights</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>

<span class="sd">    :param nmrResidue:</span>
<span class="sd">    :param nmrAtomsNames: nmr Atoms to compare. str &#39;H&#39;, &#39;N&#39;, &#39;CA&#39; etc</span>
<span class="sd">    :param spectra: compare peaks only from given spectra</span>
<span class="sd">    :return:</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">deltas</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spectra</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="n">peaks</span> <span class="o">=</span> <span class="n">__filterPeaksBySelectedNmrAtomOption</span><span class="p">(</span><span class="n">nmrResidue</span><span class="p">,</span> <span class="n">nmrAtomsNames</span><span class="p">,</span> <span class="n">spectra</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">atomWeights</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">atomWeights</span> <span class="o">=</span> <span class="n">DefaultAtomWeights</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">peaks</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">peaks</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">peak</span><span class="o">.</span><span class="n">peakList</span><span class="o">.</span><span class="n">spectrum</span> <span class="ow">in</span> <span class="n">spectra</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>  <span class="c1">#some None value can get in here</span>
                    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="n">POSITIONS</span><span class="p">:</span>
                        <span class="n">delta</span> <span class="o">=</span> <span class="bp">None</span>
                        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">axisCode</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">peak</span><span class="o">.</span><span class="n">axisCodes</span><span class="p">):</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axisCode</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">axisCode</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">nmrAtomsNames</span><span class="p">):</span>
                                    <span class="n">weight</span> <span class="o">=</span> <span class="n">_getAtomWeight</span><span class="p">(</span><span class="n">axisCode</span><span class="p">,</span> <span class="n">atomWeights</span><span class="p">)</span>
                                    <span class="k">if</span> <span class="n">delta</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                                        <span class="n">delta</span> <span class="o">=</span> <span class="mf">0.0</span>
                                    <span class="n">delta</span> <span class="o">+=</span> <span class="p">((</span><span class="n">peak</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="nb">list</span><span class="p">(</span><span class="n">peaks</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="n">weight</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
                        <span class="k">if</span> <span class="n">delta</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                            <span class="n">delta</span> <span class="o">=</span> <span class="n">delta</span> <span class="o">**</span> <span class="mf">0.5</span>
                            <span class="n">deltas</span> <span class="o">+=</span> <span class="p">[</span><span class="n">delta</span><span class="p">]</span>

                    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="n">VOLUME</span><span class="p">:</span>
                        <span class="n">delta1Atoms</span> <span class="o">=</span> <span class="p">(</span><span class="n">peak</span><span class="o">.</span><span class="n">volume</span> <span class="o">/</span> <span class="nb">list</span><span class="p">(</span><span class="n">peaks</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">volume</span><span class="p">)</span>
                        <span class="n">deltas</span> <span class="o">+=</span> <span class="p">[((</span><span class="n">delta1Atoms</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">,</span> <span class="p">]</span>

                    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="n">HEIGHT</span><span class="p">:</span>
                        <span class="n">delta1Atoms</span> <span class="o">=</span> <span class="p">(</span><span class="n">peak</span><span class="o">.</span><span class="n">height</span> <span class="o">/</span> <span class="nb">list</span><span class="p">(</span><span class="n">peaks</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">height</span><span class="p">)</span>
                        <span class="n">deltas</span> <span class="o">+=</span> <span class="p">[((</span><span class="n">delta1Atoms</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">,</span> <span class="p">]</span>

                    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="n">LINEWIDTHS</span><span class="p">:</span>
                        <span class="n">delta</span> <span class="o">=</span> <span class="bp">None</span>
                        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">axisCode</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">peak</span><span class="o">.</span><span class="n">axisCodes</span><span class="p">):</span>
                            <span class="k">if</span> <span class="n">axisCode</span><span class="p">:</span>
                                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axisCode</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                                    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">axisCode</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">nmrAtomsNames</span><span class="p">):</span>
                                        <span class="n">weight</span> <span class="o">=</span> <span class="n">_getAtomWeight</span><span class="p">(</span><span class="n">axisCode</span><span class="p">,</span> <span class="n">atomWeights</span><span class="p">)</span>
                                        <span class="k">if</span> <span class="n">delta</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                                            <span class="n">delta</span> <span class="o">=</span> <span class="mf">0.0</span>
                                        <span class="n">delta</span> <span class="o">+=</span> <span class="p">((</span><span class="n">peak</span><span class="o">.</span><span class="n">lineWidths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="nb">list</span><span class="p">(</span><span class="n">peaks</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lineWidths</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="n">weight</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
                        <span class="k">if</span> <span class="n">delta</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                            <span class="n">delta</span> <span class="o">=</span> <span class="n">delta</span> <span class="o">**</span> <span class="mf">0.5</span>
                            <span class="n">deltas</span> <span class="o">+=</span> <span class="p">[</span><span class="n">delta</span><span class="p">]</span>

                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="n">message</span> <span class="o">=</span> <span class="s1">&#39;Error for calculation mode: </span><span class="si">%s</span><span class="s1"> on </span><span class="si">%s</span><span class="s1"> and </span><span class="si">%s</span><span class="s1">. &#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">peak</span><span class="o">.</span><span class="n">pid</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">peaks</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pid</span><span class="p">)</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                    <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">deltas</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">in</span> <span class="n">deltas</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">round</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">deltas</span><span class="p">)),</span> <span class="mi">3</span><span class="p">)</span>
    <span class="k">return</span></div>


<span class="k">def</span> <span class="nf">_getKd</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="n">param</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="n">bindingUnscaled</span><span class="p">,</span> <span class="n">bmax</span> <span class="o">=</span> <span class="n">param</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">yScaled</span> <span class="o">=</span> <span class="n">y</span> <span class="o">/</span> <span class="n">bmax</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">paramScaled</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">yScaled</span><span class="p">)</span>
        <span class="n">kd</span><span class="p">,</span> <span class="n">bmax</span> <span class="o">=</span> <span class="n">paramScaled</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
        <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Impossible to estimate Kd values. </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">err</span><span class="p">)</span>
        <span class="n">kd</span><span class="p">,</span> <span class="n">bmax</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">kd</span>


<div class="viewcode-block" id="oneSiteBindingCurve"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.peakUtils.oneSiteBindingCurve">[docs]</a><span class="k">def</span> <span class="nf">oneSiteBindingCurve</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">kd</span><span class="p">,</span> <span class="n">bmax</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">bmax</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">kd</span><span class="p">)</span></div>


<div class="viewcode-block" id="exponenial_func"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.peakUtils.exponenial_func">[docs]</a><span class="k">def</span> <span class="nf">exponenial_func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">b</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_fit1SiteBindCurve</span><span class="p">(</span><span class="n">bindingCurves</span><span class="p">,</span> <span class="n">aFunc</span><span class="o">=</span><span class="n">oneSiteBindingCurve</span><span class="p">,</span> <span class="n">xfStep</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">xfPercent</span><span class="o">=</span><span class="mi">30</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :param bindingCurves: DataFrame as: Columns -&gt; float or int.</span>
<span class="sd">                                                  Used as xs points (e.g. concentration/time/etc value)</span>
<span class="sd">                                        rows    -&gt; float or int.</span>
<span class="sd">                                                  Used as ys points (e.g. Deltadelta in ppm)</span>
<span class="sd">                                                  the actual curve points</span>
<span class="sd">                                        index   -&gt; obj. E.g. nmrResidue obj. used as identifier for the curve origin</span>

<span class="sd">                                        | index          |    1   |   2   |</span>
<span class="sd">                                        |----------------+--------|-------|</span>
<span class="sd">                                        | obj1           |    1.0 |   1.1 |</span>
<span class="sd">                                        | obj2           |    2.0 |   1.2 |</span>

<span class="sd">    :param aFunc:  Default: oneSiteBindingCurve.</span>
<span class="sd">    :param xfStep: number of x points for generating the fitted curve.</span>
<span class="sd">    :param xfPercent: percent to add to max X value of the fitted curve, so to have a longer curve after the last</span>
<span class="sd">                    experimental value.</span>

<span class="sd">    :return: tuple of parameters for plotting fitted curves.</span>
<span class="sd">             x_atHalf_Y: the x value for half of Y. Used as estimated  kd</span>
<span class="sd">             xs: array of xs. Original xs points from the dataFrame columns</span>
<span class="sd">             yScaled: array of yScaled. Scaled to have values 0 to 1</span>
<span class="sd">             xf: array of x point for the new fitted curve. A range from 0 to max of xs.</span>
<span class="sd">             yf: array the fitted curve</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">curve_fit</span>
    <span class="kn">from</span> <span class="nn">ccpn.util.Common</span> <span class="kn">import</span> <span class="n">percentage</span>

    <span class="n">errorValue</span> <span class="o">=</span> <span class="p">(</span><span class="bp">None</span><span class="p">,)</span> <span class="o">*</span> <span class="mi">6</span>
    <span class="k">if</span> <span class="n">aFunc</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">callable</span><span class="p">(</span><span class="n">aFunc</span><span class="p">):</span>
        <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Error. Fitting curve </span><span class="si">%s</span><span class="s2"> is not callable&quot;</span> <span class="o">%</span> <span class="n">aFunc</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">errorValue</span>
    <span class="k">if</span> <span class="n">bindingCurves</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Error. Binding curves not found&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">errorValue</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">bindingCurves</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">ys</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>  <span class="c1">#puts all y values in a single 1d array.</span>
    <span class="n">xss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span> <span class="o">*</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">xs</span> <span class="o">=</span> <span class="n">xss</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>  <span class="c1"># #puts all x values in a 1d array preserving the original y positions (order=&#39;F&#39;).</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">errorValue</span>  <span class="c1">#not enough datapoints</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">param</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span><span class="n">aFunc</span><span class="p">,</span> <span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">)</span>
        <span class="n">xhalfUnscaled</span><span class="p">,</span> <span class="n">bMaxUnscaled</span> <span class="o">=</span> <span class="n">param</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">yScaled</span> <span class="o">=</span> <span class="n">ys</span> <span class="o">/</span> <span class="n">bMaxUnscaled</span>  <span class="c1">#scales y to have values 0-1</span>
        <span class="n">paramScaled</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span><span class="n">aFunc</span><span class="p">,</span> <span class="n">xs</span><span class="p">,</span> <span class="n">yScaled</span><span class="p">)</span>

        <span class="n">xfRange</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span>
        <span class="n">xfPerc</span> <span class="o">=</span> <span class="n">percentage</span><span class="p">(</span><span class="n">xfPercent</span><span class="p">,</span> <span class="n">xfRange</span><span class="p">)</span>
        <span class="n">xfMax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span> <span class="o">+</span> <span class="n">xfPerc</span>
        <span class="n">xf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">xfMax</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="n">xfStep</span><span class="p">)</span>
        <span class="n">yf</span> <span class="o">=</span> <span class="n">aFunc</span><span class="p">(</span><span class="n">xf</span><span class="p">,</span> <span class="o">*</span><span class="n">paramScaled</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">x_atHalf_Y</span><span class="p">,</span> <span class="n">bmax</span> <span class="o">=</span> <span class="n">paramScaled</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">x_atHalf_Y</span><span class="p">,</span> <span class="n">bmax</span><span class="p">,</span> <span class="n">xs</span><span class="p">,</span> <span class="n">yScaled</span><span class="p">,</span> <span class="n">xf</span><span class="p">,</span> <span class="n">yf</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
        <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Impossible to estimate Kd value </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">err</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">errorValue</span>


<span class="k">def</span> <span class="nf">_fitExpDecayCurve</span><span class="p">(</span><span class="n">bindingCurves</span><span class="p">,</span> <span class="n">aFunc</span><span class="o">=</span><span class="n">exponenial_func</span><span class="p">,</span> <span class="n">xfStep</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">xfPercent</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">p0</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :param TODO</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">from</span> <span class="nn">ccpn.util.Common</span> <span class="kn">import</span> <span class="n">percentage</span>

    <span class="n">errorValue</span> <span class="o">=</span> <span class="p">(</span><span class="bp">None</span><span class="p">,)</span> <span class="o">*</span> <span class="mi">6</span>
    <span class="k">if</span> <span class="n">aFunc</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">callable</span><span class="p">(</span><span class="n">aFunc</span><span class="p">):</span>
        <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Error. Fitting curve </span><span class="si">%s</span><span class="s2"> is not callable&quot;</span> <span class="o">%</span> <span class="n">aFunc</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">errorValue</span>
    <span class="k">if</span> <span class="n">bindingCurves</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Error. Binding curves not found&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">errorValue</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">bindingCurves</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">ys</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>  <span class="c1">#puts all y values in a single 1d array.</span>
    <span class="n">xss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span> <span class="o">*</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">xs</span> <span class="o">=</span> <span class="n">xss</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>  <span class="c1"># #puts all x values in a 1d array preserving the original y positions (order=&#39;F&#39;).</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">errorValue</span>  <span class="c1">#not enough datapoints</span>
    <span class="k">try</span><span class="p">:</span>

        <span class="n">popt</span><span class="p">,</span> <span class="n">pcov</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span><span class="n">aFunc</span><span class="p">,</span> <span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="n">p0</span><span class="o">=</span><span class="n">p0</span><span class="p">)</span>
        <span class="n">xfRange</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span>
        <span class="n">xfPerc</span> <span class="o">=</span> <span class="n">percentage</span><span class="p">(</span><span class="n">xfPercent</span><span class="p">,</span> <span class="n">xfRange</span><span class="p">)</span>
        <span class="n">xfMax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span> <span class="o">+</span> <span class="n">xfPerc</span>
        <span class="n">xf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">xfMax</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="n">xfStep</span><span class="p">)</span>
        <span class="n">yf</span> <span class="o">=</span> <span class="n">aFunc</span><span class="p">(</span><span class="n">xf</span><span class="p">,</span> <span class="o">*</span><span class="n">popt</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="n">xf</span><span class="p">,</span> <span class="n">yf</span><span class="p">,</span> <span class="o">*</span><span class="n">popt</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
        <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Impossible to estimate Kd value </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">err</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">errorValue</span>


<div class="viewcode-block" id="snapToExtremum"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.peakUtils.snapToExtremum">[docs]</a><span class="k">def</span> <span class="nf">snapToExtremum</span><span class="p">(</span><span class="n">peak</span><span class="p">:</span> <span class="s1">&#39;Peak&#39;</span><span class="p">,</span> <span class="n">halfBoxSearchWidth</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">halfBoxFitWidth</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
                   <span class="n">minDropFactor</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">fitMethod</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">PARABOLICMETHOD</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Snap the position of the peak the nearest extremum.</span>
<span class="sd">    Assumes called with an existing peak, will fit within a box halfBoxSearchWidth about the current peak position.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">from</span> <span class="nn">ccpn.core.Peak</span> <span class="kn">import</span> <span class="n">Peak</span>
    <span class="kn">from</span> <span class="nn">ccpnc.peak</span> <span class="kn">import</span> <span class="n">Peak</span> <span class="k">as</span> <span class="n">CPeak</span>
    <span class="kn">from</span> <span class="nn">ccpn.framework.Application</span> <span class="kn">import</span> <span class="n">getApplication</span>

    <span class="c1"># error checking - that the peak is a valid peak</span>
    <span class="n">peak</span> <span class="o">=</span> <span class="n">getApplication</span><span class="p">()</span><span class="o">.</span><span class="n">project</span><span class="o">.</span><span class="n">getByPid</span><span class="p">(</span><span class="n">peak</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">peak</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">peak</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">peak</span><span class="p">,</span> <span class="n">Peak</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> is not of type Peak&#39;</span> <span class="o">%</span> <span class="n">peak</span><span class="p">)</span>

    <span class="n">apiPeak</span> <span class="o">=</span> <span class="n">peak</span><span class="o">.</span><span class="n">_wrappedData</span>

    <span class="n">dataSource</span> <span class="o">=</span> <span class="n">apiPeak</span><span class="o">.</span><span class="n">peakList</span><span class="o">.</span><span class="n">dataSource</span>
    <span class="n">numDim</span> <span class="o">=</span> <span class="n">dataSource</span><span class="o">.</span><span class="n">numDim</span>
    <span class="n">peakDims</span> <span class="o">=</span> <span class="n">apiPeak</span><span class="o">.</span><span class="n">sortedPeakDims</span><span class="p">()</span>

    <span class="c1"># get the height - remember not to use (position-1) because function does that</span>
    <span class="n">height</span> <span class="o">=</span> <span class="n">dataSource</span><span class="o">.</span><span class="n">getPositionValue</span><span class="p">([</span><span class="n">peakDim</span><span class="o">.</span><span class="n">position</span> <span class="k">for</span> <span class="n">peakDim</span> <span class="ow">in</span> <span class="n">peakDims</span><span class="p">])</span>

    <span class="c1"># generate a np array with the position of the peak in points rounded to integers</span>
    <span class="n">position</span> <span class="o">=</span> <span class="p">[</span><span class="n">peakDim</span><span class="o">.</span><span class="n">position</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">peakDim</span> <span class="ow">in</span> <span class="n">peakDims</span><span class="p">]</span>  <span class="c1"># API position starts at 1</span>

    <span class="c1"># round up/down the position</span>
    <span class="n">pLower</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">position</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">pUpper</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">position</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">position</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">position</span><span class="p">)</span>

    <span class="c1"># generate a np array with the number of points per dimension</span>
    <span class="c1"># numPoints = [peakDim.dataDim.numPoints for peakDim in peakDims]</span>
    <span class="n">numPoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">peakDim</span><span class="o">.</span><span class="n">dataDim</span><span class="o">.</span><span class="n">numPoints</span> <span class="k">for</span> <span class="n">peakDim</span> <span class="ow">in</span> <span class="n">peakDims</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

    <span class="c1"># extra plane in each direction increases accuracy of group fitting</span>
    <span class="n">startPoint</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">pLower</span> <span class="o">-</span> <span class="n">halfBoxSearchWidth</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">endPoint</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">pUpper</span> <span class="o">+</span> <span class="n">halfBoxSearchWidth</span><span class="p">,</span> <span class="n">numPoints</span><span class="p">)</span>

    <span class="c1"># map to co-ordinates to a (0,0) cornered box</span>
    <span class="n">regionArray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">startPoint</span> <span class="o">-</span> <span class="n">startPoint</span><span class="p">,</span> <span class="n">endPoint</span> <span class="o">-</span> <span class="n">startPoint</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

    <span class="c1"># Get the data; note that arguments have to be cast to int32s/float32s for the C routines</span>
    <span class="n">dataArray</span><span class="p">,</span> <span class="n">intRegion</span> <span class="o">=</span> <span class="n">dataSource</span><span class="o">.</span><span class="n">getRegionData</span><span class="p">(</span><span class="n">startPoint</span><span class="p">,</span> <span class="n">endPoint</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">dataArray</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">dataArray</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;no region found&#39;</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="n">scaledHeight</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">height</span>  <span class="c1"># this is so that have sensible pos/negLevel</span>
    <span class="k">if</span> <span class="n">height</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">doPos</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="n">doNeg</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">posLevel</span> <span class="o">=</span> <span class="n">scaledHeight</span>
        <span class="n">negLevel</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># arbitrary - not necessary</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">doPos</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">doNeg</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="n">posLevel</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># arbitrary - not necessary</span>
        <span class="n">negLevel</span> <span class="o">=</span> <span class="n">scaledHeight</span>

    <span class="n">exclusionBuffer</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">numDim</span>

    <span class="n">nonAdj</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">minLinewidth</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span> <span class="o">*</span> <span class="n">numDim</span>

    <span class="n">excludedRegionsList</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">excludedDiagonalDimsList</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">excludedDiagonalTransformList</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">peakPoints</span> <span class="o">=</span> <span class="n">CPeak</span><span class="o">.</span><span class="n">findPeaks</span><span class="p">(</span><span class="n">dataArray</span><span class="p">,</span> <span class="n">doNeg</span><span class="p">,</span> <span class="n">doPos</span><span class="p">,</span>
                                 <span class="n">negLevel</span><span class="p">,</span> <span class="n">posLevel</span><span class="p">,</span> <span class="n">exclusionBuffer</span><span class="p">,</span>
                                 <span class="n">nonAdj</span><span class="p">,</span> <span class="n">minDropFactor</span><span class="p">,</span> <span class="n">minLinewidth</span><span class="p">,</span>
                                 <span class="n">excludedRegionsList</span><span class="p">,</span> <span class="n">excludedDiagonalDimsList</span><span class="p">,</span> <span class="n">excludedDiagonalTransformList</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">peakPoints</span><span class="p">:</span>
        <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;no points found&#39;</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="c1"># catch any C errors</span>
    <span class="k">try</span><span class="p">:</span>

        <span class="c1"># find the closest peak in the found list</span>
        <span class="c1"># peakPoint, height = peakPoints[0]</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">peakPoint</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">for</span> <span class="n">findNextPeak</span> <span class="ow">in</span> <span class="n">peakPoints</span><span class="p">:</span>
            <span class="n">peakDist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">findNextPeak</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="n">position</span> <span class="o">-</span> <span class="n">startPoint</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dist</span> <span class="o">==</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">peakDist</span> <span class="o">&lt;</span> <span class="n">dist</span><span class="p">:</span>
                <span class="n">dist</span> <span class="o">=</span> <span class="n">peakDist</span>
                <span class="n">peakPoint</span> <span class="o">=</span> <span class="n">findNextPeak</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># use this as the centre for the peak fitting</span>
        <span class="n">peakPoint</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">peakPoint</span><span class="p">)</span>
        <span class="n">peakArray</span> <span class="o">=</span> <span class="n">peakPoint</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">numDim</span><span class="p">))</span>
        <span class="n">peakArray</span> <span class="o">=</span> <span class="n">peakArray</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">fitMethod</span> <span class="o">==</span> <span class="n">PARABOLICMETHOD</span><span class="p">:</span>
            <span class="c1"># parabolic - generate all peaks in one operation</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">CPeak</span><span class="o">.</span><span class="n">fitParabolicPeaks</span><span class="p">(</span><span class="n">dataArray</span><span class="p">,</span> <span class="n">regionArray</span><span class="p">,</span> <span class="n">peakArray</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">method</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">fitMethod</span> <span class="o">==</span> <span class="n">GAUSSIANMETHOD</span> <span class="k">else</span> <span class="mi">1</span>

            <span class="c1"># fit all peaks in one operation</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">CPeak</span><span class="o">.</span><span class="n">fitPeaks</span><span class="p">(</span><span class="n">dataArray</span><span class="p">,</span> <span class="n">regionArray</span><span class="p">,</span> <span class="n">peakArray</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>

    <span class="k">except</span> <span class="n">CPeak</span><span class="o">.</span><span class="n">error</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="c1"># there could be some fitting error</span>
        <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Aborting peak fit, Error for peak: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">peak</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="c1"># if any results are found then set the new peak position/height</span>
    <span class="k">if</span> <span class="n">result</span><span class="p">:</span>
        <span class="n">height</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">linewidth</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># work on the _wrappedData</span>
        <span class="n">apiPeak</span> <span class="o">=</span> <span class="n">peak</span><span class="o">.</span><span class="n">_wrappedData</span>
        <span class="n">peakDims</span> <span class="o">=</span> <span class="n">apiPeak</span><span class="o">.</span><span class="n">sortedPeakDims</span><span class="p">()</span>

        <span class="n">dataSource</span> <span class="o">=</span> <span class="n">apiPeak</span><span class="o">.</span><span class="n">peakList</span><span class="o">.</span><span class="n">dataSource</span>
        <span class="n">dataDims</span> <span class="o">=</span> <span class="n">dataSource</span><span class="o">.</span><span class="n">sortedDataDims</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">peakDim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">peakDims</span><span class="p">):</span>
            <span class="n">newPos</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">center</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mf">0.5</span><span class="p">),</span> <span class="n">dataArray</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mf">1.5</span><span class="p">)</span>

            <span class="c1"># ignore if out of range</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">newPos</span> <span class="o">-</span> <span class="n">center</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mf">1e-9</span><span class="p">:</span>
                <span class="n">peakDim</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">center</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">startPoint</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mf">1.0</span>  <span class="c1"># API position starts at 1</span>
            <span class="n">peakDim</span><span class="o">.</span><span class="n">lineWidth</span> <span class="o">=</span> <span class="n">dataDims</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">valuePerPoint</span> <span class="o">*</span> <span class="n">linewidth</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="n">apiPeak</span><span class="o">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">dataSource</span><span class="o">.</span><span class="n">scale</span> <span class="o">*</span> <span class="n">height</span></div>


<div class="viewcode-block" id="getSpectrumData"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.peakUtils.getSpectrumData">[docs]</a><span class="k">def</span> <span class="nf">getSpectrumData</span><span class="p">(</span><span class="n">peak</span><span class="p">:</span> <span class="s1">&#39;Peak&#39;</span><span class="p">,</span> <span class="n">halfBoxWidth</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get a region of the spectrum data centred on the peak.</span>
<span class="sd">    Will return the smallest region containing the peak halfBoxWidth about the current peak position.</span>

<span class="sd">    returns a tuple of the form (dataArray, region, position, planePosition)</span>

<span class="sd">        dataArray is the numpy array surrounding the peak, ordered by spectrum axisCodes</span>
<span class="sd">        region is a tuple (bottomLeft, topRight)</span>
<span class="sd">        position is the float32 relative position of the peak in dataArray</span>
<span class="sd">        planePosition is the int32 position of the nearest planes to the peak</span>

<span class="sd">    where bottomLeft is the co-ordinates of the bottom-left corner of the region</span>
<span class="sd">            topRight is the co-ordinates of the top-right corner of the region</span>

<span class="sd">            Co-ordinates are indexed from (0, 0)</span>

<span class="sd">            Note: screen point co-ordinates are indexed from (1, 1)</span>

<span class="sd">    The region will be cropped to the bounds of the spectrum, in which case position will not correspond to the centre</span>
<span class="sd">    if no region is found, returns None</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">from</span> <span class="nn">ccpn.core.Peak</span> <span class="kn">import</span> <span class="n">Peak</span>
    <span class="kn">from</span> <span class="nn">ccpn.framework.Application</span> <span class="kn">import</span> <span class="n">getApplication</span>

    <span class="c1"># error checking - that the peak is a valid peak</span>
    <span class="n">peak</span> <span class="o">=</span> <span class="n">getApplication</span><span class="p">()</span><span class="o">.</span><span class="n">project</span><span class="o">.</span><span class="n">getByPid</span><span class="p">(</span><span class="n">peak</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">peak</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">peak</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">peak</span><span class="p">,</span> <span class="n">Peak</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> is not of type Peak&#39;</span> <span class="o">%</span> <span class="n">peak</span><span class="p">)</span>

    <span class="n">apiPeak</span> <span class="o">=</span> <span class="n">peak</span><span class="o">.</span><span class="n">_wrappedData</span>

    <span class="n">dataSource</span> <span class="o">=</span> <span class="n">apiPeak</span><span class="o">.</span><span class="n">peakList</span><span class="o">.</span><span class="n">dataSource</span>
    <span class="n">peakDims</span> <span class="o">=</span> <span class="n">apiPeak</span><span class="o">.</span><span class="n">sortedPeakDims</span><span class="p">()</span>

    <span class="c1"># generate a np array with the position of the peak in points rounded to integers</span>
    <span class="n">position</span> <span class="o">=</span> <span class="p">[</span><span class="n">peakDim</span><span class="o">.</span><span class="n">position</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">peakDim</span> <span class="ow">in</span> <span class="n">peakDims</span><span class="p">]</span>  <span class="c1"># API position starts at 1</span>

    <span class="c1"># round up/down the position to give the square containing the peak</span>
    <span class="n">pLower</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">position</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">pUpper</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">position</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">position</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="c1"># generate a np array with the number of points per dimension</span>
    <span class="c1"># numPoints = [peakDim.dataDim.numPoints for peakDim in peakDims]</span>
    <span class="n">numPoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">peakDim</span><span class="o">.</span><span class="n">dataDim</span><span class="o">.</span><span class="n">numPoints</span> <span class="k">for</span> <span class="n">peakDim</span> <span class="ow">in</span> <span class="n">peakDims</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

    <span class="c1"># add extra points in each direction</span>
    <span class="n">startPoint</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">pLower</span> <span class="o">-</span> <span class="n">halfBoxWidth</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">endPoint</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">pUpper</span> <span class="o">+</span> <span class="n">halfBoxWidth</span><span class="p">,</span> <span class="n">numPoints</span><span class="p">)</span>

    <span class="c1"># Get the data; note that arguments has to be cast to ints for the C routines</span>
    <span class="n">dataArray</span><span class="p">,</span> <span class="n">intRegion</span> <span class="o">=</span> <span class="n">dataSource</span><span class="o">.</span><span class="n">getRegionData</span><span class="p">(</span><span class="n">startPoint</span><span class="p">,</span> <span class="n">endPoint</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">dataArray</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">dataArray</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;no region found&#39;</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">dataArray</span><span class="p">,</span> <span class="n">intRegion</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">position</span> <span class="o">-</span> <span class="n">startPoint</span><span class="p">),</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">position</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)))</span></div>


<div class="viewcode-block" id="estimateVolumes"><a class="viewcode-back" href="../../../../ccpn/ccpn.core.lib.html#ccpn.core.lib.peakUtils.estimateVolumes">[docs]</a><span class="k">def</span> <span class="nf">estimateVolumes</span><span class="p">(</span><span class="n">peaks</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="s1">&#39;Peak&#39;</span><span class="p">]],</span> <span class="n">volumeIntegralLimit</span><span class="o">=</span><span class="mf">2.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Estimate the volumes for the peaks</span>
<span class="sd">    :param peaks: list of peaks as pids or strings</span>
<span class="sd">    :param volumeIntegralLimit: integral width as a multiple of lineWidth (FWHM)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># move to peakList</span>

    <span class="kn">from</span> <span class="nn">ccpn.core.Peak</span> <span class="kn">import</span> <span class="n">Peak</span>
    <span class="kn">from</span> <span class="nn">ccpn.framework.Application</span> <span class="kn">import</span> <span class="n">getApplication</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">getApplication</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">getApplication</span><span class="p">()</span><span class="o">.</span><span class="n">project</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;There is no project&#39;</span><span class="p">)</span>

    <span class="n">getByPid</span> <span class="o">=</span> <span class="n">getApplication</span><span class="p">()</span><span class="o">.</span><span class="n">project</span><span class="o">.</span><span class="n">getByPid</span>

    <span class="c1"># error checking - that the peaks are valid</span>
    <span class="n">peakList</span> <span class="o">=</span> <span class="n">makeIterableList</span><span class="p">(</span><span class="n">peaks</span><span class="p">)</span>
    <span class="n">pks</span> <span class="o">=</span> <span class="p">[</span><span class="n">getByPid</span><span class="p">(</span><span class="n">peak</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">peak</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">peak</span> <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">peakList</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">pp</span> <span class="ow">in</span> <span class="n">pks</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pp</span><span class="p">,</span> <span class="n">Peak</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> is not of type Peak&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">pp</span><span class="p">))</span>

    <span class="c1"># estimate the volume for each peak</span>
    <span class="k">for</span> <span class="n">pp</span> <span class="ow">in</span> <span class="n">pks</span><span class="p">:</span>
        <span class="n">height</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">height</span>
        <span class="n">lineWidths</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">lineWidths</span>
        <span class="k">if</span> <span class="n">lineWidths</span> <span class="ow">and</span> <span class="bp">None</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lineWidths</span> <span class="ow">and</span> <span class="n">height</span><span class="p">:</span>
            <span class="n">pp</span><span class="o">.</span><span class="n">estimateVolume</span><span class="p">(</span><span class="n">volumeIntegralLimit</span><span class="o">=</span><span class="n">volumeIntegralLimit</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Peak </span><span class="si">%s</span><span class="s1"> contains undefined height/lineWidths&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">pp</span><span class="p">))</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">Python  documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright .
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.1.
    </div>
  </body>
</html>