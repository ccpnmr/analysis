<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>ccpnmodel.ccpncore.lib.V2Upgrade &mdash; Python  documentation</title>
    
    <link rel="stylesheet" href="../../../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <link rel="top" title="Python  documentation" href="../../../../index.html" />
    <link rel="up" title="Module code" href="../../../index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">Python  documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for ccpnmodel.ccpncore.lib.V2Upgrade</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Mapping of Resonances and ResonancGroups in version 2 to new 4-string assignment style</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="c1">#=========================================================================================</span>
<span class="c1"># Licence, Reference and Credits</span>
<span class="c1">#=========================================================================================</span>
<span class="n">__copyright__</span> <span class="o">=</span> <span class="s2">&quot;Copyright (C) CCPN project (http://www.ccpn.ac.uk) 2014 - 2017&quot;</span>
<span class="n">__credits__</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Wayne Boucher, Ed Brooksbank, Rasmus H Fogh, Luca Mureddu, Timothy J Ragan &amp; Geerten W Vuister&quot;</span><span class="p">)</span>
<span class="n">__licence__</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;CCPN licence. See http://www.ccpn.ac.uk/v3-software/downloads/license&quot;</span><span class="p">,</span>
               <span class="s2">&quot;or ccpnmodel.ccpncore.memops.Credits.CcpnLicense for licence text&quot;</span><span class="p">)</span>
<span class="n">__reference__</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;For publications, please use reference from http://www.ccpn.ac.uk/v3-software/downloads/license&quot;</span><span class="p">,</span>
               <span class="s2">&quot;or ccpnmodel.ccpncore.memops.Credits.CcpNmrReference&quot;</span><span class="p">)</span>

<span class="c1">#=========================================================================================</span>
<span class="c1"># Last code modification</span>
<span class="c1">#=========================================================================================</span>
<span class="n">__modifiedBy__</span> <span class="o">=</span> <span class="s2">&quot;$modifiedBy: CCPN $&quot;</span>
<span class="n">__dateModified__</span> <span class="o">=</span> <span class="s2">&quot;$dateModified: 2017-07-07 16:33:09 +0100 (Fri, July 07, 2017) $&quot;</span>
<span class="n">__version__</span> <span class="o">=</span> <span class="s2">&quot;$Revision: 3.0.b5 $&quot;</span>
<span class="c1">#=========================================================================================</span>
<span class="c1"># Created</span>
<span class="c1">#=========================================================================================</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s2">&quot;$Author: CCPN $&quot;</span>
<span class="n">__date__</span> <span class="o">=</span> <span class="s2">&quot;$Date: 2017-04-07 10:28:48 +0000 (Fri, April 07, 2017) $&quot;</span>
<span class="c1">#=========================================================================================</span>
<span class="c1"># Start of code</span>
<span class="c1">#=========================================================================================</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">operator</span>

<span class="kn">from</span> <span class="nn">ccpnmodel.ccpncore.lib.chemComp.Util</span> <span class="kn">import</span> <span class="n">chemAtomSetFromAtoms</span>


<div class="viewcode-block" id="mapResonanceGroupResidues"><a class="viewcode-back" href="../../../../ccpnmodel/ccpnmodel.ccpncore.lib.html#ccpnmodel.ccpncore.lib.V2Upgrade.mapResonanceGroupResidues">[docs]</a><span class="k">def</span> <span class="nf">mapResonanceGroupResidues</span><span class="p">(</span><span class="n">apiNmrProject</span><span class="p">,</span> <span class="n">molSystem</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">chainMap</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
  <span class="sd">&quot;&quot;&quot;Map resonanceGroup:assignmentTuple for fully assigned ResonanceGroups &quot;&quot;&quot;</span>

  <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>

  <span class="c1"># We need either chainMap or molSystem, and chainMap takes precedence</span>
  <span class="k">if</span> <span class="n">chainMap</span><span class="p">:</span>
    <span class="n">molSystem</span> <span class="o">=</span> <span class="bp">None</span>

  <span class="c1"># Handle properly assigned ResonanceGroups</span>
  <span class="k">for</span> <span class="n">resonanceGroup</span> <span class="ow">in</span> <span class="n">apiNmrProject</span><span class="o">.</span><span class="n">sortedResonanceGroups</span><span class="p">():</span>

    <span class="c1"># Find residue</span>
    <span class="n">residue</span> <span class="o">=</span> <span class="n">resonanceGroup</span><span class="o">.</span><span class="n">residue</span>
    <span class="k">if</span> <span class="n">residue</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
      <span class="n">ll</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="k">for</span> <span class="n">residueProb</span> <span class="ow">in</span> <span class="n">resonanceGroup</span><span class="o">.</span><span class="n">residueProbs</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">residueProb</span><span class="o">.</span><span class="n">weight</span><span class="p">:</span>
          <span class="n">ll</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">residueProb</span><span class="p">)</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ll</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># In principle this should never happen, but it does not hurt to be careful</span>
        <span class="n">residue</span> <span class="o">=</span> <span class="n">ll</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">possibility</span>

    <span class="k">if</span> <span class="n">residue</span><span class="p">:</span>

      <span class="c1"># Remap chain and residue if necessary,</span>

      <span class="n">chain</span> <span class="o">=</span> <span class="n">residue</span><span class="o">.</span><span class="n">chain</span>
      <span class="k">if</span> <span class="n">chainMap</span><span class="p">:</span>
        <span class="c1"># If there is a chainMap the chain MUST be in it.</span>
        <span class="n">chain</span> <span class="o">=</span> <span class="n">chainMap</span><span class="p">[</span><span class="n">chain</span><span class="p">]</span>
        <span class="c1"># get residue in new chain</span>
        <span class="n">residue</span> <span class="o">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">findFirstResidue</span><span class="p">(</span><span class="n">seqCode</span><span class="o">=</span><span class="n">residue</span><span class="o">.</span><span class="n">seqCode</span><span class="p">,</span>
                                         <span class="n">seqInsertCode</span><span class="o">=</span><span class="n">residue</span><span class="o">.</span><span class="n">seqInsertCode</span><span class="p">)</span>

      <span class="k">elif</span> <span class="n">residue</span><span class="o">.</span><span class="n">topObject</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">molSystem</span><span class="p">:</span>
          <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot generate consistent assignment names from mixed MolSystems - 1&quot;</span><span class="p">)</span>
      <span class="c1">#</span>
      <span class="c1"># # set residue assignment strings</span>
      <span class="c1"># chainCode = chain.code</span>
      <span class="c1"># sequenceCode = str(residue.seqCode)+ (residue.seqInsertCode or &#39;&#39;).strip()</span>
      <span class="c1"># residueType = residue.code3Letter</span>

      <span class="k">if</span> <span class="n">residue</span><span class="p">:</span>
        <span class="c1"># Should nevere happen, bunless there is an error in teh cahinMapping</span>
        <span class="n">result</span><span class="p">[</span><span class="n">resonanceGroup</span><span class="p">]</span> <span class="o">=</span> <span class="n">residue</span>
  <span class="c1">#</span>
  <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="mapUnAssignedFixedResonances"><a class="viewcode-back" href="../../../../ccpnmodel/ccpnmodel.ccpncore.lib.html#ccpnmodel.ccpncore.lib.V2Upgrade.mapUnAssignedFixedResonances">[docs]</a><span class="k">def</span> <span class="nf">mapUnAssignedFixedResonances</span><span class="p">(</span><span class="n">nmrConstraintStore</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Map unassigned resonances for NmrConstraintStore</span>

<span class="sd">   NBNB This must be done AFTER assignments and resonances are done,</span>
<span class="sd">   as it transfers teh assignment of the attached NmrProject resonance (if any)</span>
<span class="sd">   to the fixedResonance&quot;&quot;&quot;</span>

  <span class="n">nmrProject</span> <span class="o">=</span> <span class="n">nmrConstraintStore</span><span class="o">.</span><span class="n">nmrProject</span>

  <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>

  <span class="n">separator1</span> <span class="o">=</span> <span class="s1">&#39;@&#39;</span>
  <span class="n">separator2</span> <span class="o">=</span> <span class="s1">&#39;@@&#39;</span>   <span class="c1"># To distinguish fixedResonance serial from resonance serial</span>

  <span class="k">for</span> <span class="n">resonance</span> <span class="ow">in</span> <span class="n">nmrConstraintStore</span><span class="o">.</span><span class="n">sortedFixedResonances</span><span class="p">():</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">resonance</span><span class="o">.</span><span class="n">resonanceSet</span><span class="p">:</span>
      <span class="c1"># unassigned - treat it</span>

      <span class="n">nmrResonance</span> <span class="o">=</span> <span class="n">nmrProject</span><span class="o">.</span><span class="n">findFirstResonance</span><span class="p">(</span><span class="n">serial</span><span class="o">=</span><span class="n">resonance</span><span class="o">.</span><span class="n">resonanceSerial</span><span class="p">)</span>

      <span class="k">if</span> <span class="n">nmrResonance</span><span class="p">:</span>
        <span class="n">resonanceGroup</span> <span class="o">=</span> <span class="n">nmrResonance</span><span class="o">.</span><span class="n">resonanceGroup</span>
        <span class="n">result</span><span class="p">[</span><span class="n">resonance</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">resonanceGroup</span><span class="o">.</span><span class="n">nmrChain</span><span class="o">.</span><span class="n">code</span><span class="p">,</span> <span class="n">resonanceGroup</span><span class="o">.</span><span class="n">sequenceCode</span><span class="p">,</span>
                             <span class="n">resonanceGroup</span><span class="o">.</span><span class="n">residueType</span><span class="p">,</span> <span class="n">nmrResonance</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

      <span class="k">else</span><span class="p">:</span>
        <span class="c1"># No resonance found - make name from fixedResonance info</span>
        <span class="n">name</span> <span class="o">=</span>  <span class="n">regularisedResonanceName</span><span class="p">(</span><span class="n">resonance</span><span class="p">)</span>

        <span class="c1"># Add resonance serial to name, if it is not in the name already.</span>
        <span class="n">separator</span> <span class="o">=</span> <span class="n">separator1</span>
        <span class="c1"># use resonanceSerial if available</span>
        <span class="n">serial</span> <span class="o">=</span> <span class="n">resonance</span><span class="o">.</span><span class="n">resonanceSerial</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">serial</span><span class="p">:</span>
          <span class="c1"># use FixedResonance.serial instead, and use &#39;@@&#39; to distinguish</span>
          <span class="n">serial</span> <span class="o">=</span> <span class="n">resonance</span><span class="o">.</span><span class="n">serial</span>
          <span class="n">separator</span> <span class="o">=</span> <span class="n">separator2</span>

        <span class="n">ss</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">separator1</span><span class="p">,</span> <span class="n">serial</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ss</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">name</span><span class="p">:</span>
          <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s%s%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">separator</span><span class="p">,</span> <span class="n">serial</span><span class="p">)</span>
        <span class="c1">#</span>
        <span class="n">result</span><span class="p">[</span><span class="n">resonance</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
  <span class="c1">#</span>
  <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="addOffsetResonanceGroup"><a class="viewcode-back" href="../../../../ccpnmodel/ccpnmodel.ccpncore.lib.html#ccpnmodel.ccpncore.lib.V2Upgrade.addOffsetResonanceGroup">[docs]</a><span class="k">def</span> <span class="nf">addOffsetResonanceGroup</span><span class="p">(</span><span class="n">addToGroup</span><span class="p">:</span><span class="s1">&#39;ResonanceGroup&#39;</span><span class="p">,</span> <span class="n">addGroup</span><span class="p">:</span><span class="s1">&#39;ResonanceGroup&#39;</span><span class="p">,</span>
                             <span class="n">offset</span><span class="p">:</span><span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
  <span class="sd">&quot;&quot;&quot;Add addGroup as satellite to addToGroup with offset offset. Return True if successful&quot;&quot;&quot;</span>
  <span class="n">previous</span> <span class="o">=</span> <span class="n">addToGroup</span><span class="o">.</span><span class="n">nmrProject</span><span class="o">.</span><span class="n">findFirstResonanceGroup</span><span class="p">(</span><span class="n">mainGroupSerial</span><span class="o">=</span><span class="n">addToGroup</span><span class="o">.</span><span class="n">serial</span><span class="p">,</span>
                                                           <span class="n">relativeOffset</span><span class="o">=</span><span class="n">offset</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">previous</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
    <span class="c1"># New. Set as offset. Multisteps to avoid name clashes and ensure undo.</span>
    <span class="c1"># We do not need to guard against connected stretches etc. in V2 conversion</span>
    <span class="n">addGroup</span><span class="o">.</span><span class="n">sequenceCode</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">addGroup</span><span class="o">.</span><span class="n">directNmrChain</span> <span class="o">=</span> <span class="n">addToGroup</span><span class="o">.</span><span class="n">nmrChain</span>
    <span class="n">addGroup</span><span class="o">.</span><span class="n">sequenceCode</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s%+d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">addToGroup</span><span class="o">.</span><span class="n">sequenceCode</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>

    <span class="c1"># set offset residueType</span>
    <span class="n">residueType</span> <span class="o">=</span> <span class="n">addGroup</span><span class="o">.</span><span class="n">residueType</span>
    <span class="k">if</span> <span class="n">residueType</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
      <span class="n">chemComp</span> <span class="o">=</span> <span class="n">addToGroup</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">findFirstChemComp</span><span class="p">(</span><span class="n">molType</span><span class="o">=</span><span class="n">addGroup</span><span class="o">.</span><span class="n">molType</span><span class="p">,</span>
                                                         <span class="n">ccpCode</span><span class="o">=</span><span class="n">addGroup</span><span class="o">.</span><span class="n">ccpCode</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">chemComp</span><span class="p">:</span>
        <span class="n">addGroup</span><span class="o">.</span><span class="n">residueType</span> <span class="o">=</span> <span class="n">chemComp</span><span class="o">.</span><span class="n">code3Letter</span>

    <span class="k">return</span> <span class="bp">True</span>

  <span class="k">else</span><span class="p">:</span>
    <span class="c1"># Duplicate. Merge.</span>
    <span class="c1"># NBNB check that resonance names are dealt with properly later</span>
    <span class="k">for</span> <span class="n">resonance</span> <span class="ow">in</span> <span class="n">addGroup</span><span class="o">.</span><span class="n">resonances</span><span class="p">:</span>
      <span class="n">resonance</span><span class="o">.</span><span class="n">resonanceGroup</span> <span class="o">=</span> <span class="n">previous</span>
    <span class="n">addGroup</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>

    <span class="k">return</span> <span class="bp">False</span></div>



<div class="viewcode-block" id="mapAssignedResonances"><a class="viewcode-back" href="../../../../ccpnmodel/ccpnmodel.ccpncore.lib.html#ccpnmodel.ccpncore.lib.V2Upgrade.mapAssignedResonances">[docs]</a><span class="k">def</span> <span class="nf">mapAssignedResonances</span><span class="p">(</span><span class="n">topObject</span><span class="p">,</span> <span class="n">molSystem</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">chainMap</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Make/extend {resonance:assignmentTuple} map in V2 for either Resonances or fixedResonances</span>
<span class="sd">  chainMap remaps chains to new ones with different chainCodes (for V2-V3 upgrade).</span>

<span class="sd">  NB, does NOT use ResonanceGroup information&quot;&quot;&quot;</span>

  <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>

  <span class="k">if</span> <span class="n">topObject</span><span class="o">.</span><span class="n">className</span> <span class="o">==</span> <span class="s1">&#39;NmrProject&#39;</span><span class="p">:</span>
    <span class="n">resonanceSets</span> <span class="o">=</span> <span class="n">topObject</span><span class="o">.</span><span class="n">sortedResonanceSets</span><span class="p">()</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">resonanceSets</span> <span class="o">=</span> <span class="n">topObject</span><span class="o">.</span><span class="n">sortedFixedResonanceSets</span><span class="p">()</span>

  <span class="k">for</span> <span class="n">resonanceSet</span> <span class="ow">in</span> <span class="n">resonanceSets</span><span class="p">:</span>

    <span class="c1"># set up loop-level parameters</span>
    <span class="n">resonances</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">resonanceSet</span><span class="o">.</span><span class="n">resonances</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">resonanceSet</span><span class="o">.</span><span class="n">findFirstResonance</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
      <span class="n">resonances</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">operator</span><span class="o">.</span><span class="n">attrgetter</span><span class="p">(</span><span class="s1">&#39;serial&#39;</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">resonances</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">operator</span><span class="o">.</span><span class="n">attrgetter</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">))</span>
    <span class="n">atomSets</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">resonanceSet</span><span class="o">.</span><span class="n">atomSets</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">resonanceSet</span><span class="o">.</span><span class="n">findFirstAtomSet</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
      <span class="n">atomSets</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">operator</span><span class="o">.</span><span class="n">attrgetter</span><span class="p">(</span><span class="s1">&#39;serial&#39;</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">atomSets</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">operator</span><span class="o">.</span><span class="n">attrgetter</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">))</span>
    <span class="n">allAtoms</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">atomSets</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">y</span><span class="o">.</span><span class="n">atoms</span><span class="p">]</span>
    <span class="n">chemAtomSet</span> <span class="o">=</span> <span class="n">chemAtomSetFromAtoms</span><span class="p">(</span><span class="n">allAtoms</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">residue</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">allAtoms</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
      <span class="n">residue</span> <span class="o">=</span> <span class="n">allAtoms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">residue</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">residue</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">if</span> <span class="n">residue</span><span class="p">:</span>

      <span class="c1"># Remap chain and residue if necessary</span>
      <span class="n">chain</span> <span class="o">=</span> <span class="n">residue</span><span class="o">.</span><span class="n">chain</span>
      <span class="k">if</span> <span class="n">chainMap</span><span class="p">:</span>
        <span class="c1"># If there is a chainMap the chain MUST be in it.</span>
        <span class="n">chain</span> <span class="o">=</span> <span class="n">chainMap</span><span class="p">[</span><span class="n">chain</span><span class="p">]</span>
        <span class="c1"># get residue in new chain</span>
        <span class="n">residue</span> <span class="o">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">findFirstResidue</span><span class="p">(</span><span class="n">seqCode</span><span class="o">=</span><span class="n">residue</span><span class="o">.</span><span class="n">seqCode</span><span class="p">,</span>
                                         <span class="n">seqInsertCode</span><span class="o">=</span><span class="n">residue</span><span class="o">.</span><span class="n">seqInsertCode</span><span class="p">)</span>

      <span class="k">elif</span> <span class="n">chain</span><span class="o">.</span><span class="n">molSystem</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">molSystem</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot generate consistent assignment names from mixed MolSystems - 2&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">residue</span><span class="p">:</span>
      <span class="c1"># Should always be true - but in case something went wrong with the chain mapping</span>

      <span class="c1"># We have the residue - and we need the ChemCompVar below</span>
      <span class="n">chemComp</span> <span class="o">=</span> <span class="n">residue</span><span class="o">.</span><span class="n">molResidue</span><span class="o">.</span><span class="n">chemComp</span>
      <span class="n">chemCompVar</span> <span class="o">=</span> <span class="n">residue</span><span class="o">.</span><span class="n">chemCompVar</span> <span class="ow">or</span> <span class="n">chemComp</span><span class="o">.</span><span class="n">findFirstChemCompVar</span><span class="p">(</span><span class="n">isDefaultVar</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

      <span class="c1"># Now for the atom name</span>
      <span class="k">if</span> <span class="n">chemAtomSet</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">atomSets</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">resonances</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1"># prochiral pair. Use _getAmbigProchiralLabel for priority, and set &#39;x&#39; for &#39;a&#39;, &#39;y&#39; for &#39;b&#39;</span>

        <span class="c1"># get non-stereo names</span>
        <span class="n">atomSetNames</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">atomSets</span><span class="p">]</span>
        <span class="n">starpos</span> <span class="o">=</span> <span class="n">chemAtomSet</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">)</span>
        <span class="n">newNames</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="n">starpos</span><span class="p">:]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">atomSetNames</span><span class="p">)]</span> <span class="o">==</span> <span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;&#39;&quot;</span><span class="p">]:</span>
          <span class="c1"># special case - names are &quot;abc&#39;&quot;, &quot;abc&#39;&#39;&quot;</span>
          <span class="n">ss</span> <span class="o">=</span> <span class="n">atomSetNames</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span><span class="n">starpos</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
          <span class="n">newNames</span> <span class="o">=</span> <span class="p">[</span><span class="n">ss</span> <span class="o">+</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">ss</span> <span class="o">+</span> <span class="s1">&#39;y&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">newChar</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="s1">&#39;xy&#39;</span><span class="p">):</span>
            <span class="n">chars</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">atomSetNames</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span>
            <span class="n">chars</span><span class="p">[</span><span class="n">starpos</span><span class="p">]</span> <span class="o">=</span> <span class="n">newChar</span>
            <span class="n">newNames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">chars</span><span class="p">))</span>

        <span class="c1"># select new name to use</span>
        <span class="k">if</span> <span class="n">topObject</span><span class="o">.</span><span class="n">className</span> <span class="o">==</span> <span class="s1">&#39;NmrProject&#39;</span><span class="p">:</span>
          <span class="c1"># Real resonance - use normal procedure</span>

          <span class="c1"># First one resonance. NB we test prochiral label on one resonance only</span>
          <span class="c1"># - if data are inconsistent both might give &#39;a&#39; and we must avoid a name clash.</span>
          <span class="k">if</span> <span class="n">_getAmbigProchiralLabel</span><span class="p">(</span><span class="n">resonances</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="s1">&#39;a&#39;</span><span class="p">:</span>
            <span class="c1"># First resonance does not match first name - reverse name order</span>
            <span class="c1"># NB we test on one resonance only. If data are inconsistent and both give &#39;a&#39;</span>
            <span class="c1"># we still want the names to be different</span>
            <span class="n">newNames</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>

          <span class="k">for</span> <span class="n">ii</span><span class="p">,</span><span class="n">resonance</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">resonances</span><span class="p">):</span>
            <span class="n">result</span><span class="p">[</span><span class="n">resonance</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">residue</span><span class="p">,</span> <span class="n">newNames</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">,</span><span class="s1">&#39;%&#39;</span><span class="p">))</span>


        <span class="k">else</span><span class="p">:</span>
          <span class="c1"># NmrConstraintStore - these are fixed resonances</span>

          <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">resonances</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># resonances are sorted by name, as are newNames. Match in order.</span>
            <span class="c1"># NB this being in an NmrConstraintStore, we have to assume that names  are</span>
            <span class="c1"># consistent, so e.g. HG1* is bound to CG1 and not CG2</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
              <span class="n">result</span><span class="p">[</span><span class="n">resonances</span><span class="p">[</span><span class="n">ii</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="n">residue</span><span class="p">,</span> <span class="n">newNames</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">,</span><span class="s1">&#39;%&#39;</span><span class="p">))</span>

          <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Only one resonance. Must choose which.</span>
            <span class="c1"># Use various heuristics, as we can not assume assignments in NmrProject still match.</span>

            <span class="c1"># assert len(resonances) == 1</span>
            <span class="n">resonance</span> <span class="o">=</span> <span class="n">resonances</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">resonance</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
              <span class="c1"># Aribtratily pck the first one. Wnat else?</span>
              <span class="n">indx</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="k">else</span><span class="p">:</span>
              <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">resonance</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span><span class="p">(</span><span class="n">atomSetNames</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">newNames</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span> <span class="ow">or</span>
                    <span class="n">resonance</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="ow">in</span><span class="p">(</span><span class="n">atomSetNames</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">newNames</span><span class="p">[</span><span class="n">ii</span><span class="p">])):</span>
                  <span class="c1"># name matches one of the atomSets - use matching name</span>
                  <span class="n">indx</span> <span class="o">=</span> <span class="n">ii</span>
                  <span class="k">break</span>

              <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Name did not match either possibility, so these are non-standard. Try anyway</span>
                <span class="k">if</span> <span class="s1">&#39;b&#39;</span> <span class="ow">in</span> <span class="n">resonance</span><span class="o">.</span><span class="n">name</span> <span class="ow">or</span> <span class="s1">&#39;3&#39;</span> <span class="ow">in</span> <span class="n">resonance</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                  <span class="c1"># Heuristic - these names are likely to be second in sorting</span>
                  <span class="c1"># e.g. &#39;HBb&#39; or &#39;HB3&#39;</span>
                  <span class="n">indx</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="s1">&#39;a&#39;</span> <span class="ow">in</span> <span class="n">resonance</span><span class="o">.</span><span class="n">name</span> <span class="ow">or</span> <span class="s1">&#39;1&#39;</span> <span class="ow">in</span> <span class="n">resonance</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                  <span class="c1"># Heuristic = this name is likely to be first in sorting (e.g. &#39;HBa&#39;</span>
                  <span class="c1"># NB both XY1, XY1*, XY11, XY21 (Asn, Gln,Arg) XY12 (Ile) should sort first</span>
                  <span class="c1"># Arg HH12 should sort second, but this cannot be helped</span>
                  <span class="n">indx</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">elif</span> <span class="s1">&#39;2&#39;</span> <span class="ow">in</span> <span class="n">resonance</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                  <span class="c1"># This will not sort second for e,g, HB2/HB3, but that cannot be helped.</span>
                  <span class="c1"># The only one that matters is</span>
                  <span class="c1"># where e.g. HD1 must bind to CD1 and HD2 to CD2, and it gets those right</span>
                  <span class="c1"># Anyway the real atom names are caught before this</span>
                  <span class="n">indx</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                  <span class="n">realResonance</span> <span class="o">=</span> <span class="n">resonance</span><span class="o">.</span><span class="n">resonance</span>
                  <span class="k">if</span> <span class="n">realResonance</span><span class="p">:</span>
                    <span class="c1"># We can not be sure that assignments have not changed, but</span>
                    <span class="c1"># better have it match the resonance than not</span>
                    <span class="k">if</span> <span class="n">_getAmbigProchiralLabel</span><span class="p">(</span><span class="n">realResonance</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;a&#39;</span><span class="p">:</span>
                      <span class="n">indx</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">else</span><span class="p">:</span>
                      <span class="n">indx</span> <span class="o">=</span> <span class="mi">1</span>
                  <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Stuff it. We just do not know and pick the first one.</span>
                    <span class="c1"># Anyway the cases where is makes a difference are cared for above.</span>
                    <span class="n">indx</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="n">resonanceName</span> <span class="o">=</span> <span class="n">newNames</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span>
            <span class="n">result</span><span class="p">[</span><span class="n">resonance</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">residue</span><span class="p">,</span> <span class="n">resonanceName</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">,</span><span class="s1">&#39;%&#39;</span><span class="p">))</span>

      <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">resonances</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># Single resonance, not assigned to prochiral</span>

        <span class="n">resonance</span> <span class="o">=</span> <span class="n">resonances</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">atomSets</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
          <span class="c1"># simple one-to-one stereospecific assignment</span>
          <span class="k">if</span> <span class="n">chemAtomSet</span><span class="p">:</span>
            <span class="c1"># assignment to atomSet</span>
            <span class="n">resonanceName</span> <span class="o">=</span> <span class="n">chemAtomSet</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="s1">&#39;%&#39;</span><span class="p">)</span>
          <span class="k">else</span><span class="p">:</span>
            <span class="c1">#asssignment to single atom</span>
            <span class="n">resonanceName</span> <span class="o">=</span> <span class="n">allAtoms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span>

        <span class="k">else</span><span class="p">:</span>
          <span class="c1"># multiple atomSets</span>
          <span class="c1"># NB we do it this way because it must work in pure V2 as well as the intermediate model</span>
          <span class="n">nuc</span> <span class="o">=</span> <span class="n">allAtoms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">elementSymbol</span>
          <span class="n">residueChemAtoms</span> <span class="o">=</span> <span class="p">[</span><span class="n">chemCompVar</span><span class="o">.</span><span class="n">findFirstChemAtom</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">residue</span><span class="o">.</span><span class="n">atoms</span><span class="p">]</span>
          <span class="n">residueChemAtoms</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">residueChemAtoms</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">]</span>
          <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">allAtoms</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">residueChemAtoms</span><span class="p">):</span>
            <span class="c1"># All single atoms in residue</span>
            <span class="n">resonanceName</span> <span class="o">=</span> <span class="s1">&#39;*&#39;</span>

          <span class="k">elif</span> <span class="p">(</span><span class="nb">all</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">elementSymbol</span> <span class="o">==</span> <span class="n">nuc</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">allAtoms</span><span class="p">)</span> <span class="ow">and</span>
              <span class="nb">len</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">residueChemAtoms</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">elementSymbol</span> <span class="o">==</span> <span class="n">nuc</span><span class="p">])</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">allAtoms</span><span class="p">)):</span>
            <span class="c1"># All atoms of a given nucleus</span>
            <span class="n">resonanceName</span> <span class="o">=</span> <span class="n">nuc</span> <span class="o">+</span> <span class="s1">&#39;*&#39;</span>

          <span class="k">else</span><span class="p">:</span>
            <span class="c1"># random multiple atom selection</span>
            <span class="n">resonanceName</span> <span class="o">=</span> <span class="s1">&#39;/&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">((</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">atomSets</span><span class="p">)))</span>

        <span class="n">result</span><span class="p">[</span><span class="n">resonance</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">residue</span><span class="p">,</span> <span class="n">resonanceName</span><span class="p">)</span>

      <span class="k">else</span><span class="p">:</span>
        <span class="c1"># multiple resonances not matching chemAtomSet</span>
        <span class="n">atomsName</span> <span class="o">=</span> <span class="s1">&#39;/&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">((</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">atomSets</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">resonance</span> <span class="ow">in</span> <span class="n">resonances</span><span class="p">:</span>
          <span class="c1"># NB this name can not be in use already, so we do not need to check</span>
          <span class="n">resonanceName</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">@</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">atomsName</span><span class="p">,</span> <span class="n">resonance</span><span class="o">.</span><span class="n">serial</span><span class="p">)</span>

          <span class="n">result</span><span class="p">[</span><span class="n">resonance</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">residue</span><span class="p">,</span> <span class="n">resonanceName</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">,</span><span class="s1">&#39;%&#39;</span><span class="p">))</span>

    <span class="k">else</span><span class="p">:</span>
      <span class="c1"># assigned to multiple residues - cannot be helped</span>
      <span class="c1"># Same naming style for single and multiple resonances</span>
      <span class="n">partNames</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="k">for</span> <span class="n">atomSet</span> <span class="ow">in</span> <span class="n">atomSets</span><span class="p">:</span>
        <span class="n">rr</span> <span class="o">=</span> <span class="n">atomSet</span><span class="o">.</span><span class="n">findFirstAtom</span><span class="p">()</span><span class="o">.</span><span class="n">residue</span>
        <span class="n">partNames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s%s</span><span class="s1">-</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">rr</span><span class="o">.</span><span class="n">seqCode</span><span class="p">,</span> <span class="p">(</span><span class="n">rr</span><span class="o">.</span><span class="n">seqInsertCode</span> <span class="ow">or</span> <span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">(),</span> <span class="n">atomSet</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

      <span class="n">ss</span> <span class="o">=</span> <span class="s1">&#39;/&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">partNames</span><span class="p">))</span>
      <span class="k">for</span> <span class="n">resonance</span> <span class="ow">in</span> <span class="n">resonances</span><span class="p">:</span>
        <span class="n">resonanceName</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">@</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="n">resonance</span><span class="o">.</span><span class="n">serial</span><span class="p">)</span>

        <span class="n">result</span><span class="p">[</span><span class="n">resonance</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="n">resonanceName</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">,</span><span class="s1">&#39;%&#39;</span><span class="p">))</span>
  <span class="c1">#</span>
  <span class="k">return</span> <span class="n">result</span></div>

<span class="c1">###################################################################################</span>
<span class="c1">#</span>
<span class="c1">#  Functions for V2/upgrade only:</span>
<span class="c1">#</span>
<span class="c1">###################################################################################</span>

<div class="viewcode-block" id="regularisedResonanceName"><a class="viewcode-back" href="../../../../ccpnmodel/ccpnmodel.ccpncore.lib.html#ccpnmodel.ccpncore.lib.V2Upgrade.regularisedResonanceName">[docs]</a><span class="k">def</span> <span class="nf">regularisedResonanceName</span><span class="p">(</span><span class="n">resonance</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;V2: Get resonance name, starting with element type and adding @serial to impossible names&quot;&quot;&quot;</span>

  <span class="c1"># NB names like &#39;*&#39;, &#39;C*&#39; etc. will not make it through regularisation</span>
  <span class="c1"># but it is too dangerous to arrive at those from name strings only</span>
  <span class="c1"># For that you need to have them properly assigned.</span>

  <span class="n">resonanceName</span> <span class="o">=</span> <span class="n">resonance</span><span class="o">.</span><span class="n">name</span> <span class="ow">or</span> <span class="s1">&#39;&#39;</span>

  <span class="c1"># get elementCode</span>
  <span class="n">isotope</span> <span class="o">=</span> <span class="n">resonance</span><span class="o">.</span><span class="n">isotope</span>
  <span class="k">if</span> <span class="n">isotope</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
    <span class="n">elementCode</span> <span class="o">=</span> <span class="s1">&#39;?&#39;</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">elementCode</span> <span class="o">=</span> <span class="n">isotope</span><span class="o">.</span><span class="n">chemElement</span><span class="o">.</span><span class="n">symbol</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>

  <span class="n">result</span> <span class="o">=</span> <span class="bp">None</span>

  <span class="k">if</span> <span class="n">resonance</span><span class="o">.</span><span class="n">className</span> <span class="o">==</span> <span class="s1">&#39;Resonance&#39;</span><span class="p">:</span>

    <span class="c1"># Exclude fixedResonances</span>
    <span class="n">assignNames</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">resonance</span><span class="o">.</span><span class="n">assignNames</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">assignNames</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
      <span class="c1"># One assignName - use for assignment</span>
      <span class="n">name</span> <span class="o">=</span> <span class="n">assignNames</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
      <span class="n">result</span> <span class="o">=</span>  <span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="s1">&#39;%&#39;</span><span class="p">)</span>


    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">assignNames</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
      <span class="c1"># 2 assignNames - if they match prochiral return nonstereo variant</span>
      <span class="n">assignNames</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
      <span class="n">prefix</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">commonprefix</span><span class="p">(</span><span class="n">assignNames</span><span class="p">)</span>
      <span class="n">lenPrefix</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">assignNames</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">lenPrefix</span><span class="p">]</span><span class="o">.</span><span class="n">isdigit</span><span class="p">()</span> <span class="ow">and</span> <span class="n">assignNames</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">lenPrefix</span><span class="p">]</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">assignNames</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">lenPrefix</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span> <span class="o">==</span> <span class="n">assignNames</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">lenPrefix</span><span class="o">+</span><span class="mi">1</span><span class="p">:]:</span>

          <span class="c1"># Heuristics, try to get x or y right</span>
          <span class="c1"># NB &#39;x&#39; will not always match the lowest sorting - it fails for</span>
          <span class="c1"># ordinary HB2/HB3 methylenes and must be caught later</span>
          <span class="c1"># But the crucial isopropyl and aromatic cases should work</span>
          <span class="n">newChar</span> <span class="o">=</span> <span class="bp">None</span>
          <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">resonanceName</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">char</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
              <span class="k">break</span>
          <span class="k">else</span><span class="p">:</span>
            <span class="n">char</span> <span class="o">=</span> <span class="bp">None</span>
          <span class="k">if</span> <span class="n">assignNames</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">lenPrefix</span><span class="p">]</span> <span class="o">==</span> <span class="n">char</span><span class="p">:</span>
            <span class="n">newChar</span> <span class="o">=</span> <span class="s1">&#39;x&#39;</span>
          <span class="k">elif</span> <span class="n">assignNames</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">lenPrefix</span><span class="p">]</span> <span class="o">==</span> <span class="n">char</span><span class="p">:</span>
            <span class="n">newChar</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span>
          <span class="k">elif</span> <span class="s1">&#39;a&#39;</span> <span class="ow">in</span> <span class="n">resonanceName</span> <span class="ow">and</span> <span class="ow">not</span> <span class="s1">&#39;b&#39;</span> <span class="ow">in</span> <span class="n">resonanceName</span><span class="p">:</span>
            <span class="n">newChar</span> <span class="o">=</span> <span class="s1">&#39;x&#39;</span>
          <span class="k">elif</span> <span class="s1">&#39;b&#39;</span> <span class="ow">in</span> <span class="n">resonanceName</span> <span class="ow">and</span> <span class="ow">not</span> <span class="s1">&#39;a&#39;</span> <span class="ow">in</span> <span class="n">resonanceName</span><span class="p">:</span>
            <span class="n">newChar</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span>

          <span class="k">if</span> <span class="n">newChar</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">ll</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">assignNames</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">ll</span><span class="p">[</span><span class="n">lenPrefix</span><span class="p">]</span> <span class="o">=</span> <span class="n">newChar</span>
            <span class="n">result</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">ll</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="s1">&#39;%&#39;</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
    <span class="c1"># If we are still here, assignNames did not help. Use resonanceName only</span>

    <span class="k">if</span> <span class="n">resonanceName</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">elementCode</span> <span class="ow">and</span> <span class="n">resonanceName</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">elementCode</span><span class="p">):</span>
        <span class="c1"># name is OK except possibly for casing - fix the casing</span>
        <span class="n">ss</span> <span class="o">=</span> <span class="n">resonanceName</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">elementCode</span><span class="p">):]</span>

        <span class="k">if</span> <span class="s1">&#39;x&#39;</span> <span class="ow">in</span> <span class="n">ss</span> <span class="ow">or</span> <span class="s1">&#39;y&#39;</span> <span class="ow">in</span> <span class="n">ss</span><span class="p">:</span>
          <span class="c1"># Necessary to avoid potential clashes with XY names set above</span>
          <span class="c1"># No actual assigned names contain &#39;x&#39; or &#39;y&#39; anyway</span>
          <span class="n">result</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">@</span><span class="si">%s</span><span class="s1">-</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">elementCode</span><span class="p">,</span> <span class="n">resonance</span><span class="o">.</span><span class="n">serial</span><span class="p">,</span> <span class="n">resonanceName</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="c1"># Name might be proper assignment name. Change to new wildcard convention</span>
         <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">elementCode</span> <span class="o">+</span> <span class="n">ss</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="s1">&#39;%&#39;</span><span class="p">)</span>

      <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Set unique default name</span>
        <span class="n">result</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">@</span><span class="si">%s</span><span class="s1">-</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">elementCode</span><span class="p">,</span> <span class="n">resonance</span><span class="o">.</span><span class="n">serial</span><span class="p">,</span> <span class="n">resonanceName</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">resonance</span><span class="p">,</span> <span class="s1">&#39;resonanceSerial&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">resonance</span><span class="o">.</span><span class="n">resonanceSerial</span><span class="p">:</span>
      <span class="n">result</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">@</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">elementCode</span><span class="p">,</span> <span class="n">resonance</span><span class="o">.</span><span class="n">resonanceSerial</span><span class="p">)</span>


    <span class="k">else</span><span class="p">:</span>
      <span class="n">result</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">@</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">elementCode</span><span class="p">,</span> <span class="n">resonance</span><span class="o">.</span><span class="n">serial</span><span class="p">)</span>
  <span class="c1">#</span>
  <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="upgradeConstraintList"><a class="viewcode-back" href="../../../../ccpnmodel/ccpnmodel.ccpncore.lib.html#ccpnmodel.ccpncore.lib.V2Upgrade.upgradeConstraintList">[docs]</a><span class="k">def</span> <span class="nf">upgradeConstraintList</span><span class="p">(</span><span class="n">constraintList</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Upgrade ConstraintList from early V3 to newer V3 - this avoids redoing earlier function</span>
<span class="sd">  and anyway data must be copied to a new set of objects</span>

<span class="sd">  Will also work if called on old-type V3 ConstraintLists (use only internally)&quot;&quot;&quot;</span>

  <span class="n">constraintStore</span> <span class="o">=</span> <span class="n">constraintList</span><span class="o">.</span><span class="n">nmrConstraintStore</span>

  <span class="c1"># Get defining parameters</span>
  <span class="n">className</span> <span class="o">=</span> <span class="n">constraintList</span><span class="o">.</span><span class="n">className</span>
  <span class="n">restraintType</span> <span class="o">=</span> <span class="n">className</span><span class="p">[:</span><span class="o">-</span><span class="mi">14</span><span class="p">]</span>

  <span class="k">if</span> <span class="n">restraintType</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;Distance&#39;</span><span class="p">,</span> <span class="s1">&#39;HBond&#39;</span><span class="p">,</span> <span class="s1">&#39;JCoupling&#39;</span><span class="p">,</span> <span class="s1">&#39;Rdc&#39;</span><span class="p">,):</span>
    <span class="n">itemLength</span> <span class="o">=</span> <span class="mi">2</span>
  <span class="k">elif</span> <span class="n">restraintType</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;Csa&#39;</span><span class="p">,</span> <span class="s1">&#39;ChemicalShift&#39;</span><span class="p">):</span>
    <span class="n">itemLength</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="k">elif</span> <span class="n">restraintType</span> <span class="o">==</span> <span class="s1">&#39;Dihedral&#39;</span><span class="p">:</span>
    <span class="n">itemLength</span> <span class="o">=</span> <span class="mi">4</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Restraint list named </span><span class="si">%s</span><span class="s2"> not recognized by code (BUG2?)&quot;</span> <span class="o">%</span> <span class="n">className</span><span class="p">)</span>

  <span class="c1"># Make new ConstraintList</span>
  <span class="n">params</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;constraintType&#39;</span><span class="p">:</span><span class="n">restraintType</span><span class="p">,</span> <span class="s1">&#39;itemLength&#39;</span><span class="p">:</span><span class="n">itemLength</span><span class="p">}</span>
  <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;details&#39;</span><span class="p">,</span> <span class="s1">&#39;potentialType&#39;</span><span class="p">,</span> <span class="s1">&#39;unit&#39;</span><span class="p">,</span> <span class="s1">&#39;usedForCalculation&#39;</span><span class="p">,</span> <span class="s1">&#39;experimentSerial&#39;</span><span class="p">,</span>
              <span class="s1">&#39;measureListSerial&#39;</span><span class="p">,</span> <span class="s1">&#39;origin&#39;</span><span class="p">,</span> <span class="s1">&#39;tensorIsotropicValue&#39;</span><span class="p">,</span> <span class="s1">&#39;tensorMagnitude&#39;</span><span class="p">,</span>
              <span class="s1">&#39;tensorRhombicity&#39;</span><span class="p">,</span> <span class="s1">&#39;tensorChainCode&#39;</span><span class="p">,</span> <span class="s1">&#39;tensorSequenceCode&#39;</span><span class="p">,</span> <span class="s1">&#39;tensorResidueType&#39;</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">constraintList</span><span class="p">,</span> <span class="n">tag</span><span class="p">):</span>
      <span class="n">val</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">constraintList</span><span class="p">,</span> <span class="n">tag</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">params</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">constraintList</span><span class="p">,</span> <span class="n">tag</span><span class="p">)</span>
  <span class="c1"># RESETS:</span>
  <span class="c1"># reset name to unique string, to free the name to give to new ConstraintList:</span>
  <span class="n">constraintList</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;@@@</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">constraintList</span><span class="o">.</span><span class="n">serial</span>
  <span class="k">if</span> <span class="n">restraintType</span> <span class="o">==</span> <span class="s1">&#39;HBond&#39;</span><span class="p">:</span>
    <span class="c1"># RESET: HBond lists are type &#39;Distance&#39; origin &#39;hbond&#39;</span>
    <span class="n">restraintType</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;constraintType&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Distance&#39;</span>
    <span class="n">params</span><span class="p">[</span><span class="s1">&#39;origin&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;hbond&#39;</span>

  <span class="n">newList</span> <span class="o">=</span> <span class="n">constraintStore</span><span class="o">.</span><span class="n">newGenericConstraintList</span><span class="p">(</span><span class="o">**</span><span class="n">params</span><span class="p">)</span>

  <span class="n">constraintStore</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">override</span> <span class="o">=</span> <span class="bp">True</span>
  <span class="n">constraintTags</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;serial&#39;</span><span class="p">,</span> <span class="s1">&#39;origData&#39;</span><span class="p">,</span> <span class="s1">&#39;details&#39;</span><span class="p">)</span>
  <span class="n">contributionTags</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;serial&#39;</span><span class="p">,</span> <span class="s1">&#39;weight&#39;</span><span class="p">,</span> <span class="s1">&#39;targetValue&#39;</span><span class="p">,</span> <span class="s1">&#39;error&#39;</span><span class="p">,</span>
                      <span class="s1">&#39;upperLimit&#39;</span><span class="p">,</span> <span class="s1">&#39;lowerLimit&#39;</span><span class="p">,</span> <span class="s1">&#39;additionalUpperLimit&#39;</span><span class="p">,</span> <span class="s1">&#39;additionalLowerLimit&#39;</span><span class="p">,</span>
                      <span class="s1">&#39;combinationId&#39;</span><span class="p">,</span> <span class="p">)</span>
  <span class="n">contributionTags2</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;scale&#39;</span><span class="p">,</span> <span class="s1">&#39;isDistanceDependent&#39;</span><span class="p">)</span>
  <span class="k">try</span><span class="p">:</span>

    <span class="k">for</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="n">constraintList</span><span class="o">.</span><span class="n">sortedConstraints</span><span class="p">():</span>
      <span class="c1"># Make new Constraint</span>
      <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>
      <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">constraintTags</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">constraint</span><span class="p">,</span> <span class="n">tag</span><span class="p">):</span>
          <span class="n">val</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">constraint</span><span class="p">,</span> <span class="n">tag</span><span class="p">)</span>
          <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
      <span class="c1"># params = {tag:getattr(constraint,tag) for tag in constraintTags}</span>
      <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">constraint</span><span class="p">,</span> <span class="s1">&#39;vectorLength&#39;</span><span class="p">):</span>
        <span class="n">params</span><span class="p">[</span><span class="s1">&#39;vectorLength&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">constraint</span><span class="o">.</span><span class="n">vectorLength</span>
      <span class="n">newConstraint</span> <span class="o">=</span> <span class="n">newList</span><span class="o">.</span><span class="n">newGenericConstraint</span><span class="p">(</span><span class="o">**</span><span class="n">params</span><span class="p">)</span>

      <span class="k">for</span> <span class="n">peakContrib</span> <span class="ow">in</span> <span class="n">constraint</span><span class="o">.</span><span class="n">sortedPeakContribs</span><span class="p">():</span>
        <span class="n">dd</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;experimentSerial&#39;</span><span class="p">,</span> <span class="s1">&#39;dataSourceSerial&#39;</span><span class="p">,</span> <span class="s1">&#39;peakListSerial&#39;</span><span class="p">,</span> <span class="s1">&#39;peakSerial&#39;</span><span class="p">):</span>
          <span class="n">dd</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">peakContrib</span><span class="p">,</span> <span class="n">tag</span><span class="p">)</span>
        <span class="n">newConstraint</span><span class="o">.</span><span class="n">newConstraintPeakContrib</span><span class="p">(</span><span class="o">**</span><span class="n">dd</span><span class="p">)</span>

      <span class="k">for</span> <span class="n">contribution</span> <span class="ow">in</span> <span class="n">constraint</span><span class="o">.</span><span class="n">sortedContributions</span><span class="p">():</span>
        <span class="c1"># Make new Contribution</span>
        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">contributionTags</span> <span class="o">+</span> <span class="n">contributionTags2</span><span class="p">:</span>
          <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">contribution</span><span class="p">,</span> <span class="n">tag</span><span class="p">):</span>
            <span class="n">val</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">contribution</span><span class="p">,</span> <span class="n">tag</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
              <span class="n">params</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="c1"># params = {tag:getattr(contribution,tag) for tag in contributionTags}</span>
        <span class="c1"># for tag in contributionTags2:</span>
        <span class="c1">#   if hasattr(contribution, tag):</span>
        <span class="c1">#     params[tag] = getattr(contribution, tag)</span>
        <span class="n">newContribution</span> <span class="o">=</span> <span class="n">newConstraint</span><span class="o">.</span><span class="n">newGenericContribution</span><span class="p">(</span><span class="o">**</span><span class="n">params</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">contribution</span><span class="o">.</span><span class="n">items</span><span class="p">:</span>
        <span class="c1"># Make new Item</span>
          <span class="k">if</span> <span class="n">itemLength</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">newContribution</span><span class="o">.</span><span class="n">newSingleAtomItem</span><span class="p">(</span><span class="n">resonance</span><span class="o">=</span><span class="n">item</span><span class="o">.</span><span class="n">resonance</span><span class="p">)</span>
          <span class="k">elif</span> <span class="n">itemLength</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">newContribution</span><span class="o">.</span><span class="n">newFourAtomItem</span><span class="p">(</span><span class="n">resonances</span><span class="o">=</span><span class="n">item</span><span class="o">.</span><span class="n">resonances</span><span class="p">)</span>
          <span class="k">else</span><span class="p">:</span>
            <span class="c1"># assert itemLength == 2</span>
            <span class="n">newContribution</span><span class="o">.</span><span class="n">newAtomPairItem</span><span class="p">(</span><span class="n">resonances</span><span class="o">=</span><span class="n">item</span><span class="o">.</span><span class="n">resonances</span><span class="p">)</span>

    <span class="c1"># delete old list and copy across serial</span>
    <span class="n">serial</span> <span class="o">=</span> <span class="n">constraintList</span><span class="o">.</span><span class="n">serial</span>
    <span class="n">tempSerial</span> <span class="o">=</span> <span class="n">newList</span><span class="o">.</span><span class="n">serial</span>
    <span class="n">constraintList</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
    <span class="n">newList</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="s1">&#39;serial&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">serial</span>
    <span class="n">constraintStore</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="s1">&#39;constraintLists&#39;</span><span class="p">][</span><span class="n">serial</span><span class="p">]</span> <span class="o">=</span> <span class="n">newList</span>
    <span class="k">del</span> <span class="n">constraintStore</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="s1">&#39;constraintLists&#39;</span><span class="p">][</span><span class="n">tempSerial</span><span class="p">]</span>
    <span class="n">constraintStore</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="s1">&#39;_serialDict&#39;</span><span class="p">][</span><span class="s1">&#39;constraintLists&#39;</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
  <span class="k">finally</span><span class="p">:</span>
    <span class="n">constraintStore</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">override</span> <span class="o">=</span> <span class="bp">False</span></div>



<div class="viewcode-block" id="findSpinSystemStretch"><a class="viewcode-back" href="../../../../ccpnmodel/ccpnmodel.ccpncore.lib.html#ccpnmodel.ccpncore.lib.V2Upgrade.findSpinSystemStretch">[docs]</a><span class="k">def</span> <span class="nf">findSpinSystemStretch</span><span class="p">(</span><span class="n">resonanceGroup</span><span class="p">,</span> <span class="n">excludedSpinSystems</span><span class="o">=</span><span class="nb">set</span><span class="p">()):</span>
  <span class="sd">&quot;&quot;&quot;Find (one of the) longest sequential spin system stretch(es) containing resonanceGroup</span>
<span class="sd">  &quot;&quot;&quot;</span>

  <span class="c1"># To avoid modifying external data</span>
  <span class="n">excludedSpinSystems</span> <span class="o">=</span> <span class="n">excludedSpinSystems</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
  <span class="n">excludedSpinSystems</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">resonanceGroup</span><span class="p">)</span>

  <span class="n">stretches</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="k">for</span> <span class="n">delta</span> <span class="ow">in</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="p">[</span><span class="n">resonanceGroup</span><span class="p">]</span>
    <span class="n">dd</span> <span class="o">=</span> <span class="p">{</span><span class="n">resonanceGroup</span><span class="p">:[]}</span>
    <span class="k">for</span> <span class="n">rg</span> <span class="ow">in</span> <span class="n">queue</span><span class="p">:</span>
      <span class="n">ll</span> <span class="o">=</span> <span class="n">dd</span><span class="p">[</span><span class="n">rg</span><span class="p">]</span>
      <span class="k">for</span> <span class="n">rg2</span> <span class="ow">in</span> <span class="n">findConnectedSpinSystems</span><span class="p">(</span><span class="n">rg</span><span class="p">,</span> <span class="n">delta</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">rg2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">excludedSpinSystems</span><span class="p">:</span>
          <span class="n">excludedSpinSystems</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">rg2</span><span class="p">)</span>
          <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rg2</span><span class="p">)</span>
          <span class="n">ll2</span> <span class="o">=</span> <span class="n">dd</span><span class="p">[</span><span class="n">rg2</span><span class="p">]</span> <span class="o">=</span> <span class="n">ll</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
          <span class="n">ll2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rg2</span><span class="p">)</span>

    <span class="n">stretch</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">ll3</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">dd</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ll3</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">stretch</span><span class="p">):</span>
        <span class="n">stretch</span> <span class="o">=</span> <span class="n">ll3</span>
    <span class="c1">#</span>
    <span class="n">stretches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stretch</span><span class="p">)</span>
  <span class="c1">#</span>
  <span class="n">result</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">stretches</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">+</span> <span class="p">[</span><span class="n">resonanceGroup</span><span class="p">]</span> <span class="o">+</span> <span class="n">stretches</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
  <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="getSeqSpinSystemLinks"><a class="viewcode-back" href="../../../../ccpnmodel/ccpnmodel.ccpncore.lib.html#ccpnmodel.ccpncore.lib.V2Upgrade.getSeqSpinSystemLinks">[docs]</a><span class="k">def</span> <span class="nf">getSeqSpinSystemLinks</span><span class="p">(</span><span class="n">spinSystem</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Get any sequential spin system links (resonanceGroupProbs).</span>
<span class="sd">  An optional sequence offset may be specified.</span>

<span class="sd">  .. describe:: Input</span>

<span class="sd">  Nmr.ResonanceGroup, Int</span>

<span class="sd">  .. describe:: Output</span>

<span class="sd">  List of Nmr.ResonanceGroupProbs</span>
<span class="sd">  &quot;&quot;&quot;</span>

  <span class="n">seqLinks</span> <span class="o">=</span> <span class="p">{}</span>
  <span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="n">spinSystem</span><span class="o">.</span><span class="n">findAllResonanceGroupProbs</span><span class="p">(</span><span class="n">linkType</span><span class="o">=</span><span class="s1">&#39;sequential&#39;</span><span class="p">,</span> <span class="n">isSelected</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">delta</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
      <span class="n">seqLinks</span><span class="p">[</span><span class="n">link</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">elif</span> <span class="n">link</span><span class="o">.</span><span class="n">sequenceOffset</span> <span class="o">==</span> <span class="n">delta</span><span class="p">:</span>
      <span class="n">seqLinks</span><span class="p">[</span><span class="n">link</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>

  <span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="n">spinSystem</span><span class="o">.</span><span class="n">findAllFromResonanceGroups</span><span class="p">(</span><span class="n">linkType</span><span class="o">=</span><span class="s1">&#39;sequential&#39;</span><span class="p">,</span> <span class="n">isSelected</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">delta</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
      <span class="n">seqLinks</span><span class="p">[</span><span class="n">link</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">elif</span> <span class="n">link</span><span class="o">.</span><span class="n">sequenceOffset</span> <span class="o">==</span> <span class="o">-</span><span class="n">delta</span><span class="p">:</span>
      <span class="n">seqLinks</span><span class="p">[</span><span class="n">link</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>

  <span class="k">return</span> <span class="n">seqLinks</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span></div>


<div class="viewcode-block" id="findConnectedSpinSystems"><a class="viewcode-back" href="../../../../ccpnmodel/ccpnmodel.ccpncore.lib.html#ccpnmodel.ccpncore.lib.V2Upgrade.findConnectedSpinSystems">[docs]</a><span class="k">def</span> <span class="nf">findConnectedSpinSystems</span><span class="p">(</span><span class="n">spinSystem</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Find spin systems sequentially connected to the input one with given sequence offset.</span>

<span class="sd">  .. describe:: Input</span>

<span class="sd">  Nmr.ResonanceGroup, Int</span>
<span class="sd">  .. describe:: Output</span>

<span class="sd">  Nmr.ResonanceGroup</span>
<span class="sd">  &quot;&quot;&quot;</span>

  <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="n">getSeqSpinSystemLinks</span><span class="p">(</span><span class="n">spinSystem</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="n">delta</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">spinSystem</span> <span class="ow">is</span> <span class="n">link</span><span class="o">.</span><span class="n">parent</span><span class="p">:</span>
      <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">link</span><span class="o">.</span><span class="n">possibility</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">link</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
  <span class="c1">#</span>
  <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="findIdentityResonanceGroup"><a class="viewcode-back" href="../../../../ccpnmodel/ccpnmodel.ccpncore.lib.html#ccpnmodel.ccpncore.lib.V2Upgrade.findIdentityResonanceGroup">[docs]</a><span class="k">def</span>  <span class="nf">findIdentityResonanceGroup</span><span class="p">(</span><span class="n">resonanceGroup</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;V2: find unique resonanceGroup linked as identical to teh input&quot;&quot;&quot;</span>
  <span class="n">ll</span> <span class="o">=</span> <span class="n">resonanceGroup</span><span class="o">.</span><span class="n">findAllResonanceGroupProbs</span><span class="p">(</span><span class="n">linkType</span><span class="o">=</span><span class="s1">&#39;identity&#39;</span><span class="p">,</span>
                                                  <span class="n">isSelected</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
  <span class="n">identicals</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">possibility</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ll</span><span class="p">)</span>
  <span class="n">ll2</span> <span class="o">=</span> <span class="n">resonanceGroup</span><span class="o">.</span><span class="n">findAllFromResonanceGroups</span><span class="p">(</span><span class="n">linkType</span><span class="o">=</span><span class="s1">&#39;identity&#39;</span><span class="p">,</span>
                                                  <span class="n">isSelected</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
  <span class="n">identicals</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">parent</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ll2</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">identicals</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">identicals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="bp">None</span></div>

<span class="k">def</span> <span class="nf">_getAmbigProchiralLabel</span><span class="p">(</span><span class="n">resonance</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  V2: Deterimine if an ambigous prochiral resonance (non-stereospecifically assigned)</span>
<span class="sd">  Has an &quot;a&quot; label or a &quot;b&quot; label. &quot;a&quot; is reserved for the upfield proton and any</span>
<span class="sd">  other nulceus bound to it.</span>

<span class="sd">  .. describe:: Input</span>

<span class="sd">  Nmr.Resonance</span>

<span class="sd">  .. describe:: Output</span>

<span class="sd">  Character</span>
<span class="sd">  &quot;&quot;&quot;</span>

  <span class="n">letter</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
  <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">resonance</span><span class="p">,</span> <span class="s1">&#39;onebond&#39;</span><span class="p">):</span>
    <span class="k">del</span> <span class="n">resonance</span><span class="o">.</span><span class="n">onebond</span>

  <span class="n">resonanceSet</span> <span class="o">=</span> <span class="n">resonance</span><span class="o">.</span><span class="n">resonanceSet</span>

  <span class="k">if</span> <span class="n">resonanceSet</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">resonance</span><span class="o">.</span><span class="n">isotopeCode</span> <span class="o">==</span> <span class="s1">&#39;1H&#39;</span><span class="p">:</span>
      <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="k">for</span> <span class="n">resonance2</span> <span class="ow">in</span> <span class="n">resonanceSet</span><span class="o">.</span><span class="n">sortedResonances</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">resonance2</span><span class="o">.</span><span class="n">shifts</span><span class="p">:</span>
          <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span><span class="n">resonance2</span><span class="o">.</span><span class="n">findFirstShift</span><span class="p">()</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">resonance2</span><span class="o">.</span><span class="n">serial</span><span class="p">,</span> <span class="n">resonance2</span><span class="p">)</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span><span class="mf">999999.999</span><span class="p">,</span> <span class="n">resonance2</span><span class="o">.</span><span class="n">serial</span><span class="p">,</span> <span class="n">resonance2</span><span class="p">)</span> <span class="p">)</span>

      <span class="n">data</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
      <span class="n">resonances</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">data</span><span class="p">]</span>
      <span class="n">i</span> <span class="o">=</span> <span class="n">resonances</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">resonance</span><span class="p">)</span>
      <span class="n">letter</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span><span class="o">+</span><span class="n">i</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
      <span class="n">resonance2</span> <span class="o">=</span> <span class="n">_getOnebondResonance</span><span class="p">(</span><span class="n">resonance</span><span class="p">,</span> <span class="n">isotopeCode</span><span class="o">=</span><span class="s1">&#39;1H&#39;</span><span class="p">)</span>

      <span class="k">if</span> <span class="n">resonance2</span> <span class="ow">and</span> <span class="n">resonance2</span><span class="o">.</span><span class="n">resonanceSet</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">resonance2</span><span class="o">.</span><span class="n">resonanceSet</span><span class="o">.</span><span class="n">atomSets</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">letter</span> <span class="o">=</span> <span class="n">_getAmbigProchiralLabel</span><span class="p">(</span><span class="n">resonance2</span><span class="p">)</span>
        <span class="n">resonance2</span><span class="o">.</span><span class="n">onebond</span> <span class="o">=</span> <span class="n">resonance</span>

      <span class="k">elif</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">resonanceSet</span><span class="o">.</span><span class="n">resonances</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">resonanceSet</span><span class="o">.</span><span class="n">atomSets</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">resonance2</span> <span class="ow">in</span> <span class="n">resonanceSet</span><span class="o">.</span><span class="n">resonances</span><span class="p">:</span>
          <span class="k">if</span> <span class="n">resonance2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">resonance</span><span class="p">:</span>
            <span class="n">resonance3</span> <span class="o">=</span> <span class="n">_getOnebondResonance</span><span class="p">(</span><span class="n">resonance2</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">resonance3</span> <span class="ow">and</span> <span class="n">resonance3</span><span class="o">.</span><span class="n">resonanceSet</span>
                <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">resonance3</span><span class="o">.</span><span class="n">resonanceSet</span><span class="o">.</span><span class="n">atomSets</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)):</span>
              <span class="n">letter</span> <span class="o">=</span> <span class="s1">&#39;b&#39;</span>
            <span class="k">break</span>

      <span class="k">if</span> <span class="ow">not</span> <span class="n">letter</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">resonance2</span> <span class="ow">in</span> <span class="n">resonanceSet</span><span class="o">.</span><span class="n">resonances</span><span class="p">:</span>
          <span class="k">if</span> <span class="n">resonance2</span><span class="o">.</span><span class="n">shifts</span><span class="p">:</span>
            <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span><span class="n">resonance2</span><span class="o">.</span><span class="n">findFirstShift</span><span class="p">()</span><span class="o">.</span><span class="n">value</span><span class="p">,</span><span class="n">resonance2</span><span class="p">)</span> <span class="p">)</span>
          <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span><span class="n">resonance2</span><span class="o">.</span><span class="n">serial</span><span class="p">,</span><span class="n">resonance2</span><span class="p">)</span> <span class="p">)</span>

        <span class="n">data</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="n">resonances</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">data</span><span class="p">]</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">resonances</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">resonance</span><span class="p">)</span>
        <span class="n">letter</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span><span class="o">+</span><span class="n">i</span><span class="p">)</span>

  <span class="c1">#keyword = &#39;ambigProchiralLabel&#39;</span>
  <span class="c1">#appData = resonance.findFirstApplicationData(application=app, keyword=keyword)</span>
  <span class="c1">#</span>
  <span class="c1">#if appData and (appData.value != letter):</span>
  <span class="c1">#  appData.delete()</span>
  <span class="c1">#  appData = None</span>
  <span class="c1">#</span>
  <span class="c1">#if not appData:</span>
  <span class="c1">#  AppDataString(resonance,application=app,keyword=keyword, value=letter)</span>

  <span class="k">return</span> <span class="n">letter</span>


<span class="k">def</span> <span class="nf">_getOnebondResonance</span><span class="p">(</span><span class="n">resonance</span><span class="p">,</span> <span class="n">isotopeCode</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  V2: Find any resonance that may have a single bond connection to the input resonance</span>
<span class="sd">  Option to specify the isotope type</span>

<span class="sd">  .. describe:: Input</span>

<span class="sd">  Nmr.Resonance, Nmr.Resonance.isotopeCode</span>

<span class="sd">  .. describe:: Output</span>

<span class="sd">  Nmr.Resonance</span>
<span class="sd">  &quot;&quot;&quot;</span>

  <span class="n">resonances</span> <span class="o">=</span> <span class="n">_getBoundResonances</span><span class="p">(</span><span class="n">resonance</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">resonances</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">isotopeCode</span><span class="p">:</span>
      <span class="k">for</span> <span class="n">resonance1</span> <span class="ow">in</span> <span class="n">resonances</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">resonance1</span><span class="o">.</span><span class="n">isotopeCode</span> <span class="o">==</span> <span class="n">isotopeCode</span><span class="p">:</span>
          <span class="k">return</span> <span class="n">resonance1</span>

    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">resonances</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

  <span class="n">resonance2</span> <span class="o">=</span> <span class="bp">None</span>

  <span class="k">for</span> <span class="n">contrib</span> <span class="ow">in</span> <span class="n">resonance</span><span class="o">.</span><span class="n">peakDimContribs</span><span class="p">:</span>
    <span class="n">peakDim</span>      <span class="o">=</span> <span class="n">contrib</span><span class="o">.</span><span class="n">peakDim</span>
    <span class="n">expDimRef1</span>   <span class="o">=</span> <span class="n">peakDim</span><span class="o">.</span><span class="n">dataDimRef</span><span class="o">.</span><span class="n">expDimRef</span>
    <span class="n">expTransfers</span> <span class="o">=</span> <span class="n">expDimRef1</span><span class="o">.</span><span class="n">expTransfers</span>

    <span class="k">for</span> <span class="n">expTransfer</span> <span class="ow">in</span> <span class="n">expTransfers</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">expTransfer</span><span class="o">.</span><span class="n">transferType</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;onebond&#39;</span><span class="p">,</span><span class="s1">&#39;CP&#39;</span><span class="p">):</span>
        <span class="n">expDimRef2</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="k">for</span> <span class="n">expDimRef</span> <span class="ow">in</span> <span class="n">expTransfer</span><span class="o">.</span><span class="n">expDimRefs</span><span class="p">:</span>
          <span class="k">if</span> <span class="n">expDimRef</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">expDimRef1</span><span class="p">:</span>
            <span class="n">expDimRef2</span> <span class="o">=</span> <span class="n">expDimRef</span>
            <span class="k">break</span>

        <span class="k">if</span> <span class="n">expDimRef2</span><span class="p">:</span>
          <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">isotopeCode</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">isotopeCode</span> <span class="ow">in</span> <span class="n">expDimRef2</span><span class="o">.</span><span class="n">isotopeCodes</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">peakDim2</span> <span class="ow">in</span> <span class="n">peakDim</span><span class="o">.</span><span class="n">peak</span><span class="o">.</span><span class="n">peakDims</span><span class="p">:</span>
              <span class="k">if</span> <span class="n">peakDim2</span><span class="o">.</span><span class="n">dataDimRef</span> <span class="ow">and</span> <span class="p">(</span><span class="n">peakDim2</span><span class="o">.</span><span class="n">dataDimRef</span><span class="o">.</span><span class="n">expDimRef</span> <span class="ow">is</span> <span class="n">expDimRef2</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">contrib2</span> <span class="ow">in</span> <span class="n">peakDim2</span><span class="o">.</span><span class="n">peakDimContribs</span><span class="p">:</span>
                  <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">isotopeCode</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">contrib2</span><span class="o">.</span><span class="n">resonance</span><span class="o">.</span><span class="n">isotopeCode</span> <span class="o">==</span> <span class="n">isotopeCode</span><span class="p">):</span>
                    <span class="n">resonance2</span> <span class="o">=</span> <span class="n">contrib2</span><span class="o">.</span><span class="n">resonance</span>

                <span class="k">break</span>

    <span class="k">if</span> <span class="n">resonance2</span><span class="p">:</span>
      <span class="k">break</span>

  <span class="k">return</span> <span class="n">resonance2</span>



<span class="k">def</span> <span class="nf">_getBoundResonances</span><span class="p">(</span><span class="n">resonance</span><span class="p">,</span> <span class="n">recalculate</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">contribs</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">recursiveCall</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  V2: Find all resonances that have a single bond connection to the input resonance</span>
<span class="sd">  Option to recalculate given assignment status (e.g. if something changes)</span>
<span class="sd">  Option to specify peakDimContribs to search</span>

<span class="sd">  .. describe:: Input</span>

<span class="sd">  Nmr.Resonance, Boolean, List of Nmr.PeakDimContribs</span>

<span class="sd">  .. describe:: Output</span>

<span class="sd">  List of Nmr.Resonances</span>
<span class="sd">  &quot;&quot;&quot;</span>

  <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">recalculate</span><span class="p">)</span> <span class="ow">and</span> <span class="n">resonance</span><span class="o">.</span><span class="n">covalentlyBound</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">resonance</span><span class="o">.</span><span class="n">covalentlyBound</span><span class="p">)</span>

  <span class="n">resonances</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span> <span class="c1"># Linked by bound atoms irrespective of spectra</span>
  <span class="n">pairResonances</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span> <span class="c1"># prochiral or other pairs that can not be determined imemdiately</span>
  <span class="n">resonanceSet</span>   <span class="o">=</span> <span class="n">resonance</span><span class="o">.</span><span class="n">resonanceSet</span>

  <span class="n">funnyResonances</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

  <span class="k">if</span> <span class="n">resonanceSet</span><span class="p">:</span>
    <span class="c1">#residue  = resonanceSet.findFirstAtomSet().findFirstAtom().residue</span>
    <span class="n">atomSets</span> <span class="o">=</span> <span class="n">resonanceSet</span><span class="o">.</span><span class="n">atomSets</span>

    <span class="k">for</span> <span class="n">atomSet</span> <span class="ow">in</span> <span class="n">atomSets</span><span class="p">:</span>
      <span class="c1">#for atom in atomSet.atoms:</span>
      <span class="n">atom</span> <span class="o">=</span> <span class="n">atomSet</span><span class="o">.</span><span class="n">findFirstAtom</span><span class="p">()</span>

      <span class="k">for</span> <span class="n">atom2</span> <span class="ow">in</span> <span class="n">_getBoundAtoms</span><span class="p">(</span><span class="n">atom</span><span class="p">):</span>
        <span class="n">atomSet2</span> <span class="o">=</span> <span class="n">atom2</span><span class="o">.</span><span class="n">atomSet</span>

        <span class="k">if</span> <span class="n">atomSet2</span> <span class="ow">and</span> <span class="n">atomSet2</span><span class="o">.</span><span class="n">resonanceSets</span><span class="p">:</span>

          <span class="n">usePaired</span> <span class="o">=</span> <span class="bp">False</span>
          <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">atomSets</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">chemAtomSet</span> <span class="o">=</span> <span class="n">atom2</span><span class="o">.</span><span class="n">chemAtom</span><span class="o">.</span><span class="n">chemAtomSet</span>
            <span class="k">if</span> <span class="n">chemAtomSet</span><span class="p">:</span>
              <span class="n">usePaired</span> <span class="o">=</span> <span class="p">(</span><span class="n">chemAtomSet</span><span class="o">.</span><span class="n">isProchiral</span> <span class="ow">or</span>
                           <span class="p">(</span><span class="n">chemAtomSet</span><span class="o">.</span><span class="n">chemAtomSet</span> <span class="ow">and</span> <span class="n">chemAtomSet</span><span class="o">.</span><span class="n">chemAtomSet</span><span class="o">.</span><span class="n">isProchiral</span><span class="p">))</span>

          <span class="k">for</span> <span class="n">resonanceSet2</span> <span class="ow">in</span> <span class="n">atomSet2</span><span class="o">.</span><span class="n">resonanceSets</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">resonance2</span> <span class="ow">in</span> <span class="n">resonanceSet2</span><span class="o">.</span><span class="n">resonances</span><span class="p">:</span>
              <span class="k">if</span> <span class="n">resonance2</span> <span class="ow">is</span> <span class="n">resonance</span><span class="p">:</span> <span class="c1"># should not happen</span>
                <span class="k">if</span> <span class="n">resonance</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">funnyResonances</span><span class="p">:</span>
                  <span class="n">resonance</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span> <span class="s1">&#39;in _getBoundResonances():&#39;</span>
                                                  <span class="s1">&#39;resonance </span><span class="si">%d</span><span class="s1"> tried to be linked to itself&#39;</span>
                                                  <span class="o">%</span> <span class="n">resonance</span><span class="o">.</span><span class="n">serial</span><span class="p">)</span>
                  <span class="n">funnyResonances</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">resonance</span><span class="p">)</span>
              <span class="k">elif</span> <span class="n">usePaired</span><span class="p">:</span>
                <span class="n">pairResonances</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">resonance2</span><span class="p">)</span>
              <span class="k">else</span><span class="p">:</span>
                <span class="n">resonances</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">resonance2</span><span class="p">)</span>

  <span class="k">if</span> <span class="ow">not</span> <span class="n">contribs</span><span class="p">:</span>
    <span class="n">contribs</span> <span class="o">=</span> <span class="n">resonance</span><span class="o">.</span><span class="n">peakDimContribs</span>

  <span class="n">expResonances</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
  <span class="n">foundBothPaired</span> <span class="o">=</span> <span class="bp">False</span>
  <span class="k">for</span> <span class="n">contrib</span> <span class="ow">in</span> <span class="n">contribs</span><span class="p">:</span>
    <span class="n">peakDim</span>      <span class="o">=</span> <span class="n">contrib</span><span class="o">.</span><span class="n">peakDim</span>
    <span class="n">expDimRef1</span>   <span class="o">=</span> <span class="n">peakDim</span><span class="o">.</span><span class="n">dataDimRef</span><span class="o">.</span><span class="n">expDimRef</span>
    <span class="n">expTransfers</span> <span class="o">=</span> <span class="n">expDimRef1</span><span class="o">.</span><span class="n">expTransfers</span>

    <span class="k">for</span> <span class="n">expTransfer</span> <span class="ow">in</span> <span class="n">expTransfers</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">expTransfer</span><span class="o">.</span><span class="n">transferType</span> <span class="o">==</span> <span class="s1">&#39;onebond&#39;</span><span class="p">:</span>
        <span class="n">expDimRef2</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="k">for</span> <span class="n">expDimRef</span> <span class="ow">in</span> <span class="n">expTransfer</span><span class="o">.</span><span class="n">expDimRefs</span><span class="p">:</span>
          <span class="k">if</span> <span class="n">expDimRef</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">expDimRef1</span><span class="p">:</span>
            <span class="n">expDimRef2</span> <span class="o">=</span> <span class="n">expDimRef</span>
            <span class="k">break</span>

        <span class="k">if</span> <span class="n">expDimRef2</span><span class="p">:</span>
          <span class="k">for</span> <span class="n">peakDim2</span> <span class="ow">in</span> <span class="n">peakDim</span><span class="o">.</span><span class="n">peak</span><span class="o">.</span><span class="n">peakDims</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">peakDim2</span><span class="o">.</span><span class="n">dataDimRef</span> <span class="ow">and</span> <span class="p">(</span><span class="n">peakDim2</span><span class="o">.</span><span class="n">dataDimRef</span><span class="o">.</span><span class="n">expDimRef</span> <span class="ow">is</span> <span class="n">expDimRef2</span><span class="p">):</span>
              <span class="n">expBound</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

              <span class="k">for</span> <span class="n">contrib2</span> <span class="ow">in</span> <span class="n">peakDim2</span><span class="o">.</span><span class="n">peakDimContribs</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">contrib</span><span class="o">.</span><span class="n">peakContribs</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">contrib2</span><span class="o">.</span><span class="n">peakContribs</span><span class="p">):</span>
                  <span class="n">resonance2</span> <span class="o">=</span> <span class="n">contrib2</span><span class="o">.</span><span class="n">resonance</span>

                  <span class="k">if</span> <span class="n">resonance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">resonance2</span><span class="p">:</span>
                    <span class="n">expBound</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">resonance2</span><span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>
                  <span class="k">for</span> <span class="n">peakContrib</span> <span class="ow">in</span> <span class="n">contrib</span><span class="o">.</span><span class="n">peakContribs</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">peakContrib</span> <span class="ow">in</span> <span class="n">contrib2</span><span class="o">.</span><span class="n">peakContribs</span><span class="p">:</span>
                      <span class="n">resonance2</span> <span class="o">=</span> <span class="n">contrib2</span><span class="o">.</span><span class="n">resonance</span>

                      <span class="k">if</span> <span class="n">resonance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">resonance2</span><span class="p">:</span>
                        <span class="n">expBound</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">resonance2</span><span class="p">)</span>

                      <span class="k">break</span>

              <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">expBound</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Ambiguity</span>
                <span class="k">for</span> <span class="n">bound</span> <span class="ow">in</span> <span class="n">expBound</span><span class="p">:</span>
                  <span class="c1"># Leave the covalently bound one</span>
                  <span class="k">if</span> <span class="n">bound</span> <span class="ow">in</span> <span class="n">resonances</span><span class="p">:</span>
                    <span class="k">break</span>

                <span class="k">else</span><span class="p">:</span>
                  <span class="n">aSet</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">expBound</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">resonance</span><span class="o">.</span><span class="n">covalentlyBound</span><span class="p">)</span>
                  <span class="k">if</span> <span class="n">aSet</span> <span class="ow">and</span> <span class="n">aSet</span> <span class="o">!=</span> <span class="n">pairResonances</span><span class="p">:</span>
                    <span class="c1"># Resonances found. Previously linked.</span>
                    <span class="c1"># Not the pairResonances. Use them</span>
                    <span class="n">expResonances</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">aSet</span><span class="p">)</span>

                  <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># check presence of prochiral pairs</span>
                    <span class="n">ll</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">pairResonances</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">expBound</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pairResonances</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">ll</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                      <span class="n">foundBothPaired</span><span class="o">=</span> <span class="bp">True</span>
                    <span class="k">elif</span> <span class="n">ll</span><span class="p">:</span>
                      <span class="c1"># found some prochiral pair resonances - use them</span>
                      <span class="n">expResonances</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">ll</span><span class="p">)</span>
              <span class="k">else</span><span class="p">:</span>
                <span class="n">expResonances</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">expBound</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">foundBothPaired</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">expResonances</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">pairResonances</span><span class="p">]:</span>
    <span class="c1"># particular special case.</span>
    <span class="c1"># Resonance is bound to both prochiral alternatives but always as a pair.</span>

    <span class="k">if</span> <span class="n">recursiveCall</span><span class="p">:</span>
      <span class="c1"># This was called from elsewhere. We could resolve nothing, so send back to caller</span>
      <span class="k">pass</span>

    <span class="k">else</span><span class="p">:</span>
      <span class="c1"># call for sister resonances and see</span>
      <span class="n">resons</span> <span class="o">=</span> <span class="n">resonanceSet</span><span class="o">.</span><span class="n">sortedResonances</span><span class="p">()</span>
      <span class="n">newResonances</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">resons</span><span class="p">)</span><span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># there are sister resonances</span>
        <span class="n">resons</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">resonance</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">reson</span> <span class="ow">in</span> <span class="n">resons</span><span class="p">:</span>
          <span class="n">boundResons</span> <span class="o">=</span> <span class="n">_getBoundResonances</span><span class="p">(</span><span class="n">reson</span><span class="p">,</span> <span class="n">recalculate</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">contribs</span><span class="o">=</span><span class="n">contribs</span><span class="p">,</span>
                                            <span class="n">recursiveCall</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
          <span class="n">ll</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">pairResonances</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">boundResons</span><span class="p">]</span>
          <span class="k">if</span> <span class="ow">not</span> <span class="n">ll</span><span class="p">:</span>
            <span class="c1"># One sister was bound to both. Incorrect data. Bind to both here too</span>
            <span class="n">newResonances</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">pairResonances</span><span class="p">)</span>
            <span class="k">break</span>
          <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">ll</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">pairResonances</span><span class="p">):</span>
            <span class="c1"># Some resonances were taken. Use the free ones.</span>
            <span class="n">newResonances</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">ll</span><span class="p">)</span>

      <span class="k">if</span> <span class="n">newResonances</span><span class="p">:</span>
        <span class="n">expResonances</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">newResonances</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="c1"># No data anywhere to resolve which is which. Match on serials</span>
        <span class="n">pairResonList</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">pairResonances</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">operator</span><span class="o">.</span><span class="n">attrgetter</span><span class="p">(</span><span class="s1">&#39;serial&#39;</span><span class="p">)))</span>
        <span class="n">rr</span> <span class="o">=</span> <span class="n">pairResonList</span><span class="p">[</span><span class="n">resonanceSet</span><span class="o">.</span><span class="n">sortedResonances</span><span class="p">()</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">resonance</span><span class="p">)]</span>
        <span class="n">expResonances</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">rr</span><span class="p">)</span>


  <span class="n">resonances</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">expResonances</span><span class="p">)</span>

  <span class="c1">#if doWarning and (resonance.isotopeCode == &#39;1H&#39;) and (len(resonances) &gt; 1):</span>
  <span class="c1">#  pass</span>

  <span class="k">if</span> <span class="n">resonances</span><span class="p">:</span>
    <span class="n">resonance</span><span class="o">.</span><span class="n">setCovalentlyBound</span><span class="p">(</span><span class="n">resonances</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">resonance</span><span class="o">.</span><span class="n">setCovalentlyBound</span><span class="p">([])</span>

  <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">resonances</span><span class="p">)</span>




<span class="k">def</span> <span class="nf">_getBoundAtoms</span><span class="p">(</span><span class="n">atom</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Get a list of atoms bound to a given atom. NB ONLY for use in upgrade</span>
<span class="sd">  .. describe:: Input</span>

<span class="sd">  MolSystem.Atom</span>

<span class="sd">  .. describe:: Output</span>

<span class="sd">  List of MolSystem.Atoms</span>
<span class="sd">  &quot;&quot;&quot;</span>

  <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="s1">&#39;boundAtoms&#39;</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">atom</span><span class="o">.</span><span class="n">boundAtoms</span>

  <span class="n">atoms</span>    <span class="o">=</span> <span class="p">[]</span>
  <span class="n">chemAtom</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">chemAtom</span>
  <span class="n">residue</span>  <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">residue</span>

  <span class="n">chemAtomDict</span> <span class="o">=</span> <span class="p">{}</span>
  <span class="k">for</span> <span class="n">atom2</span> <span class="ow">in</span> <span class="n">residue</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
    <span class="c1"># Only atoms specific to ChemCompVar :-)</span>
    <span class="n">chemAtomDict</span><span class="p">[</span><span class="n">atom2</span><span class="o">.</span><span class="n">chemAtom</span><span class="p">]</span> <span class="o">=</span> <span class="n">atom2</span>

  <span class="k">for</span> <span class="n">chemBond</span> <span class="ow">in</span> <span class="n">chemAtom</span><span class="o">.</span><span class="n">chemBonds</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">chemAtom2</span> <span class="ow">in</span> <span class="n">chemBond</span><span class="o">.</span><span class="n">chemAtoms</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">chemAtom2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">chemAtom</span><span class="p">:</span>
        <span class="n">atom2</span> <span class="o">=</span> <span class="n">chemAtomDict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">chemAtom2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">atom2</span><span class="p">:</span>
          <span class="n">atoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atom2</span><span class="p">)</span>

  <span class="n">linkEnd</span> <span class="o">=</span> <span class="n">residue</span><span class="o">.</span><span class="n">chemCompVar</span><span class="o">.</span><span class="n">findFirstLinkEnd</span><span class="p">(</span><span class="n">boundChemAtom</span><span class="o">=</span><span class="n">chemAtom</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">linkEnd</span><span class="p">:</span>
    <span class="n">molResLinkEnd</span> <span class="o">=</span> <span class="n">residue</span><span class="o">.</span><span class="n">molResidue</span><span class="o">.</span><span class="n">findFirstMolResLinkEnd</span><span class="p">(</span><span class="n">linkEnd</span><span class="o">=</span><span class="n">linkEnd</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">molResLinkEnd</span><span class="p">:</span>
      <span class="n">molResLink</span> <span class="o">=</span> <span class="n">molResLinkEnd</span><span class="o">.</span><span class="n">molResLink</span>

      <span class="k">if</span> <span class="n">molResLink</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">molResLinkEnd2</span> <span class="ow">in</span> <span class="n">molResLink</span><span class="o">.</span><span class="n">molResLinkEnds</span><span class="p">:</span>
          <span class="k">if</span> <span class="n">molResLinkEnd2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">molResLinkEnd</span><span class="p">:</span>
            <span class="n">residue2</span> <span class="o">=</span> <span class="n">residue</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">findFirstResidue</span><span class="p">(</span><span class="n">molResidue</span><span class="o">=</span><span class="n">molResLinkEnd2</span><span class="o">.</span><span class="n">molResidue</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">residue2</span><span class="p">:</span>
              <span class="n">chemAtom2</span> <span class="o">=</span> <span class="n">molResLinkEnd2</span><span class="o">.</span><span class="n">linkEnd</span><span class="o">.</span><span class="n">boundChemAtom</span>
              <span class="n">atom2</span> <span class="o">=</span> <span class="n">residue2</span><span class="o">.</span><span class="n">findFirstAtom</span><span class="p">(</span><span class="n">chemAtom</span><span class="o">=</span><span class="n">chemAtom2</span><span class="p">)</span>

              <span class="k">if</span> <span class="n">atom2</span><span class="p">:</span>
                <span class="n">atoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atom2</span><span class="p">)</span>

            <span class="k">break</span>

  <span class="n">atom</span><span class="o">.</span><span class="n">boundAtoms</span> <span class="o">=</span> <span class="n">atoms</span>
  <span class="k">return</span> <span class="n">atoms</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">Python  documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright .
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.1.
    </div>
  </body>
</html>