"""
Module Documentation here
"""
#=========================================================================================
# Licence, Reference and Credits
#=========================================================================================
__copyright__ = "Copyright (C) CCPN project (http://www.ccpn.ac.uk) 2014 - 2021"
__credits__ = ("Ed Brooksbank, Joanna Fox, Victoria A Higman, Luca Mureddu, Eliza Płoskoń",
               "Timothy J Ragan, Brian O Smith, Gary S Thompson & Geerten W Vuister")
__licence__ = ("CCPN licence. See http://www.ccpn.ac.uk/v3-software/downloads/license")
__reference__ = ("Skinner, S.P., Fogh, R.H., Boucher, W., Ragan, T.J., Mureddu, L.G., & Vuister, G.W.",
                 "CcpNmr AnalysisAssign: a flexible platform for integrated NMR analysis",
                 "J.Biomol.Nmr (2016), 66, 111-124, http://doi.org/10.1007/s10858-016-0060-y")
#=========================================================================================
# Last code modification
#=========================================================================================
__modifiedBy__ = "$Author: Luca Mureddu $"
__modifiedBy__ = "$modifiedBy: Ed Brooksbank $"
__dateModified__ = "$Date: 2021-07-02 17:16:25 +0100 (Fri, July 02, 2021) $"
__version__ = "$Revision: 3.0.4 $"
#=========================================================================================
# Created
#=========================================================================================
__author__ = "$Author: Luca Mureddu $"
__date__ = "$Date: 2021-07-02 17:16:25 +0100 (Fri, July 02, 2021) $"
#=========================================================================================
# Start of code
#=========================================================================================

import uuid
import pandas as pd
from collections import OrderedDict as od
from collections import defaultdict
from ccpn.util.Logging import getLogger
from ccpn.core.lib.Cache import cached
from ccpnmodel.ccpncore.api.memops.Implementation import ComplexDataType as ApiType

#### Columns definitions
UUID            = 'UUID'
OBJ             = 'object'
HIERARCHY       = 'hierarchy'
ERRORMESSAGE    = 'errorMessage'
ISVALID         = 'isValid'
LEVEL           = 'level'
TYPENAME        = 'type'

#### Other definitions
CACHEDATA       = '_cachedData'
PARENT          = 'parent'
CHILD           = 'child'


def _getUniqueID():
    """
    Return  : str,  a 12 alphanumeric unique string ID. Used as index for each row in the _APIStatus DataFrame
    """
    _id = uuid.uuid4()
    uniqueID = str(_id).split('-')[-1]
    return uniqueID


class APIStatus(object):
    """
    This object builds a dataframe that contains a list of all current API objects status.
    Each row is an unique API object that has been checked for its validity.

    Parameters
    -----------------------------
        apiObj              : type, any API Object that contains children. E.g.: MemopsRoot
        build               : bool, True to initiate the machinery
        onlyInvalids        : bool, True to add to dataframe only failing objects. Reduces adding redundant info
        completeScan        : bool, True to perform a complete validity check of the API objects
        includeDefaultChildren  : bool, False to exclude objects for inspection such as ChemComps. See _excludedChildren

    Class properties
    ------------------------------
        _excludedChildren   : list, a list of children method definitions used to be excluded from inspection.
                            These objects are not queried for checkValid, as they are autogenerated for each new project
                            not modified by users and they should be always valid. Skipping reduces the computing time.
                            To force inspecting these too: set includeAllChildren to True

    Data Columns
    ------------------------------
        UUID                : str,  Unique ID. An identifier used as indexing value and stored as separate column
        OBJ                 : type, API object instance
        TYPENAME            : str,  Metaclass name of the API object
        HIERARCHY           : int,  Object hierarchy number in the tree: Root: 0; NmrProject: 1 etc...
        ISVALID             : bool, True if the object passes the method call "checkValid"
        ERRORMESSAGE        : str,  Any API raised errors


    """

    _reservedColumns = od((
                            (UUID,          ''),
                            (OBJ,           ''),
                            (TYPENAME,      ''),
                            (HIERARCHY,     ''),
                            (ISVALID,       ''),
                            (ERRORMESSAGE,  ''),
                            ))

    _excludedChildren = [
                         'chemCompCharges',
                         'chemCompCoords',
                         'chemComps',
                         'chemCompLabels',
                         'chemElementStores',
                         'molSystemSymmetrySets',
                         'nmrExpPrototypes',
                         'nmrReferenceStores',
                         'refSampleComponentStores',
                        ]

    def __init__(self, apiObj, build=True, onlyInvalids=True, completeScan=False, includeDefaultChildren=False):
        self._data = None
        self._addOnlyInvalidObjs = onlyInvalids
        self._includeAllChildren = includeDefaultChildren
        self._isCompleteScan = completeScan
        self._dataDict = defaultdict(list)
        self._dataDict.update({x:[] for x in self._reservedColumns})
        if build:
            self.buildAll(apiObj)

    @property
    @cached(CACHEDATA, maxItems=20000, debug=False)
    def data(self):
        "The dataframe that contains a list of all current API objects status"
        return self._data

    @data.getter
    def data(self):
        df = pd.DataFrame(self._dataDict)
        df.drop_duplicates(subset=[OBJ], inplace=True) # it shouldn't be any
        return df

    @property
    def invalidObjects(self):
        """
        A tuple of all invalid API objects
        """
        return tuple(self._getDFforValues(self.data, [False], ISVALID)[OBJ].values)

    @property
    def invalidObjectsErrors(self):
        """
        A tuple of all invalid API objects Errors
        """
        return tuple(self._getDFforValues(self.data, [False], ISVALID)[ERRORMESSAGE].values)

    @property
    def invalidObjectsAndErrors(self):
        """
        A tuple of tuples containing invalid object and error message
            ((obj1, error), ...)
        """
        df = self._getDFforValues(self.data, [False], ISVALID)
        return tuple(zip(df[OBJ], df[ERRORMESSAGE]))

    def __repr__(self):
        df = self.data
        df[OBJ] = df[OBJ].astype(str)
        return repr(df)

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Library functions
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    def buildAll(self, obj, level=0, methodNames=None):
        """
        Called recursively.
        Inspect recursively the tree hierarchy of an obj and add its status to the dictionary data

        Parameters
        -----------------------------
            obj         : type, API object
            level       : int,  hierarchical number of the object. Automatically given from recursion.
            methodNames : list, a list of method names to get the set of direct children.
                                Automatically detected if not explicitly given. Only given in recursive mode for speed
                                optimisation from the first instance of a loop.

        Return: None
        """
        methodNames = methodNames or self._getChildrenMethodNames(obj)
        for childrenMethodName in methodNames:
            try:
                children = getattr(obj, childrenMethodName, [])
            except Exception as errMesg:
                self.addChildStatusToDict(obj, isValid=False, errMesg=errMesg, level=level)
                continue
            if not children: continue
            childMethods = self._getChildrenMethodNames(list(children)[0]) # don't call same method for same instances
            for child in children:
                isValid, errMesg = self._getIsValidStatus(child)
                self.addChildStatusToDict(child, isValid=isValid, errMesg=errMesg, level=level+1)
                if childMethods:
                    self.buildAll(child, level=level+1, methodNames=childMethods)

    def addChildStatusToDict(self, child, isValid=None, errMesg=None, level=0):
        """
        Add the object status to the main dictionary.
        If _addOnlyInvalidObjs is set to True. Only invalid object are reported.
        """
        uniqueID = _getUniqueID()
        if isValid and self._addOnlyInvalidObjs:
            return
        if child.isDeleted:
            return 
        vv = ((UUID, uniqueID),
              (OBJ, child),
              (TYPENAME, child.className),
              (ISVALID, isValid),
              (ERRORMESSAGE, errMesg),
              (HIERARCHY, level))
        for k,v in vv:
            self._dataDict[k].append(v)

    def _getIsValidStatus(self, obj):
        """
        return tuple(bool, str)
        Compute "checkValid" method for an object.
        Return (True, '')  with empty str if no errors.
        Return (False, errorMessage) if an exception was raised.
        """
        try:
            obj.checkValid(complete=self._isCompleteScan)
            return (True, '')
        except Exception as e:
            return (False, str(e))

    def _getChildrenMethodNames(self, obj):
        """
        A list of method names to get the direct hierarchical children of an API object.
        """
        if not isinstance(obj, ApiType): return []
        methodNames = [a.name for a in obj.metaclass.getAllRoles() if a.hierarchy == CHILD]
        if not self._includeAllChildren: ## filter-out excluded children
            methodNames = [x for x in methodNames if x not in self._excludedChildren]
        return methodNames

    def _getDFforValues(self, df, values, headerName):
        return df[df[headerName].isin(values)]

# if __name__ == '__main__':
#     ## testing. Open a project and run this file
#     pr = project._wrappedData
#     mr = pr.root
#     status = _APIStatus(mr, onlyInvalids=True, includeDefaultChildren=True, completeScan=True)
#     print('status: ',status)

